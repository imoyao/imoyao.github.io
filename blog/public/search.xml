<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记一次 MySQL 内存不足错误</title>
      <link href="/blog/2019-11-05/mysqld-out-of-memory/"/>
      <url>/blog/2019-11-05/mysqld-out-of-memory/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>今天在访问博客的时候，登录首页发现无法正常加载博文。因为之前也出现过这种错误，怀疑还是因为数据库的问题，所以果断查看 MySQL 日志：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /var/log/mariadb/mariadb.log</span><br></pre></td></tr></table></figure></p><p>打到文件最后，分析日志：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">191104 17:48:04 mysqld_safe Number of processes running now: 0</span><br><span class="line">191104 17:48:05 mysqld_safe mysqld restarted</span><br><span class="line">191104 17:48:05 [Note] /usr/libexec/mysqld (mysqld 5.5.64-MariaDB) starting as process 11169 ...</span><br><span class="line">191104 17:48:05 InnoDB: The InnoDB memory heap is disabled</span><br><span class="line">191104 17:48:05 InnoDB: Mutexes and rw_locks use GCC atomic builtins</span><br><span class="line">191104 17:48:05 InnoDB: Compressed tables use zlib 1.2.7</span><br><span class="line">191104 17:48:05 InnoDB: Using Linux native AIO</span><br><span class="line">191104 17:48:05 InnoDB: Initializing buffer pool, size = 128.0M</span><br><span class="line">InnoDB: mmap(137756672 bytes) failed; errno 12</span><br><span class="line">191104 17:48:05 InnoDB: Completed initialization of buffer pool</span><br><span class="line">191104 17:48:05 InnoDB: Fatal error: cannot allocate memory for the buffer pool</span><br><span class="line">**错误信息从此行开始**</span><br><span class="line">191104 17:48:05 [ERROR] Plugin 'InnoDB' init function returned error.</span><br><span class="line">191104 17:48:05 [ERROR] Plugin 'InnoDB' registration as a STORAGE ENGINE failed.</span><br><span class="line">191104 17:48:05 [ERROR] mysqld: Out of memory (Needed 128917504 bytes)</span><br><span class="line">191104 17:48:05 [Note] Plugin 'FEEDBACK' is disabled.</span><br><span class="line">191104 17:48:05 [ERROR] Unknown/unsupported storage engine: InnoDB</span><br><span class="line">191104 17:48:05 [ERROR] Aborting</span><br><span class="line"></span><br><span class="line">191104 17:48:05 [Note] /usr/libexec/mysqld: Shutdown complete</span><br><span class="line">**服务停止**</span><br><span class="line">191104 17:48:05 mysqld_safe mysqld from pid file /var/run/mariadb/mariadb.pid ended</span><br></pre></td></tr></table></figure></p><p>确认是 MySQL 服务的问题，首先手动把 MySQL 启动起来，保证应用正常使用：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart mariadb</span><br></pre></td></tr></table></figure></p><p>之后服务恢复正常</p><h2 id="增加-swap-分区"><a href="#增加-swap-分区" class="headerlink" title="增加 swap 分区"></a>增加 swap 分区</h2><p>因为本身内存很小只有 1G，而 5.6（？）之后默认使用 innodb 引擎，这个引擎又很消耗内存。所以最好的办法是使用大内存或者将 MySQL 降级到一个合适的版本，但是，如果不是真的喜欢，谁愿意做一条舔狗呢？如果不是没钱，谁愿意用低配服务器呢。所以，退而求其次的办法就是增加一个 swap 分区，在内存不足时，使用 swap 分区。<br>接下来记录创建一个 1024M 的 swap 分区的办法。</p><h3 id="创建-swap-文件"><a href="#创建-swap-文件" class="headerlink" title="创建 swap 文件"></a>创建 swap 文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=/swapfile bs=1024 of=1048576 # 1024*1024</span><br></pre></td></tr></table></figure><h3 id="配置-swap-文件"><a href="#配置-swap-文件" class="headerlink" title="配置 swap 文件"></a>配置 swap 文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkswap /swapfile</span><br></pre></td></tr></table></figure><h3 id="立即启用-swap-文件"><a href="#立即启用-swap-文件" class="headerlink" title="立即启用 swap 文件"></a>立即启用 swap 文件</h3><p>而不是重启之后才生效<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swapon /swapfile</span><br></pre></td></tr></table></figure></p><h3 id="重启生效"><a href="#重启生效" class="headerlink" title="重启生效"></a>重启生效</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/fstab</span><br></pre></td></tr></table></figure><p>最后一行追加<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/swapfile       swap    swap defaults   0    0</span><br></pre></td></tr></table></figure></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_16_centos imoyao]# free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            991         697          70           0         223         120</span><br><span class="line">Swap:          1023           0        1023</span><br><span class="line">[root@VM_0_16_centos imoyao]# cat /proc/swaps </span><br><span class="line">FilenameTypeSizeUsedPriority</span><br><span class="line">/swapfile                               file1048572520-2</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.aimz8.com/?p=286" target="_blank" rel="noopener">MariaDB 在低配 VPS 上崩溃问题处理方案</a></p><h2 id="设置-MySQL-自动重启"><a href="#设置-MySQL-自动重启" class="headerlink" title="设置 MySQL 自动重启"></a>设置 MySQL 自动重启</h2><h3 id="是否设置-MySQL-服务-enable"><a href="#是否设置-MySQL-服务-enable" class="headerlink" title="是否设置 MySQL 服务 enable"></a>是否设置 MySQL 服务 enable</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl is-enabled mariadb</span><br></pre></td></tr></table></figure><p>如果返回不是<code>enabled</code>则使用命令<code>systemctl enable mariadb</code>进行使能</p><h3 id="编辑配置"><a href="#编辑配置" class="headerlink" title="编辑配置"></a>编辑配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/systemd/system/multi-user.target.wants/mariadb.service</span><br></pre></td></tr></table></figure><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>在<code>Service</code>配置项增加如下配置:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nu:30</span></span><br><span class="line">[Service]</span><br><span class="line">……</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=3</span><br><span class="line">……</span><br></pre></td></tr></table></figure></p><h3 id="配置生效"><a href="#配置生效" class="headerlink" title="配置生效"></a>配置生效</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重新启动来重导Systemd配置：</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新启动MariaDB服务</span></span><br><span class="line">systemctl restart mariadb</span><br></pre></td></tr></table></figure><p>参见<a href="https://www.codebye.com/how-to-config-centos7-mariadb-service-auto-start-after-reboot-or-crash.html" target="_blank" rel="noopener">如何配置 CentOS7 mariadb 服务在崩溃或重启后自动启动</a><br><a href="http://chengms.com/?p=151" target="_blank" rel="noopener">mariadb 在低配 ECS 上崩溃问题</a>  </p><h2 id="修改-MySQL-配置-调小-innodb-buffer-pool-size-参数"><a href="#修改-MySQL-配置-调小-innodb-buffer-pool-size-参数" class="headerlink" title="修改 MySQL 配置(调小 innodb_buffer_pool_size 参数)"></a>修改 MySQL 配置(调小 innodb_buffer_pool_size 参数)</h2><p>参见</p><ul><li><a href="https://www.v2ex.com/t/276069" target="_blank" rel="noopener">MySQL5.7.12 占用内存过多的原因到底是什么?</a>  </li><li><a href="https://www.v2ex.com/t/276069" target="_blank" rel="noopener">MySQL 调优之 innodb_buffer_pool_size 大小设置</a>  </li><li><a href="https://segmentfault.com/a/1190000017992793" target="_blank" rel="noopener">mariadb 内存占用优化</a>  </li><li><a href="https://segmentfault.com/a/1190000003072283" target="_blank" rel="noopener">MySQL 必须调整的 10 项配置优化</a>  </li><li><a href="https://blog.csdn.net/sunny05296/article/details/78916775" target="_blank" rel="noopener">MySQL 调优之 innodb_buffer_pool_size 大小设置</a>  </li><li><a href="http://www.bluestep.cc/%E4%BD%8E%E9%85%8D%E6%9C%8D%E5%8A%A1%E5%99%A8vps%E8%BF%90%E8%A1%8Cmysql%E7%BB%8F%E5%B8%B8%E5%B4%A9%E6%BA%83%EF%BC%9Aerror-mysqld-out-of-memory-needed-128663552-bytes/" target="_blank" rel="noopener">低配服务器 VPS 运行 MYSQL 经常崩溃：[ERROR] mysqld: Out of memory (Needed 128663552 bytes)</a>  </li></ul><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql --version</span><br><span class="line">mysql  Ver 15.1 Distrib 5.5.64-MariaDB, for Linux (x86_64) using readline 5.1</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM_0_16_centos imoyao]# cat /etc/system-release</span><br><span class="line">CentOS Linux release 7.6.1810 (Core)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：文中以<code>MariaDB</code>示例，关于其与<code>MySQL</code>的关系在此不做过多说明，如果使用<code>MySQL</code>作为数据库，以上配置命令可能略有不同。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://bobcares.com/blog/mysqld-out-of-memory/" target="_blank" rel="noopener">“mysqld: out of memory” – 4 major reasons why you get this error</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树深度优先遍历（DFS）和广度优先遍历（BFS）</title>
      <link href="/blog/2019-10-28/binary-tree-BFS-and-DFS/"/>
      <url>/blog/2019-10-28/binary-tree-BFS-and-DFS/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>二叉树每个节点最多有两个子树结构，分别是“左子树”（left subtree）和“右子树”(right subtree)。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h3><p>广度优先搜索(Breadth First Search),又称层次遍历。从树的根节点(root)开始，然后按照从上到下，从左到右的顺序依次遍历每一层的子节点直到遍历整个树的节点。</p><h3 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h3><p>对于一颗二叉树，深度优先遍历是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。树的深度优先遍历主要分为：前序遍历、中序遍历以及后序遍历</p><pre><code>- 前序遍历：若二叉树为空则结束，否则依次先访问根节点，然后访问左子树，最后访问右子树。- 中序遍历：若二叉树为空则结束，否则先访问根节点的左子树，然后访问根节点，最后访问右子数。- 后序遍历：若二叉树为空则结束，否则先访问根节点的左子树，然后访问右子数，最后访问根节点。深度优先一般采用递归的方式实现，递归的深度为树的高度。</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">        0               <span class="comment"># 层级遍历：0,1,2,3,4,5,6,7,8,9</span></span><br><span class="line">     /    \             <span class="comment"># 前序遍历：0,1,3,7,8,4,9,2,5,6</span></span><br><span class="line">    1      2            <span class="comment"># 中序遍历：7,3,8,1,9,4,0,5,2,6</span></span><br><span class="line">   / \    / \           <span class="comment"># 后序遍历：7,8,3,9,4,1,5,6,2,0</span></span><br><span class="line">  3   4  5   6</span><br><span class="line"> / \  /</span><br><span class="line">7   8 9</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.nowcoder.com/questionTerminal/b194924b44b144e8a238819a0a6dae42" target="_blank" rel="noopener">简述树的深度优先算法、广度优先算法，及非递归实现的特点。</a></li><li><a href="https://blog.csdn.net/xinxin957_/article/details/81915443" target="_blank" rel="noopener">Python 广度优先/深度优先遍历二叉树</a></li><li><a href="https://blog.csdn.net/zzfightingy/article/details/86742755" target="_blank" rel="noopener">python 实现二叉树的广度优先遍历和深度优先遍历</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ceph-calamari 安装记录</title>
      <link href="/blog/2019-10-23/ceph-calamari-install-guide/"/>
      <url>/blog/2019-10-23/ceph-calamari-install-guide/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="克隆源码"><a href="#克隆源码" class="headerlink" title="克隆源码"></a>克隆源码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /tmp/calamari-repo</span><br><span class="line"><span class="built_in">cd</span> /tmp/calamari-repo </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ceph/calamari.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ceph/Diamond.git </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ceph/calamari-clients.git</span><br></pre></td></tr></table></figure><h2 id="构建-calamari-server-的-rpm-包"><a href="#构建-calamari-server-的-rpm-包" class="headerlink" title="构建 calamari server 的 rpm 包"></a>构建 calamari server 的 rpm 包</h2><h2 id="生成-diamond-安装包"><a href="#生成-diamond-安装包" class="headerlink" title="生成 diamond 安装包"></a>生成 diamond 安装包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../Diamond</span><br><span class="line">git checkout origin/calamari</span><br><span class="line">yum install rpm-build -y</span><br><span class="line">make rpm</span><br></pre></td></tr></table></figure><p>将 diamond-<version>.noarch.rpm 复制到所有的 ceph 服务器，执行安装：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> dist/</span><br><span class="line"><span class="comment"># 方案1</span></span><br><span class="line">yum install python-configobj</span><br><span class="line">rpm -ivh diamond-&lt;version&gt;.noarch.rpm</span><br><span class="line"><span class="comment"># 方案2</span></span><br><span class="line">yum localinstall diamond-3.4.67-0.noarch.rpm</span><br></pre></td></tr></table></figure></version></p><h2 id="安装-salt-minion"><a href="#安装-salt-minion" class="headerlink" title="安装 salt-minion"></a>安装 salt-minion</h2><p>在所有的 ceph 服务器上安装 salt-minion<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install salt-minion</span><br></pre></td></tr></table></figure></p><p>创建<code>/etc/salt/minion.d/calamari.conf</code>，内容为：<br>master: {SERVER NODE HOSTNAME}<br>{SERVER NODE HOSTNAME}对应 calamari 服务器的域名。<br>启动 salt-minion 服务：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service salt-minion restart</span><br></pre></td></tr></table></figure></p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="Ceph-servers-are-connected-to-Calamari-but-no-Ceph-cluster-has-been-created-yet"><a href="#Ceph-servers-are-connected-to-Calamari-but-no-Ceph-cluster-has-been-created-yet" class="headerlink" title="Ceph servers are connected to Calamari, but no Ceph cluster has been created yet"></a>Ceph servers are connected to Calamari, but no Ceph cluster has been created yet</h3><p>安装完成之后，首页出现如下提示：</p><p><img src="/images/snipaste_20191106_133550.jpg" alt="New-Calamari-Installation"><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">This appears to be the first time you have started Calamari and there are no clusters currently configured.</span><br><span class="line"></span><br><span class="line">*some* Ceph servers are connected to Calamari, but no Ceph cluster has been</span><br><span class="line">created yet. Please use ceph-deploy to create a cluster; please see the</span><br><span class="line">Inktank Ceph Enterprise documentation for more details.</span><br></pre></td></tr></table></figure></p><p>具体<a href="https://github.com/ceph/calamari/issues/518" target="_blank" rel="noopener">见此处</a>    </p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li><p>执行<code>salt &#39;*&#39; ceph.get_heartbeats</code>，返回如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node2:</span><br><span class="line">    The minion function caused an exception: Traceback (most recent call last):</span><br><span class="line">      File "/usr/lib/python2.7/site-packages/salt/minion.py", line 1200, in _thread_return</span><br><span class="line">        return_data = func(*args, **kwargs)</span><br><span class="line">      File "/var/cache/salt/minion/extmods/modules/ceph.py", line 534, in get_heartbeats</span><br><span class="line">        service_data = service_status(filename)</span><br><span class="line">      File "/var/cache/salt/minion/extmods/modules/ceph.py", line 593, in service_status</span><br><span class="line">        fsid = json.loads(admin_socket(socket_path, ['status'], 'json'))['cluster_fsid']</span><br><span class="line">    KeyError: 'cluster_fsid'</span><br><span class="line">…… # It is same.</span><br><span class="line">    The minion function caused an exception: Traceback (most recent call last):</span><br><span class="line">      File "/usr/lib/python2.7/site-packages/salt/minion.py", line 1200, in _thread_return</span><br><span class="line">        return_data = func(*args, **kwargs)</span><br><span class="line">      File "/var/cache/salt/minion/extmods/modules/ceph.py", line 534, in get_heartbeats</span><br><span class="line">        service_data = service_status(filename)</span><br><span class="line">      File "/var/cache/salt/minion/extmods/modules/ceph.py", line 593, in service_status</span><br><span class="line">        fsid = json.loads(admin_socket(socket_path, ['status'], 'json'))['cluster_fsid']</span><br><span class="line">    KeyError: 'cluster_fsid'</span><br></pre></td></tr></table></figure></li><li><p>修改代码<code>AdminSocketError</code> 为 <code>(AdminSocketError,KeyError)</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    fsid = json.loads(admin_socket(socket_path, [<span class="string">'status'</span>], <span class="string">'json'</span>))[<span class="string">'cluster_fsid'</span>]</span><br><span class="line"><span class="keyword">except</span> (AdminSocketError,KeyError):  <span class="comment"># 此处也可以直接使用 Exception</span></span><br><span class="line">    <span class="comment"># older osd/mds daemons don't support 'status'; try our best</span></span><br><span class="line">   <span class="keyword">pass</span>             <span class="comment"># 此处代码不变</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>: 在<code>admin</code>节点，代码可能在 <code>/opt/calamari/salt/salt/_modules/ceph.py</code> 而在其他节点，代码可能在<code>/var/cache/salt/minion/extmods/modules/ceph.py</code>。</p><ul><li><p>在<code>admin</code>节点执行<code>salt &quot;*&quot; saltutil.sync_all</code>或者<code>systemctl restart salt-minion</code>，返回:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node3:</span><br><span class="line">    ----------</span><br><span class="line">    beacons:</span><br><span class="line">    grains:</span><br><span class="line">    modules:</span><br><span class="line">    output:</span><br><span class="line">    renderers:</span><br><span class="line">    returners:</span><br><span class="line">    sdb:</span><br><span class="line">    states:</span><br><span class="line">    utils:</span><br><span class="line">……</span><br><span class="line">node2:</span><br><span class="line">    ----------</span><br><span class="line">    beacons:</span><br><span class="line">    grains:</span><br><span class="line">    modules:</span><br><span class="line">    output:</span><br><span class="line">    renderers:</span><br><span class="line">    returners:</span><br><span class="line">    sdb:</span><br><span class="line">    states:</span><br><span class="line">    utils:</span><br></pre></td></tr></table></figure></li><li><p>然后，在<code>admin</code>节点执行<code>salt &#39;*&#39; ceph.get_heartbeats</code>，返回:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node2:</span><br><span class="line">    |_</span><br><span class="line">      ----------</span><br><span class="line">      boot_time:</span><br><span class="line">          1573005001</span><br><span class="line">      ceph_version:</span><br><span class="line">          2:13.2.6-0.el7</span><br><span class="line">      services:</span><br><span class="line">          ----------</span><br><span class="line">          ceph-mgr.node2:</span><br><span class="line">              ----------</span><br><span class="line">              cluster:</span><br><span class="line">                  ceph</span><br><span class="line">              fsid:</span><br><span class="line">                  47071b01-394e-4a62-bb2d-cfe3c19637f7</span><br><span class="line">              id:</span><br><span class="line">                  node2</span><br><span class="line">              status:</span><br><span class="line">                  None</span><br><span class="line">              type:</span><br><span class="line">                  mgr</span><br><span class="line">              version:</span><br><span class="line">                  13.2.6</span><br><span class="line">          ceph-osd.0:</span><br><span class="line">              ----------</span><br><span class="line">              cluster:</span><br><span class="line">                  ceph</span><br><span class="line">              fsid:</span><br><span class="line">                  47071b01-394e-4a62-bb2d-cfe3c19637f7</span><br><span class="line">              id:</span><br><span class="line">                  0</span><br><span class="line">              status:</span><br><span class="line">                  None</span><br><span class="line">              type:</span><br><span class="line">                  osd</span><br><span class="line">              version:</span><br><span class="line">                  13.2.6</span><br><span class="line">    |_</span><br><span class="line">      ----------</span><br><span class="line">……</span><br></pre></td></tr></table></figure></li><li><p>访问页面，获取到如此显示<br><img src="/images/snipaste_20191106_102957.jpg" alt="500_error">   </p><h3 id="500-错误，请联系管理员"><a href="#500-错误，请联系管理员" class="headerlink" title="500 错误，请联系管理员"></a>500 错误，请联系管理员</h3><p><a href="https://tracker.ceph.com/issues/13476" target="_blank" rel="noopener">此处</a>有关于该问题的描述。</p></li><li>查看calamari 日志<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tailf /var/log/calamari/calamari.log</span><br></pre></td></tr></table></figure></li></ul><p>获取到以下错误：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2019-11-05 21:02:19,605 - metric_access - django.request No graphite data for ceph.cluster.47071b01-394e-4a62-bb2d-cfe3c19637f7.df.total_used_bytes</span><br><span class="line">2019-11-05 21:02:19,606 - metric_access - django.request No graphite data for ceph.cluster.47071b01-394e-4a62-bb2d-cfe3c19637f7.df.total_used</span><br><span class="line">2019-11-05 21:02:19,606 - metric_access - django.request No graphite data for ceph.cluster.47071b01-394e-4a62-bb2d-cfe3c19637f7.df.total_space</span><br><span class="line">2019-11-05 21:02:19,607 - metric_access - django.request No graphite data for ceph.cluster.47071b01-394e-4a62-bb2d-cfe3c19637f7.df.total_avail</span><br><span class="line">2019-11-05 21:02:19,608 - ERROR - django.request Internal Server Error: /api/v1/cluster/47071b01-394e-4a62-bb2d-cfe3c19637f7/space</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/django/core/handlers/base.py", line 115, in get_response</span><br><span class="line">    response = callback(request, *callback_args, **callback_kwargs)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/rest_framework/viewsets.py", line 78, in view</span><br><span class="line">    return self.dispatch(request, *args, **kwargs)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_rest_api-0.1-py2.7.egg/calamari_rest/views/rpc_view.py", line 94, in dispatch</span><br><span class="line">    self.client.close()</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/zerorpc/core.py", line 293, in close</span><br><span class="line">    SocketBase.close(self)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/zerorpc/socket.py", line 37, in close</span><br><span class="line">    self._events.close()</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/zerorpc/events.py", line 198, in close</span><br><span class="line">    self._send.close()</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/zerorpc/events.py", line 50, in close</span><br><span class="line">    self._send_task.kill()</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/gevent/greenlet.py", line 235, in kill</span><br><span class="line">    waiter.get()</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/gevent/hub.py", line 575, in get</span><br><span class="line">    return self.hub.switch()</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/gevent/hub.py", line 338, in switch</span><br><span class="line">    return greenlet.switch(self)</span><br><span class="line">LostRemote: Lost remote after 10s heartbeat</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">2019-11-05 23:59:43,586 - ERROR - django.request Internal Server Error: /api/v1/cluster/47071b01-394e-4a62-bb2d-cfe3c19637f7/health_counters</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/django/core/handlers/base.py", line 115, in get_response</span><br><span class="line">    response = callback(request, *callback_args, **callback_kwargs)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/rest_framework/viewsets.py", line 78, in view</span><br><span class="line">    return self.dispatch(request, *args, **kwargs)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_rest_api-0.1-py2.7.egg/calamari_rest/views/rpc_view.py", line 91, in dispatch</span><br><span class="line">    return super(RPCViewSet, self).dispatch(request, *args, **kwargs)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/django/views/decorators/csrf.py", line 77, in wrapped_view</span><br><span class="line">    return view_func(*args, **kwargs)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/rest_framework/views.py", line 399, in dispatch</span><br><span class="line">    response = self.handle_exception(exc)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_rest_api-0.1-py2.7.egg/calamari_rest/views/rpc_view.py", line 108, in handle_exception</span><br><span class="line">    return super(RPCViewSet, self).handle_exception(exc)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/rest_framework/views.py", line 396, in dispatch</span><br><span class="line">    response = handler(request, *args, **kwargs)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_rest_api-0.1-py2.7.egg/calamari_rest/views/v1.py", line 315, in get</span><br><span class="line">    counters = self.generate(osd_data, mds_data, mon_status, pg_summary)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_rest_api-0.1-py2.7.egg/calamari_rest/views/v1.py", line 167, in generate</span><br><span class="line">    'mds': cls._calculate_mds_counters(mds_map),</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_rest_api-0.1-py2.7.egg/calamari_rest/views/v1.py", line 295, in _calculate_mds_counters</span><br><span class="line">    up = len(mds_map['up'])</span><br><span class="line">TypeError: 'NoneType' object has no attribute '__getitem__'</span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line">2019-11-06 00:00:53,567 - ERROR - django.request Internal Server Error: /api/v1/cluster/47071b01-394e-4a62-bb2d-cfe3c19637f7/osd</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/django/core/handlers/base.py", line 115, in get_response</span><br><span class="line">    response = callback(request, *callback_args, **callback_kwargs)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/rest_framework/viewsets.py", line 78, in view</span><br><span class="line">    return self.dispatch(request, *args, **kwargs)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_rest_api-0.1-py2.7.egg/calamari_rest/views/rpc_view.py", line 91, in dispatch</span><br><span class="line">    return super(RPCViewSet, self).dispatch(request, *args, **kwargs)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/django/views/decorators/csrf.py", line 77, in wrapped_view</span><br><span class="line">    return view_func(*args, **kwargs)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/rest_framework/views.py", line 399, in dispatch</span><br><span class="line">    response = self.handle_exception(exc)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_rest_api-0.1-py2.7.egg/calamari_rest/views/rpc_view.py", line 108, in handle_exception</span><br><span class="line">    return super(RPCViewSet, self).handle_exception(exc)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/rest_framework/views.py", line 396, in dispatch</span><br><span class="line">    response = handler(request, *args, **kwargs)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_rest_api-0.1-py2.7.egg/calamari_rest/views/v1.py", line 417, in get</span><br><span class="line">    osds, osds_by_pg_state = self.generate(pg_summary, osd_map, server_info, servers)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_rest_api-0.1-py2.7.egg/calamari_rest/views/v1.py", line 365, in generate</span><br><span class="line">    for pool_id, osds in osd_map.osds_by_pool.items():</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_common-0.1-py2.7.egg/calamari_common/util.py", line 8, in wrapper</span><br><span class="line">    rv = function(*args)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_common-0.1-py2.7.egg/calamari_common/types.py", line 206, in osds_by_pool</span><br><span class="line">    for rule in [r for r in self.data['crush']['rules'] if r['ruleset'] == pool['crush_ruleset']]:</span><br><span class="line">KeyError: 'crush_ruleset'</span><br><span class="line">2019-11-06 00:00:54,566 - metric_access - django.request No graphite data for ceph.cluster.47071b01-394e-4a62-bb2d-cfe3c19637f7.pool.1.num_objects</span><br></pre></td></tr></table></figure></p><p>查看 <code>cthulhu</code> 日志<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tailf /var/log/calamari/cthulhu.log</span><br></pre></td></tr></table></figure></p><p>返回如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2019-11-05 22:05:31,371 - WARNING - cthulhu Ignoring event salt/job/20191105220531366943/ret/node1</span><br><span class="line">2019-11-05 22:05:31,371 - WARNING - cthulhu.request_collection on_completion: unknown jid 20191105220531366943, return: None</span><br><span class="line">2019-11-05 22:05:38,283 - WARNING - cthulhu.request_collection on_completion: unknown jid 20191105220538277178, return: None</span><br><span class="line">2019-11-05 22:05:38,283 - WARNING - cthulhu Ignoring event salt/job/20191105220538277178/ret/node3</span><br><span class="line">2019-11-05 22:05:38,383 - WARNING - cthulhu Ignoring event salt/job/20191105220538379133/ret/node2</span><br><span class="line">2019-11-05 22:05:38,384 - WARNING - cthulhu.request_collection on_completion: unknown jid 20191105220538379133, return: None</span><br><span class="line">2019-11-05 22:05:41,384 - WARNING - cthulhu Abandoning fetch for mds_map started at 2019-11-06 03:05:31.344465+00:00</span><br><span class="line">2019-11-05 22:05:41,385 - ERROR - cthulhu Exception handling message with tag ceph/cluster/47071b01-394e-4a62-bb2d-cfe3c19637f7</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_cthulhu-0.1-py2.7.egg/cthulhu/manager/cluster_monitor.py", line 244, in _run</span><br><span class="line">    self.on_heartbeat(data['id'], data['data'])</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_cthulhu-0.1-py2.7.egg/cthulhu/gevent_util.py", line 35, in wrapped</span><br><span class="line">    return func(*args, **kwargs)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_cthulhu-0.1-py2.7.egg/cthulhu/manager/cluster_monitor.py", line 346, in on_heartbeat</span><br><span class="line">    cluster_data['versions'][sync_type.str])</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_cthulhu-0.1-py2.7.egg/cthulhu/manager/cluster_monitor.py", line 99, in on_version</span><br><span class="line">    self.fetch(reported_by, sync_type)</span><br><span class="line">  File "/opt/calamari/venv/lib/python2.7/site-packages/calamari_cthulhu-0.1-py2.7.egg/cthulhu/manager/cluster_monitor.py", line 109, in fetch</span><br><span class="line">    client = LocalClient(config.get('cthulhu', 'salt_config_path'))</span><br><span class="line">  File "/usr/lib/python2.7/site-packages/salt/client/__init__.py", line 126, in __init__</span><br><span class="line">    self.opts = salt.config.client_config(c_path)</span><br><span class="line">  File "/usr/lib/python2.7/site-packages/salt/config.py", line 2203, in client_config</span><br><span class="line">  File "/usr/lib/python2.7/site-packages/salt/utils/xdg.py", line 13, in xdg_config_dir</span><br><span class="line">  File "/opt/calamari/venv/lib64/python2.7/posixpath.py", line 269, in expanduser</span><br><span class="line">KeyError: 'getpwuid(): uid not found: 0'</span><br></pre></td></tr></table></figure></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/gaohong/p/4669524.html" target="_blank" rel="noopener">安装部署 Ceph Calamari</a></li><li><a href="https://www.cnblogs.com/flytor/p/11425135.html" target="_blank" rel="noopener">在CentOS 7 安装Calamari</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安装 </tag>
            
            <tag> Calamari </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步/异步与阻塞和非阻塞的区别？</title>
      <link href="/blog/2019-10-23/Explore-sync-async-blocking-nonblocking/"/>
      <url>/blog/2019-10-23/Explore-sync-async-blocking-nonblocking/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="https://ring0.me/2014/11/sync-async-blocked/" target="_blank" rel="noopener">大话同步/异步、阻塞/非阻塞</a><br><a href="https://baiweiblog.wordpress.com/tag/non-blocking/" target="_blank" rel="noopener">关于同步/异步 VS 阻塞/非阻塞的一点体会</a><br><a href="http://www.cs.unc.edu/~dewan/242/s06/notes/ipc/node9.html" target="_blank" rel="noopener">Synchronous vs Asynchronous</a><br><a href="https://blogs.msdn.microsoft.com/csliu/2009/08/27/io-concept-blockingnon-blocking-vs-syncasync/" target="_blank" rel="noopener">I/O Concept – Blocking/Non-Blocking VS Sync/Async</a><br><a href="https://github.com/calidion/calidion.github.io/issues/40" target="_blank" rel="noopener">同步，异步，阻塞，非阻塞等关系轻松理解</a><br><a href="https://blog.csdn.net/sinat_35512245/article/details/53836580" target="_blank" rel="noopener">深入理解并发/并行，阻塞/非阻塞，同步/异步</a><br><a href="https://mp.weixin.qq.com/s/0W9aHAGqyTfPkyOPF-Z_Xw" target="_blank" rel="noopener">迄今为止把同步/异步/阻塞/非阻塞/BIO/NIO/AIO 讲的这么清楚的好文章</a><br><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="noopener">怎样理解阻塞非阻塞与同步异步的区别？</a><br><a href="https://www.zhihu.com/question/28594409/answer/52763082" target="_blank" rel="noopener">I/O 多路复用技术（multiplexing）是什么？</a></p><h3 id="TODO-翻译此系列文章"><a href="#TODO-翻译此系列文章" class="headerlink" title="TODO: 翻译此系列文章"></a>TODO: 翻译此系列文章</h3><p><a href="https://luminousmen.com/post/asynchronous-programming-blocking-and-non-blocking" target="_blank" rel="noopener">系列文章 | Asynchronous programming. Blocking I/O and non-blocking I/O</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ceph 管理系统对比</title>
      <link href="/blog/2019-10-22/ceph-web-manage/"/>
      <url>/blog/2019-10-22/ceph-web-manage/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文主要在<a href="http://www.hl10502.com/2017/03/30/ceph-web-manage/" target="_blank" rel="noopener">Ceph 开源管理监控平台分析</a>基础上做一点补充。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>Ceph 的开源管理监控平台有如 VSM（三年前最后更新，read-only），InkScope，Calamari,<a href="https://www.suse.com/zh-cn/products/suse-enterprise-storage/" target="_blank" rel="noopener">Suse-enterprise-storage</a>等;</p><h2 id="VSM"><a href="#VSM" class="headerlink" title="VSM"></a>VSM</h2><p><img src="/images/img_20191022164357.jpg" alt="VSM"><br><a href="https://github.com/intel/virtual-storage-manager" target="_blank" rel="noopener">VSM | Virtual Storage Manager</a></p><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p><a href="https://01.org/zh/virtual-storage-manager" target="_blank" rel="noopener">virtual-storage-manager</a></p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>    Dashboard（vsm-dashboard）：VSM 的 webUI 界面，用户通过 Dashboard 来管理与监控 ceph 集群<br>    vsmclient（python-vsmclient）：VSM restapi 调用的 client<br>    API（vsm）：VSM 的 restapi<br>    scheduler（vsm）：VSM 的调度组件<br>    conductor（vsm）：VSM 的数据库操作组件，即所有的数据库操作都是通过 conductor 来调用 mysql<br>    RabbitMQ：消息中间件，VSM 的各个组件相对独立，都是通过发送消息，通过 RPC 的方式来相互调用<br>    agent（vsm）：VSM 代理服务</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>管理功能完善、充足</li><li>界面友好</li><li>可以部署 Ceph 和监控 Ceph</li><li>与 OpenStack 一脉传承，设计风格类似（详见架构部分说明）<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>非官方，社区维护，且目前已处于归档状态（read-only）</li><li>依赖 OpenStack 某些包和组件</li><li>封装一套自己的 rest-api，代码复杂度较高<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3>基于 Django 开发<h2 id="inkScope"><a href="#inkScope" class="headerlink" title="inkScope"></a>inkScope</h2><img src="/images/img_20191022164353.jpg" alt="inkScope"><br><a href="https://github.com/inkscope/inkscope" target="_blank" rel="noopener">inkScope</a><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3>Inscope 搭建的主要组件:</li></ol><ul><li>inkscope-common<br>包含 inkscope 的默认配置文件以及其他进程(cephprobe,sysprobe)启动所需的依赖文件，所有相关节点都需要安装。</li><li>inkscope-admviz<br>包含 inkscope 的 web 控制台文件，含接口和界面，仅需要安装一个，该节点（管理节点）上同时需要按安装 flask 和 mongodb</li><li>inkscope-cephrestapi<br>用于安装启动 ceph RESTful api 的脚本，仅需要安装在提供 api 接口的节点上，即 mon 节点。</li><li>inkscope-cephprobe<br>用于安装启动 cephprobe 的脚本(整个集群只需一个)，安装在 mon 节点，脚本主要实现：获取 Ceph 集群的一些信息，并使用端口（5000）提供服务，将数据存入 mongodb 数据库中。</li><li>inkscope-sysprobe<br>安装用于所有 mon 和 osd 的 sysprobe 所需要脚本，即所有节点均安装，实现获取节点设备资源信息如：CPU、内存、磁盘等等。<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><a href="https://blog.csdn.net/je930502/article/details/50812014" target="_blank" rel="noopener">Centos7.2：搭建 Ceph 管理系统 Inscope</a><br><a href="https://gtcsq.readthedocs.io/en/latest/others/inkscope_install.html" target="_blank" rel="noopener">Ceph web 管理/监控平台 Inkscope 部署</a><br><a href="http://cloud.51cto.com/art/201507/486005_all.htm" target="_blank" rel="noopener">开源 Ceph 管理平台 Inkscope 部署手册</a><h3 id="技术选型-1"><a href="#技术选型-1" class="headerlink" title="技术选型"></a>技术选型</h3>PHP（？）、Flask、MongoDB、AngularJS </li></ul><h2 id="Calamari"><a href="#Calamari" class="headerlink" title="Calamari"></a>Calamari</h2><p><img src="/images/img_20191022164326.jpg" alt="Calamari"><br><a href="https://github.com/ceph/calamari" target="_blank" rel="noopener">calamari</a></p><h3 id="组件-1"><a href="#组件-1" class="headerlink" title="组件"></a>组件</h3><p>Calamari 包含的组件主要有 calamari-server、romana、salt-minion、salt-master、diamond。</p><p>这些模块各自的作用：</p><ul><li><p>calamari-server<br>这个是提供一个与集群进行交互，并且自己封装了一个自己的 API，做集中管理的地方，这个只需要在集群当中的某一台机器上安装</p></li><li><p>romana<br>就是原来的 calamari-client，虽然叫 client,其实是一个 web 的界面，这个叫 calamari-web 更好，现在已经更名为 romana，这个只需要在集群当中的某一台机器上安装，需要跟 calamari-server 安装在一台机器上</p></li><li><p>salt-master<br>是一个远程管理的工具，可以批量的管理其他的机器，可以对安装了 salt-minion 的机器进行管理，在集群当中，这个也是跟 calamari-server 安装在一起的</p></li><li><p>salt-minion<br>是安装在集群的所有节点上的，这个是接收 salt-master 的指令对集群的机器进行操作，并且反馈一些信息到 salt-master 上</p></li><li><p>diamond<br>这个是系统的监控信息的收集控件，提供集群的硬件信息的监控和集群的信息的监控，数据是发送到 romana 的机器上的，是由 romana 上的 carbon 来收取数据并存储到机器当中的数据库当中的</p></li><li>Graphite<br>图形显示工具，其中 carbon 用来收集数据，whisper 是针对其专门开发的数据库，用来持久化数据，graphite-web 借助 Django、apache 等提供 web 服务，从而用浏览器可以图形化展示数据。</li></ul><p>Graphite 不仅是一个企业级的监控工具, 还可以实时绘图。Graphite 后端运行一个名为 carbon-cache.py 的 python 程序，是高度可扩展的事件驱动的 I/O 架构的后端进程，负责处理客户端节点上的业务数据，它可以有效地跟大量的客户端通信并且以较低的开销处理大量的业务量。配置文件位于/etc/graphite/carbon.conf；</p><p>Calamari 使用了 Saltstack 让 Calamari Server 和 Ceph server node 通信。Saltstack 是一个开源的自动化运维管理工具，与 Chef 和 Puppet 功能类似。Salt-master 发送指令给指定的 Salt-minion 来完成对 Cpeh Cluster 的管理工作；Salt-minion 在 Ceph server node 安装后都会从 master 同步并安装一个 ceph.py 文件，里面包含 Ceph 操作的 API，它会调用 librados 或命令行来最终和 Ceph Cluster 通信；</p><p>cthulhu 可以理解是 Calamari Server 的 Service 层，对上为 API 提供接口，对下调用 Salt-master。但是代码美中不足的是 calamari_rest 有些功能直接调用了 Salt-master 而没有调用 cthulhu。calamari_rest 提供 Calamari REST API，详细的接口请大家参照官方文档。Ceph 的 REST API 是一种低层次的接口，其中每个 URL 直接映射到等效的 CEPH CLI；Calamari REST API 提供了一个更高层次的接口，API 的使用者可以习惯的使用 GET/POST/PATCH 方法来操作对象，而无需知道底层的 Ceph 的命令；它们之间的主要区别在于，Ceph 的 REST API 的使用者需要非常了解 Ceph 本身，而 Calamari 的 REST API 更贴近对 Ceph 资源的描述，所以更加适合给上层的应用程序调用；<br>supervisord 是一个允许用户监控和控制进程数量的系统程序。它可以指定一个服务如何运行；<br>romana（calamari_clients）是一个提供 web UI 的模块，主要为客户端使用 Calamari API 提供服务，由 salt-minion 和 diamond 组成；<br>Diamond 负责收集监控数据，它支持非常多的数据类型和 metrics，通过查看源代码，它支持 90 多种类型的数据；每一个类型的数据都是上图中的一个 collector，它除了收集 Ceph 本身的状态信息，它还可以收集关键的资源使用情况和性能数据，包括 CPU，内存，网络，I / O 负载和磁盘指标，而且还能收集很多流行软件的性能指标，包括 Hadoop, Mongo, Kafka, MySQL, NetApp, RabbitMQ, Redis, and AWS S3 等。Collector 都是使用本地的命令行来收集数据，然后报告给 Graphite。</p><p>romana 包括 dashboard、login、admin、manage 四大模块，构建 rpm 软件包时，这些模块缺一不可。</p><ul><li>dashboard 是一个 javascript 的客户端，直接与 ceph restful api 交互来管理 ceph。dashboard 包含 3 个逻辑部分，分别为 dashboard、workbench、graphs。<br>　　- dashboard 是一个只读的视图，负责展现 ceph 集群的健康状态<br>　　- workbench 是后台 OSD 和 host 的虚拟展现，最多限制展现 256 个 OSD<br>　　- graphs 是有负责展示图形的 graphite 和负责在每个节点收集数据的 diamond 共同展示各种度量数据的视图</li><li>login 模块用于登录 web 界面</li><li>admin 模块用来管理用户和 calamari 信息的管理工具</li><li>manage 模块用于管理 ceph 集群中的各种应用，如 OSD 管理、pool 管理、集群设置和集群日志展现等功能</li></ul><p>calamari_clients 是一套用户界面，Calamari Server 在安装的过程中会首先创建 opt/calamari/webapp 目录，并且把 webapp/calamari 下的 manager.py(django 配置)文件考进去， calamari_web 的所有内容到要放到 opt/calamari/webapp 下面来提供 UI 的访问页面。</p><p>calamari-web 包下面的文件提供所有 web 相关的配置，calamari_rest 和 calamari_clients 都要用到。</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>轻量级</li><li>官方化</li><li>界面友好<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li><li>不易安装</li><li>管理功能滞后</li><li>提供的管理功能太少</li></ol><p>Calamari 为 Ceph 的运维和管理提供了一个统一的平台，而且用户还可以基于这个平台扩展自己的存储管理产品，但同时也存在着不足和需要改进的地方。</p><ol><li>Calamari 还不能完成 Ceph deploy 所实现的部署功能，这是它最大一个不足；Fuel 可以完成部署功能，并且可以选择 Ceph server 的数据盘和日志盘以及定制默认的备份数等，所以 Calamari + Fuel 可以来实现一个完成的基于 Ceph 的部署和管理工具。</li><li>Calamari 提供的管理功能太少，用户无法只使用它来运维一个 Ceph 环境。</li><li>用户可以基于 Calamari 开发自己的 Ceph 管理软件，UI 部分可以修改 calamari_clients 的页面，也可也单独实现一套自己的 UI 基于 calamari_rest 和 Graphite_web，后端的功能的监控部分可以扩展 diamond 的 collector 实现，管理 Ceph 的功能可以扩展 rest api，cthulhu，salt 等来实现。</li></ol><h3 id="搭建-1"><a href="#搭建-1" class="headerlink" title="搭建"></a>搭建</h3><p><a href="https://blog.csdn.net/hit1944/article/details/38752717" target="_blank" rel="noopener">calamari：基于 web 页面的 ceph 系统监控管理工具安装</a><br><a href="https://blog.51cto.com/linuxww/1944963" target="_blank" rel="noopener">ceph 监控管理平台 calamari</a><br><a href="https://www.gitbook.com/book/zphj1987/calamaribook" target="_blank" rel="noopener">calamari 从入门到放弃</a><br><a href="https://wiki.shileizcc.com/confluence/display/CEPH/Ceph%20Calamari" target="_blank" rel="noopener">ceph | calamari</a></p><h3 id="技术选型-2"><a href="#技术选型-2" class="headerlink" title="技术选型"></a>技术选型</h3><p>Django</p><h2 id="ceph-dash"><a href="#ceph-dash" class="headerlink" title="ceph-dash"></a>ceph-dash</h2><p><img src="/images/img_20191022173026.jpg" alt="ceph-dash"><br><a href="https://github.com/Crapworks/ceph-dash" target="_blank" rel="noopener">ceph-dash</a></p><h3 id="技术选型-3"><a href="#技术选型-3" class="headerlink" title="技术选型"></a>技术选型</h3><p>Flask</p><h2 id="ceph-DASHBOARD"><a href="#ceph-DASHBOARD" class="headerlink" title="ceph-DASHBOARD"></a>ceph-DASHBOARD</h2><p><img src="/images/snipaste_20191026_172347.jpg" alt="ceph-dashboard"><br>从 Luminous 开始，Ceph 提供了原生的 Dashboard 功能，通过 Dashboard 可以获取 Ceph 集群的各种基本状态信息。<br>具体参考官方文档说明：<a href="https://docs.ceph.com/docs/mimic/mgr/dashboard/#enabling-the-object-gateway-management-frontend" target="_blank" rel="noopener">DASHBOARD PLUGIN</a></p><h3 id="技术选型-4"><a href="#技术选型-4" class="headerlink" title="技术选型"></a>技术选型</h3><p>CherryPy、AngularJS<br><a href="https://blog.csdn.net/YoFog/article/details/85318736" target="_blank" rel="noopener">Ceph Mimic - 启用 Dashboard 功能</a></p><h2 id="横向对比"><a href="#横向对比" class="headerlink" title="横向对比"></a>横向对比</h2><p><a href="http://de.slideshare.net/Inktank_Ceph/07-ceph-days-sf2015-paul-evans-static" target="_blank" rel="noopener">ceph-days-sf2015</a></p><h3 id="对比背景"><a href="#对比背景" class="headerlink" title="对比背景"></a>对比背景</h3><p><img src="/images/img_20191022163356.jpg" alt></p><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><p><img src="/images/img_20191022164343.jpg" alt="management"></p><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p><img src="/images/img_20191022164348.jpg" alt="monitor"></p><h2 id="一种声音"><a href="#一种声音" class="headerlink" title="一种声音"></a>一种声音</h2><blockquote><p>从 ceph 社区 qq 群看过去，总会有一些运维或者开发询问哪种 ceph 管理平台方便好用，然后就开始对比 inkscope、vsm、calamari。其实这些都不是重点，重点是看看 github 上的这些项目已经 long long ago 不更新代码了，也就是说软件的生命周期走到了尽头，没有更新和扩展。想想群里的兄弟在生产环境上用这些软件，最后是什么结果……况且大部分公司都是一两个码农在搬砖，投入到开发这三个监控平台上也不现实。</p><p>大部分生产环境都是用 cli 对 ceph 进行管理，所以生产环境对 ceph 的管理需求不大。在监控上，ustack 之前的文档提过了一套监控方案。建议关注一下<a href="https://prometheus.io/" target="_blank" rel="noopener">prometheus</a>项目。前台集成 grafana，运维人员根据自己实际需求，DIY 监控面板，配合后端 exporters 很小的开发量，实现监控任意指标。报警方面 prometheus 也有自己的解决方案。联邦机制的实现可以使监控平台横向扩展。目前很多公司的生产环境都在用此方案。考虑到大规模运营，后续还需要 ELK 等工具的帮助。</p></blockquote><p><a href="https://my.oschina.net/yangfanlinux/blog/783756" target="_blank" rel="noopener">关于 ceph 监控管理平台的一点个人观点</a></p><p>完整文档<a href="/doc/Ceph-manager-explore.pdf">点此</a>     </p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.zphj1987.com/" target="_blank" rel="noopener">zphj1987</a><br><a href="http://www.hl10502.com/2017/03/30/ceph-web-manage/" target="_blank" rel="noopener">Ceph 开源管理监控平台分析</a><br><a href="https://www.cnblogs.com/luxiaodai/p/10043183.html" target="_blank" rel="noopener">CEPH 监控软件</a><br><a href="http://de.slideshare.net/Inktank_Ceph/07-ceph-days-sf2015-paul-evans-static" target="_blank" rel="noopener">ceph-days-sf2015</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> Ceph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019 面试记录</title>
      <link href="/blog/2019-10-18/interview-record-2019/"/>
      <url>/blog/2019-10-18/interview-record-2019/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="FunPlus-小视频业务"><a href="#FunPlus-小视频业务" class="headerlink" title="FunPlus (小视频业务)"></a>FunPlus (小视频业务)</h2><h3 id="数据库的事务隔离机制"><a href="#数据库的事务隔离机制" class="headerlink" title="数据库的事务隔离机制"></a>数据库的事务隔离机制</h3><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul><li><p>READ UNCOMMITTED（未提交读）<br>这个级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，被称为脏读（Dirty Read），这个级别性能不会比其他级别好太多，但缺乏其他级别的很多好处，一般很少使用。</p></li><li><p>READ COMMITTED（提交读）<br>这个级别是大多数数据库系统的默认隔离级别（但 MySQL 不是）。一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别也叫作不可重复读（nonrepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。</p></li><li><p>REPEATABLE READ（可重复读）<br>该级别保证了在同一个事务中多次读取同样记录的结果是一致的，但依然无法解决另外一个幻读（Phantom Read）的问题。幻读，指的是当某个事物在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。InnoDB 和 XtraDB 存储引擎通过多版本并发控制（MVCC）解决了幻读的问题。可重复读是 MySQL 的默认事务隔离级别。</p></li><li><p>SERIALIZABLE（可串行化）<br>最高的隔离级别，强制事务串行执行，避免了前面说的幻读的问题。但每次读都需要获得表级共享锁，读写相互都会阻塞。</p></li></ul><p>所有隔离级别</p><ol><li><p>read uncommitted : 读取尚未提交的数据 ：哪个问题都不能解决</p></li><li><p>read committed：读取已经提交的数据 ：可以解决脏读 —- oracle 默认的</p></li><li><p>repeatable read：可重复读：可以解决脏读 和 不可重复读 —- mysql 默认的</p></li><li><p>serializable：串行化：可以解决 脏读 不可重复读 和 虚读—-相当于锁表</p></li></ol><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读（read uncommited）</td><td>×</td><td>×</td><td>×</td></tr><tr><td>提交读（read commited）</td><td>√</td><td>×</td><td>×</td></tr><tr><td>可重复读（repeatable read）</td><td>√</td><td>√</td><td>×</td></tr><tr><td>串行化（serialziable)</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>注：×表示有该问题，√表示解决该问题。</p><ol><li><p>脏读：事务 A 读取了事务 B 更新的数据，然后 B 进行回滚操作，那么 A 读取到的数据是脏数据；</p></li><li><p>不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致;</p></li><li><p>幻读：“当事务 A 要对数据表中某个字段的所有值进修改操作，此时有一个事务是插入一条记录 并提交给数据库，当提交事务 A 的用户再次查看时就会发现有一行数据未被修改，其实是事务 B 刚刚添加进去的”，这就是幻读；</p></li></ol><p>隔离级别越高，越能保证数据的完整性和统一性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为 Read Committed。它能够避免脏读，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p><p><a href="https://blog.csdn.net/xiancaione/article/details/82157019" target="_blank" rel="noopener">mysql 事务隔离机制&amp;锁</a><br><a href="https://blog.csdn.net/weixin_39651041/article/details/79980202" target="_blank" rel="noopener">数据库事务和四种隔离级别</a></p><h3 id="flask-组件及源码剖析"><a href="#flask-组件及源码剖析" class="headerlink" title="flask 组件及源码剖析"></a>flask 组件及源码剖析</h3><ul><li><a href="https://segmentfault.com/a/1190000009152550" target="_blank" rel="noopener">一个 Flask 应用运行过程剖析</a></li><li><a href="https://www.jianshu.com/p/2a2407f66438" target="_blank" rel="noopener">Flask 的请求处理流程和上下文</a></li><li><a href="https://cizixs.com/2017/01/10/flask-insight-introduction/" target="_blank" rel="noopener">flask 源码解析</a></li><li><a href="https://www.cnblogs.com/weihengblog/p/9490561.html" target="_blank" rel="noopener">Flask 源码解析:Flask 应用执行流程及原理</a></li><li><a href="https://www.cnblogs.com/Utopia-Clint/p/10824238.html" target="_blank" rel="noopener">Flask 面试题</a></li><li><a href="https://blog.csdn.net/bestallen/article/details/54342120" target="_blank" rel="noopener">Flask 源码解读 | 浅谈 Flask 基本工作流程</a></li></ul><h3 id="redis-中的数据类型，其中列表和有序集合有什么区别"><a href="#redis-中的数据类型，其中列表和有序集合有什么区别" class="headerlink" title="redis 中的数据类型，其中列表和有序集合有什么区别"></a>redis 中的数据类型，其中列表和有序集合有什么区别</h3><h4 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h4><p>List 内部数据结构是双向链表，可以在链表左、右两边分别操作，所以插入数据的速度很快。</p><p>也可以把 list 看成一种队列，所以在很多时候可以用 redis 用作消息队列，这个时候它的作用类似于 activeMq；</p><p>但是缺点就是在数据量比较大的时候，访问某个数据的时间可能会很长，但针对这种情况，可以使用 zset。</p><p>应用案例有时间轴数据，评论列表，消息传递等等，它可以提供简便的分页，读写操作。</p><h4 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h4><p>Set 就是一个集合，内部数据结构是整数集合(intset)、HASH 表，集合的概念就是一堆<strong>不重复值</strong>的组合。利用 Redis 提供的 Set 数据结构，可以存储一些集合性的数据。</p><p>比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。</p><p>因为 Redis 非常人性化的为集合提供了求交集、并集、差集等操作，那么就可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。</p><p>1.共同好友、二度好友<br>2.利用唯一性，可以统计访问网站的所有独立 IP<br>3.好友推荐的时候，根据 tag 求交集，大于某个阈值（threshold）就可以推荐</p><h4 id="Zset-集合（Sorted-Sets）"><a href="#Zset-集合（Sorted-Sets）" class="headerlink" title="Zset 集合（Sorted Sets）"></a>Zset 集合（Sorted Sets）</h4><p>Sorted Set 有点像 Set 和 Hash 的结合体。</p><p>和 Set 一样，它里面的元素是唯一的，但是 Set 里面的元素是无序的，而 Sorted Set 里面的元素都带有一个浮点值，叫做分数（score），内部数据结构跳跃表，所以这一点和 Hash 有点像，因为每个元素都映射到了一个值。<br>使它在 set 的基础上增加了一个<strong>顺序属性</strong>，这一属性在添加修改元素的时候可以指定，每次指定后，zset 会自动重新按新的值调整顺序。可以对指定键的值进行排序权重的设定，它应用排名模块比较多。</p><p>比如一个存储全班同学成绩的 Sorted Sets，其集合 value 可以是同学的学号，而 score 就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用 Sorted Sets 来做带权重的队列，比如普通消息的 score 为 1，重要消息的 score 为 2，然后工作线程可以选择按 score 的倒序来获取工作任务，让重要的任务优先执行。</p><p>zset 集合可以完成有序执行、按照优先级执行的情况；</p><ul><li><a href="https://www.cnblogs.com/xuzhengzong/p/7724841.html" target="_blank" rel="noopener">redis 五种数据结构详解（string，list，set，zset，hash）</a></li><li><a href="https://www.cnblogs.com/tangge/p/10698821.html" target="_blank" rel="noopener">Redis 实战 - list、set 和 Sorted Set</a></li></ul><h2 id="独到科技"><a href="#独到科技" class="headerlink" title="独到科技"></a>独到科技</h2><h3 id="进程线程以及协程"><a href="#进程线程以及协程" class="headerlink" title="进程线程以及协程"></a>进程线程以及协程</h3><ol><li><p>进程<br>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,<strong>进程是系统进行资源分配和调度的基本单位</strong>。每个进程都有自己的独立内存空间，不同进程通过进程间通信*（IPC）来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p></li><li><p>线程<br><strong>线程是进程的一个实体,是 CPU 调度和分派的基本单位</strong>,它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p></li><li><p>协程<br>协程是一种<strong>用户态</strong>的<strong>轻量级线程</strong>，<strong>协程的调度完全由用户控制</strong>。<strong>协程拥有自己的寄存器上下文和栈</strong>。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。可以利用到并发优势，又可以<strong>避免反复系统调用和进程切换造成的开销</strong>。</p></li></ol><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>进程与线程比较</li></ul><p>线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:</p><ol><li>地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间</li><li>资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源</li><li>线程是处理器调度的基本单位,但进程不是</li><li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</li></ol><ul><li>协程与线程进行比较</li></ul><ol><li>一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样 python 中则能使用多核 CPU。</li><li>线程进程都是同步机制，而协程则是<strong>异步</strong></li><li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</li></ol><p>内核态的线程是由操作系统来进行调度的，在切换线程上下文时，要先保存上一个线程的上下文，然后执行下一个线程，当条件满足时，切换回上一个线程，并恢复上下文。协程也是如此，只不过，用户态的线程不是由操作系统来调度的，而是由程序员来调度的，是在用户态的。<br><a href="https://www.cnblogs.com/lxmhhy/p/6041001.html" target="_blank" rel="noopener">进程和线程、协程的区别</a></p><h3 id="二叉树的深度优先算法和广度优先算法"><a href="#二叉树的深度优先算法和广度优先算法" class="headerlink" title="二叉树的深度优先算法和广度优先算法"></a>二叉树的深度优先算法和广度优先算法</h3><p>二叉树的<strong>深度优先</strong>遍历的非递归的通用做法是<strong>采用栈</strong>，<strong>广度优先</strong>遍历的非递归的通用做法是<strong>采用队列</strong>。<br>1：树的深度优先遍历主要分为：前序遍历、中序遍历以及后序遍历</p><pre><code>- 前序遍历：若二叉树为空则结束，否则依次先访问根节点，然后访问左子树，最后访问右子树。- 中序遍历：若二叉树为空则结束，否则先访问根节点的左子树，然后访问根节点，最后访问右子数。- 后序遍历：若二叉树为空则结束，否则先访问根节点的左子树，然后访问右子数，最后访问根节点。 深度优先一般采用递归的方式实现，递归的深度为树的高度。</code></pre><p>2：树的广度优先算法：广度优先是按照层次来遍历树的节点，先是根节点，然后依次遍历第二层子节点，当第二层子节点遍历完后，在依次遍历第三层子节点。广度优先采用队列来记录当前可遍历的节点，当遍历某个节点时，将其左孩子和右孩子结点依次入队，待该层遍历完了以后，再依次遍历下一层儿子结点。<br>3：非递归实现特点： 深度优先一般采用递归实现，如改用非递归，则可需要来模拟栈，当需要先遍历当前节点的儿子结点时（例如中序遍历）需要将其压入栈中，先遍历其儿子结点，然后再将其弹出栈，遍历当前节点。广度优先一般采用非递归来实现，用一个队列来保存依次需要遍历的节点。<br><a href="https://www.nowcoder.com/questionTerminal/b194924b44b144e8a238819a0a6dae42" target="_blank" rel="noopener">简述树的深度优先算法、广度优先算法，及非递归实现的特点</a><br><a href="https://nullcc.github.io/2018/06/07/广度优先搜索(BFS" target="_blank" rel="noopener">广度优先搜索(BFS)和深度优先搜索(DFS)</a>和深度优先搜索(DFS)/)<br><code>https://nullcc.github.io/2018/06/07/广度优先搜索(BFS)和深度优先搜索(DFS)/</code></p><h3 id="Python-垃圾回收机制"><a href="#Python-垃圾回收机制" class="headerlink" title="Python 垃圾回收机制"></a>Python 垃圾回收机制</h3><p><a href="https://github.com/imoyao/interview_python#24-python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">Python 垃圾回收机制</a></p><ul><li>引用计数<br>PyObject 是每个对象必有的内容，其中 ob_refcnt 就是做为引用计数。当一个对象有新的引用时，它的 ob_refcnt 就会增加，当引用它的对象被删除，它的 ob_refcnt 就会减少。引用计数为 0 时，该对象生命就结束了。</li><li>标记-清除机制<br>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</li><li>分代技术<br>分代回收是一种以空间换时间的操作方式，Python 将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python 将内存分为了 3“代”，分别为年轻代（第 0 代）、中年代（第 1 代）、老年代（第 2 代），他们对应的是 3 个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python 垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。</li></ul><p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p><h3 id="Python-传值还是传引用"><a href="#Python-传值还是传引用" class="headerlink" title="Python 传值还是传引用"></a>Python 传值还是传引用</h3><p>python 参数传递采用的是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。如果函数收到的是一个不可变对象（数字、字符或元组）的引用，就不能直接修改原始对象——相当于通过‘值传递’来传递对象。如果函数收到的是一个可变对象（字典、列表）的引用，就能修改对象的原始值——相当于‘传引用’来传递对象。<br><a href="https://www.masantu.com/blog/2019-04-13/python-pass-by-object-reference/" target="_blank" rel="noopener">Python 传值还是传引用？| 通过对象引用传递</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🐍PyTricks | 如何更新一个嵌套字典的值？</title>
      <link href="/blog/2019-09-25/update-value-of-a-nested-dictionary-of-varying-depth/"/>
      <url>/blog/2019-09-25/update-value-of-a-nested-dictionary-of-varying-depth/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_nested_dict</span><span class="params">(orig_dict, new_dict)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    更新嵌套字典</span></span><br><span class="line"><span class="string">    params = &#123;'state':'1','message':'9527','result':&#123;'hello':'world','foo':'bar','age':32&#125;&#125;</span></span><br><span class="line"><span class="string">    new_dict = &#123;'name':'Peter'&#125;</span></span><br><span class="line"><span class="string">    &#123;'state': '1', 'message': '9527', 'name': 'Peter', 'result': &#123;'age': 32, 'foo': 'bar', 'hello': 'world'&#125;&#125;</span></span><br><span class="line"><span class="string">    ---</span></span><br><span class="line"><span class="string">    new_dict = &#123;'result':&#123;'foo':'baz'&#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;'state': '1', 'message': '9527', 'result': &#123;'age': 32, 'foo': 'baz', 'hello': 'world'&#125;&#125;</span></span><br><span class="line"><span class="string">    new_dict = &#123;'result':&#123;'name':'Peter'&#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;'state': '1', 'message': '9527', 'result': &#123;'age': 32, 'foo': 'bar', 'hello': 'world', 'name': 'Peter'&#125;&#125;</span></span><br><span class="line"><span class="string">    ---</span></span><br><span class="line"><span class="string">    new_dict = &#123;'result':&#123;'hobbies':['reading','fishing','play game']&#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;'state': '1', 'message': '9527', 'result': &#123;'age': 32, 'foo': 'bar', 'hello': 'world', 'hobbies': ['reading', 'fishing', 'play game']&#125;&#125;</span></span><br><span class="line"><span class="string">    ---</span></span><br><span class="line"><span class="string">    params = &#123;'state':'1','message':'9527','result':&#123;'hello':'world','foo':'bar','age':32,'hobbies':['coding']&#125;&#125;</span></span><br><span class="line"><span class="string">    new_dict = &#123;'result':&#123;'hobbies':['reading','fishing','play game']&#125;&#125;</span></span><br><span class="line"><span class="string">    &#123;'state': '1', 'message': '9527', 'result': &#123;'age': 32, 'foo': 'bar', 'hello': 'world', 'hobbies': ['coding', 'reading', 'fishing', 'play game']&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> key, val <span class="keyword">in</span> new_dict.iteritems():</span><br><span class="line">        <span class="keyword">if</span> isinstance(val, collections.Mapping):</span><br><span class="line">            tmp = update_nested_dict(orig_dict.get(key, &#123;&#125;), val)</span><br><span class="line">            orig_dict[key] = tmp</span><br><span class="line">        <span class="keyword">elif</span> isinstance(val, list):</span><br><span class="line">            orig_dict[key] = (orig_dict.get(key, []) + val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            orig_dict[key] = new_dict[key]</span><br><span class="line">    <span class="keyword">return</span> orig_dict</span><br></pre></td></tr></table></figure><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p><a href="https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth" target="_blank" rel="noopener">Update value of a nested dictionary of varying depth</a></p>]]></content>
      
      
      <categories>
          
          <category> 🐍PyTricks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 和 UDP 的区别</title>
      <link href="/blog/2019-09-21/differences-between-tcp-and-udp/"/>
      <url>/blog/2019-09-21/differences-between-tcp-and-udp/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>TCP 传输控制协议（ Transmission Control Protocol）和 UDP 用户数据报协议（User Datagram Protocol）是在传输层运行的主要协议。传输控制协议（TCP）和用户数据报协议（UDP）的操作方式非常不同，你可以根据需要选择传输控制协议（TCP）或用户数据报协议（UDP）。</p><p>TCP 代表传输控制协议，它保证数据包的传送。该协议提供了广泛的错误检查机制，例如流控制和数据确认。传输控制协议（TCP）是面向连接的协议。在传输数据之前，必须确保在参与数据传输的设备之间建立连接。如果您的应用程序需要保证数据的传输，则必须选择 TCP 作为传输层协议。</p><p>UDP 代表用户数据报协议，它以数据报模式运行。在此处应注意的主要区别是用户数据报协议（UDP）是一种无连接协议。用户数据报协议（UDP）仅具有使用校验和的基本错误检查机制。</p><h2 id="传输控制协议（TCP）和用户数据报协议（UDP）之间的区别"><a href="#传输控制协议（TCP）和用户数据报协议（UDP）之间的区别" class="headerlink" title="传输控制协议（TCP）和用户数据报协议（UDP）之间的区别"></a>传输控制协议（TCP）和用户数据报协议（UDP）之间的区别</h2><h3 id="传输控制协议（TCP）"><a href="#传输控制协议（TCP）" class="headerlink" title="传输控制协议（TCP）"></a>传输控制协议（TCP）</h3><ol><li><p>TCP 是面向连接的协议，这意味着设备应在传输数据之前打开连接，并在传输数据后正常关闭连接。</p></li><li><p>TCP 确保将数据可靠地传递到目的地。</p></li><li><p>TCP 协议提供了广泛的错误检查机制，例如流控制和数据确认。</p></li><li><p>TCP 具有数据排序的功能。</p></li><li><p>TCP 可以保证数据的传输。</p></li><li><p>由于广泛的错误检查机制，TCP 相对较慢。</p></li><li><p>在 TCP 中使用 TCP 端口号可以进行多路复用和多路分解。</p></li><li><p>在 TCP 中可以重新传输丢失的数据包。</p></li></ol><h3 id="用户数据报协议（UDP）"><a href="#用户数据报协议（UDP）" class="headerlink" title="用户数据报协议（UDP）"></a>用户数据报协议（UDP）</h3><ol><li><p>UDP 是面向数据报的协议，无需任何开销即可打开连接（使用三向握手），维护连接以及关闭（终止）连接。</p></li><li><p>UDP 对于网络传输的广播/多播类型非常有效。</p></li><li><p>UDP 仅具有使用校验和的基本错误检查机制。</p></li><li><p>UDP 中没有数据排序。</p></li><li><p>UDP 中不能保证数据的传递。</p></li><li><p>UDP 比 TCP 更快，更简单，更高效。但是，UDP 的可靠性不如 TCP</p></li><li><p>在使用 UDP 端口号的 UDP 中可以进行复用和解复用。</p></li><li><p>UDP 中没有丢失分组的重传。</p></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.omnisecu.com/tcpip/differences-between-tcp-and-udp.php" target="_blank" rel="noopener">Differences between TCP and UDP</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 三次握手与四次挥手</title>
      <link href="/blog/2019-09-20/tcp-connection-3-way-handshake-and-termination-4-way-handshake/"/>
      <url>/blog/2019-09-20/tcp-connection-3-way-handshake-and-termination-4-way-handshake/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="TCP-头部"><a href="#TCP-头部" class="headerlink" title="TCP 头部"></a>TCP 头部</h2><p><img src="/images/tcp-head-en.jpg" alt="tcp头部"><br><img src="/images/tcp-head-cn.jpg" alt="tcp头部"><br>上面就是 TCP 协议头部的格式，它非常重要，是理解其它内容的基础，下面将每个字段的信息都详细的说明一下：</p><ul><li>Source Port<br>  16 位，用于标识源端口号（发送机器 TCP 端口）</li><li>Destination Port<br>  16 位，用于标识目的端口号（接收端口）</li><li>Sequence Number<br>  32 位，用于 TCP 段的字节级别编号。如果使用 TCP 连接，则为数据的每个字节分配一个序列号。如果设置了 SYN 标志（在<em>三向握手连接</em>初始化期间），则是初始序列号。 然后，实际第一个数据字节的序列号将是此序列号加 1。例如，让设备在特定 TCP 报头中的数据的第一个字节在该字段 50000 中将具有其序列号。如果此数据包有 500 字节中的数据，那么此设备发送的下一个数据包将具有 50000 + 500 + 1 = 50501 的序列号。</li><li>Acknowledgment Number<br>  32 位，确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加 1。不过，只有当标志位中的 ACK 标志（下面介绍）为 1 时该确认序列号的字段才有效。主要用来解决不丢包的问题；</li><li>Header Length<br>  4 位，显示 header 中 32 位字的数量。需要这个值是因为任选字段的长度是可变的。也称为数据偏移字段（Data Offset field）。 header 的最小为 5 个字（二进制模式为 0101）。</li><li>Reserved<br>  6 位，常被设为 0；</li><li>Control Bit Flags<br>  我们之前已经知道 TCP 是面向连接的协议。 面向连接协议的含义是，在可以传输任何数据之前，必须获得（obtained）并确认可靠的连接。 控制位控制着连接建立，数据传输和连接终止的整个过程。<br>  控制位列出如下：它们依次为 URG，ACK，PSH，RST，SYN，FIN。每个标志位的含义如下：   <ol><li>URG：Urgent Pointer，此标志表示 TCP 包的紧急指针域（后面马上就要说到）有效，用来保证 TCP 连接不被中断，并且督促中间层设备要尽快处理这些数据；</li><li>ACK：Acknowledgement，此标志表示应答域有效。就是说前面所说的 TCP 应答号将会包含在 TCP 数据包中；有两个取值：0 和 1，为 1 的时候表示应答域有效，反之为 0；</li><li>PSH：push，这个标志位表示传送操作。所谓 Push 操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；</li><li>RST：reset，这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；</li><li>SYN：synchronous，表示同步序号，用来建立连接。SYN 标志位和 ACK 标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有 SYN 的数据包，如果对方主机响应了一个数据包回来，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行 TCP 三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行 TCP 的三次握手；</li><li>FIN： finish，表示发送端已经达到数据末尾。也就是说双方的数据传送完成，没有数据可以传送了，发送 FIN 标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。<br>需要注意的是：<ul><li>不要将确认序号 ack 与标志位中的 ACK 搞混了。</li><li>确认方 ack=发起方 req+1，两端配对。  </li></ul></li></ol></li><li>Window<br>  16bits，窗口字段用来控制对方发送的数据量，单位为字节。也就是有名的滑动窗口，用来进行流量控制。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。</li><li>Checksum<br>  16bits,检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</li><li>Urgent Pointer<br>  紧急指针字段，16bits，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。</li><li>Option<br>  长度可变，TCP 首部可以有多达 40 字节的可选信息，用于把附加信息传递给终点，或用来对齐其它选项。</li></ul><ol><li><a href="http://www.omnisecu.com/tcpip/tcp-header.php" target="_blank" rel="noopener">TCP Header Fields</a></li><li><a href="https://www.inetdaemon.com/tutorials/internet/tcp/tcp_header.shtml" target="_blank" rel="noopener">TCP Header</a></li></ol><h2 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h2><h3 id="三次握手（3-way-Handshake）"><a href="#三次握手（3-way-Handshake）" class="headerlink" title="三次握手（3-way Handshake）"></a>三次握手（3-way Handshake）</h3><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。</p><p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 <code>connect()</code> 时。将触发三次握手。</p><ul><li><p>第一次握手(SYN=1, ACK=0, ISN=x):<br> 设备 A（客户端）发送一个 <strong>SYN</strong>chronize 标志设置为 1, <strong>ACK</strong>nowledge 标志设置为 0，以及初始序列号 ISN (Initial Sequence Number) 为 x 的 TCP 连接请求报文段；</p><p> 发送完毕后，客户端进入 <code>SYN_SEND</code> 状态，等待服务器的确认；</p></li><li><p>第二次握手(SYN=1, ACK=1, ISN=y, ACKnum=x+1):<br>  设备 B（服务器）接收设备 A 的 TCP 报文段，并返回 SYN = 1，ACK = 1，ISN = Y（设备 B 的初始序列号），确认编号(Acknowledgment Number )= x + 1（设备 B 接收到的设备 A 的 ISN 加 1）</p><p> 发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态。</p></li><li><p>第三次握手(ACK=1, SYN=0, ACKnum=y+1,seq=x+1)<br>  设备 A(客户端)向设备 B(服务器)发送一个 TCP 报文段，以确认接收到设备 B 的 ISN，标志设置为 SYN = 0，ACK = 1，序列号(Sequence number)= x+1，确认号(Acknowledgment number)= y+1</p><p> 发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</p></li></ul><p>完成了三次握手，客户端和服务器端建立全双工通信（full-duplex communication），开始使用约定的序列号和确认号（ sequence 和 acknowledge numbers）传送数据。</p><p>三次握手的过程的示意图如下：</p><p><img src="/images/tcp-connection-made-three-way-handshake.png" alt="three-way-handshake"><br><img src="/images/3-way-handshake.png" alt="three-way-handshake"></p><ul><li><a href="http://www.omnisecu.com/tcpip/tcp-three-way-handshake.php" target="_blank" rel="noopener">3 way handshake, TCP Three-way handshake, TCP Synchronization</a></li><li><a href="https://www.inetdaemon.com/tutorials/internet/tcp/3-way_handshake.shtml" target="_blank" rel="noopener">TCP 3-Way Handshake (SYN,SYN-ACK,ACK)</a>  </li><li><a href="https://www.geeksforgeeks.org/tcp-3-way-handshake-process/" target="_blank" rel="noopener">TCP 3-Way Handshake Process</a> </li><li><a href="https://study-ccna.com/tcp-three-way-handshake/" target="_blank" rel="noopener">TCP three-way handshake</a> </li></ul><h3 id="四次挥手（TCP-Connection-Termination）"><a href="#四次挥手（TCP-Connection-Termination）" class="headerlink" title="四次挥手（TCP Connection Termination）"></a>四次挥手（TCP Connection Termination）</h3><p>当客户端和服务器通过三次握手建立了 TCP 连接以后，数据传送完毕，肯定是要断开 TCP 连接。TCP 的连接的解除需要发送四个包，因此称为四次挥手(Four-way handshake)。<strong>客户端或服务器均可主动发起挥手动作</strong>，在 socket 编程中，任何一方执行 <code>close()</code> 操作即可产生挥手操作。</p><ul><li><p>第一次挥手(FIN=1，seq=x)<br> （从客户端获得 FIN）–此处假定客户端应用程序决定要关闭连接。 （请注意，服务器也可以选择关闭连接）。这将导致客户端将 FIN 位设置为 1 的 TCP 报文段发送到服务器，并进入 FIN_WAIT_1 状态。当客户端处于 FIN_WAIT_1 状态时，它会等待来自服务器的带有 ACK 确认（acknowledgment）的 TCP 段。</p><p> 发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态，此时仍然可以接受数据。</p></li><li><p>第二次挥手(ACK=1，ACKnum=x+1)<br> （来自服务器的 ACK）–当服务器从发件人（客户端）收到 FIN 位段时，服务器立即向发件人（客户端）发送确认（ACK）报文段。Acknowledgment Number 为 Sequence Number 加 1；表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p> 发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端发送关闭连接段。</p></li><li><p>第三次挥手(FIN=1，seq=y)</p><p> （来自服务器的 FIN）服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。</p><p> 发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个 ACK。</p></li><li><p>第四次挥手(ACK=1，ACKnum=y+1)</p><p> （来自客户端的 ACK）客户端接收到来自服务器端的关闭请求，发送一个确认报文段，并进入 <code>TIME_WAIT</code>状态，TIME_WAIT 状态允许客户端在 ACK 丢失的情况下重新发送最终确认的 ACK 包。</p><p> 服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。</p><p> 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</p><p> 处于 TIME_WAIT 状态的客户端所花费的时间取决于其实现，但典型值为 30 秒，1 分钟和 2 分钟。等待之后，连接正式关闭，并且客户端上的所有资源（包括端口号和缓冲区数据）都被释放。</p></li></ul><p>四次挥手的示意图如下：</p><p><img src="/images/tcp-connection-closed-four-way-handshake.png" alt="four-way-handshake"></p><ul><li><a href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-2.htm" target="_blank" rel="noopener">TCP Connection Termination</a>  </li><li><a href="https://www.geeksforgeeks.org/tcp-connection-termination/" target="_blank" rel="noopener">TCP Connection Termination</a>   </li></ul><h4 id="完整状态转换图"><a href="#完整状态转换图" class="headerlink" title="完整状态转换图"></a>完整状态转换图</h4><p><img src="/images/TCP-states-visited-by-ClientSide.png" alt="客户端"></p><p><img src="/images/TCP-states-visited-by-ServerSide.png" alt="服务端"></p><hr><h2 id="疑问解惑"><a href="#疑问解惑" class="headerlink" title="疑问解惑"></a>疑问解惑</h2><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。为了解决“网络中存在延迟的重复分组”的问题。    </p><p>为什么 A 还要发送一次确认呢？这主要是为了防止己失效的连接请求报文段突然又传送到了 B ,因而产生错误。<br>所谓“己失效的连接请求报文段”是这样产生的：</p><blockquote><p>正常情况下：A 发出连接请求,但因连接请求报文丢失而未收到确认。于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段。其中，第一个丢失，第二个到达了 B。没有“已失效的连接请求报文段”。</p><p>现假定出现一种异常情况：即 A 发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早己失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接，假定不采用“三次握手”，那么只要 B 发出确认，新的连接就建立了。<br>由于现在 A 并没有发出建立连接的请求。因此不会理睬 B 的确认。也不会向 B 发送数据。但 B 却以为新的运输连接己经建立了，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。<br>采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A 不会向 B 的确认发出确认。B 由于收不到确认。就知道 A 并没有要求建立连接。</p></blockquote><p>这就很明白了，<strong>防止服务器端的一直等待而浪费资源</strong>。</p><p>在 Google Groups 的 TopLanguage 中看到一帖讨论 TCP“三次握手”觉得很有意思。贴主提出“TCP 建立连接为什么是三次握手？”的问题，在众多回复中，有一条回复写道：“这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致。而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值。所以三次握手不是 TCP 本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的。请注意这里的本质需求,信道不可靠, 数据传输要可靠。三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了。因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像 UDP 那样直接发送消息就可以了。”这可视为对“三次握手”目的的另一种解答思路。</p><h3 id="通俗理解"><a href="#通俗理解" class="headerlink" title="通俗理解"></a>通俗理解</h3><p>但是为什么一定要进行三次握手来保证连接是双工的呢，一次不行么？两次不行么？我们举一个现实生活中两个人进行语言沟通的例子来模拟三次握手。<br>引用网上的一些通俗易懂的例子，虽然不太正确，后面会指出，但是不妨碍我们理解，大体就是这么个理解法。</p><ul><li>第一次对话：<br>老婆让甲出去打酱油，半路碰到一个朋友乙，甲问了一句：哥们你吃饭了么？<br>结果乙带着耳机听歌呢，根本没听到，没反应。甲心里想：跟你说话也没个音，不跟你说了，沟通失败。说明乙接受不到甲传过来的信息的情况下沟通肯定是失败的。<br>如果乙听到了甲说的话，那么第一次对话成功，接下来进行第二次对话。</li><li>第二次对话：<br>乙听到了甲说的话，但是他是老外，中文不好，不知道甲说的啥意思也不知道怎样回答，于是随便回答了一句学过的中文 ：我去厕所了。甲一听立刻笑喷了，“去厕所吃饭”?道不同不相为谋，离你远点吧，沟通失败。说明乙无法做出正确应答的情况下沟通失败。<br>如果乙听到了甲的话，做出了正确的应答，并且还进行了反问：我吃饭了，你呢？那么第二次握手成功。<br>通过前两次对话证明了乙能够听懂甲说的话，并且能做出正确的应答。 接下来进行第三次对话。</li><li>第三次对话：<br>甲刚和乙打了个招呼，突然老婆喊他，“你个死鬼，打个酱油咋这么半天，看我回家咋收拾你”，甲是个妻管严，听完吓得二话不说就跑回家了，把乙自己晾那了。乙心想：这什么人啊，得，我也回家吧，沟通失败。说明甲无法做出应答的情况下沟通失败。<br>如果甲也做出了正确的应答：我也吃了。那么第三次对话成功，两人已经建立起了顺畅的沟通渠道，接下来开始持续的聊天。<br>通过第二次和第三次的对话证明了甲能够听懂乙说的话，并且能做出正确的应答。<br>可见，两个人进行有效的语言沟通，这三次对话的过程是必须的。<br>为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。<br>这个例子举得挺好的。不过个人感觉为什么是三次而不是二次，不是因为为了证明甲能听懂乙并回应（第二次乙能正确的响应甲说明俩人之间沟通已无障碍了），而是怕出现以下情况而浪费感情。这个情景是这样的（例子有点不实际意会就好）：甲在路上跟乙打招呼，由于刮风什么的这句活被吹跑了，然后甲又跟打了个招呼，乙听到了并作出了回应。此时不管是三次握手还是两次握手两个人都能愉快的沟通。0.1 秒后俩人四次挥手告别了。此时被风刮跑的那句话又传到了乙的耳朵里，乙认为甲又要跟他沟通，所以做出了响应的回应。（问题出现了）假如采用 2 次握手，乙就认定了甲要跟他沟通，于是就不停的等，浪费感情。可如果是采用 3 次握手，乙等了一会后发现甲没有回应他就认为甲走了然后自己也就走了！<br>这就很明白了，其实第三步是防止了乙的一直等待而浪费自己的时间，而不是为了保证甲能够正确回应乙的信息。</li></ul><h3 id="为什么要四次分手"><a href="#为什么要四次分手" class="headerlink" title="为什么要四次分手"></a>为什么要四次分手</h3><p>TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。<br>TCP 是全双工模式，这就意味着，当主机 1 发出 FIN 报文段时，只是表示主机 1 已经没有数据要发送了，主机 1 告诉主机 2，它的数据已经全部发送完毕了；但是，这个时候主机 1 还是可以接受来自主机 2 的数据；当主机 2 返回 ACK 报文段时，表示它已经知道主机 1 没有数据发送了，但是主机 2 还是可以发送数据到主机 1 的；当主机 2 也发送了 FIN 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1，我也没有数据要发送了，之后彼此就会愉快地中断这次 TCP 连接。<br>如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化：  </p><ul><li>FIN_WAIT_1: 这个状态要好好解释一下，其实 FIN_WAIT_1 和 FIN_WAIT_2 状态的真正含义都是表示等待对方的 FIN 报文。而这两种状态的区别是：FIN_WAIT_1 状态实际上是当 SOCKET 在 ESTABLISHED 状态时，它想主动关闭连接，向对方发送了 FIN 报文，此时该 SOCKET 即进入到 FIN_WAIT_1 状态。而当对方回应 ACK 报文后，则进入到 FIN_WAIT_2 状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应 ACK 报文，所以 FIN_WAIT_1 状态一般是比较难见到的，而 FIN_WAIT_2 状态还有时常常可以用 netstat 看到。（主动方）</li><li>FIN_WAIT_2：上面已经详细解释了这种状态，实际上 FIN_WAIT_2 状态下的 SOCKET，表示半连接，也即有一方要求 close 连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK 信息)，稍后再关闭连接。（主动方）</li><li>CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方 close 一个 SOCKET 后发送 FIN 报文给自己，你系统毫无疑问地会回应一个 ACK 报文给对方，此时则进入到 CLOSE_WAIT 状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close 这个 SOCKET，发送 FIN 报文给对方，也即关闭连接。所以你在 CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。（被动方）</li><li>LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送 FIN 报文后，最后等待对方的 ACK 报文。当收到 ACK 报文后，也即可以进入到 CLOSED 可用状态了。（被动方）</li><li>TIME_WAIT: 表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 后即可回到 CLOSED 可用状态了。如果 FINWAIT1 状态下，收到了对方同时带 FIN 标志和 ACK 标志的报文时，可以直接进入到 TIME_WAIT 状态，而无须经过 FIN_WAIT_2 状态。（主动方）</li><li>CLOSED: 表示连接中断。</li></ul><h3 id="为什么连接的时候是三次握手，关闭的时候却是四次握手"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手</h3><p>因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，”你发的 FIN 报文我收到了”。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步握手。</p><h3 id="为什么-TIME-WAIT-状态需要经过-2MSL-maximum-segment-lifetime：最大报文段生存时间-才能返回到-CLOSE-状态"><a href="#为什么-TIME-WAIT-状态需要经过-2MSL-maximum-segment-lifetime：最大报文段生存时间-才能返回到-CLOSE-状态" class="headerlink" title="为什么 TIME_WAIT 状态需要经过 2MSL(maximum segment lifetime：最大报文段生存时间)才能返回到 CLOSE 状态"></a>为什么 TIME_WAIT 状态需要经过 2MSL(maximum segment lifetime：最大报文段生存时间)才能返回到 CLOSE 状态</h3><ol><li><p>可靠地实现 TCP 全双工连接的终止<br> 在进行关闭连接四路握手协议时，最后的 ACK 是由主动关闭端发出的，如果这个最终的 ACK 丢失，服务器将重发最终的 FIN，因此客户端必须维护状态信息允 许它重发最终的 ACK。如果不维持这个状态信息，那么客户端将响应 RST 分节，服务器将此分节解释成一个错误（在 java 中会抛出 connection reset 的 SocketException)。因而，要实现 TCP 全双工连接的正常终止，必须处理终止序列四个分节中任何一个分节的丢失情况，主动关闭 的客户端必须维持状态信息进入 TIME_WAIT 状态。</p></li><li><p>允许老的重复分节在网络中消逝<br> TCP 分节可能由于路由器异常而“迷途”，在迷途期间，TCP 发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个原来的迷途分节就称为 lost duplicate。在关闭一个 TCP 连接后，马上又重新建立起一个相同的 IP 地址和端口之间的 TCP 连接，后一个连接被称为前一个连接的化身 （incarnation)，那么有可能出现这种情况，前一个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。为了避免这个情 况，TCP 不允许处于 TIME_WAIT 状态的连接启动一个新的化身，因为 TIME_WAIT 状态持续 2MSL，就可以保证当成功建立一个 TCP 连接的时 候，来自连接先前化身的重复分组已经在网络中消逝。</p></li></ol><p><a href="https://blog.csdn.net/unix21/article/details/16918307" target="_blank" rel="noopener">为什么 TCP 的 TIME_WAIT 状态要保持 2MSL?</a><br><a href="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/" target="_blank" rel="noopener">18.6.1 2MSL 等待状态</a>   </p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://people.na.infn.it/~garufi/didattica/CorsoAcq/Trasp/Lezione9/tcpip_ill/tcp_conn.htm" target="_blank" rel="noopener">TCP Connection Establishment and Termination</a></li><li><a href="https://www.inetdaemon.com/tutorials/internet/tcp/index.shtml" target="_blank" rel="noopener">Transmission Control Protocol (TCP) Tutorials</a></li><li><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">通俗大白话来理解 TCP 协议的三次握手和四次分手</a></li><li><a href="http://blog.csdn.net/oney139/article/details/8103223" target="_blank" rel="noopener">TCP 三次握手详解及释放连接过程</a></li><li><a href="https://www.jellythink.com/archives/240" target="_blank" rel="noopener">简析 TCP 的三次握手与四次分手</a></li><li><a href="https://www.cnblogs.com/zhanglei93/p/6574714.html" target="_blank" rel="noopener">TCP 协议设计原理</a></li><li><a href="http://blog.csdn.net/whuslei/article/details/6667471" target="_blank" rel="noopener">TCP 协议中的三次握手和四次挥手(图解)</a></li><li><a href="https://www.cnblogs.com/yuilin/archive/2012/11/05/2755298.html" target="_blank" rel="noopener">理解 TCP 为什么需要进行三次握手(白话)</a></li><li><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">TCP 为什么是三次握手，为什么不是两次或四次？</a></li><li><a href="https://juejin.im/post/58e36d35b123db15eb748856" target="_blank" rel="noopener">面试时，你被问到过 TCP/IP 协议吗?</a></li><li><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="noopener">TCP 协议</a></li><li><a href="http://www.cnblogs.com/hnrainll/archive/2011/10/14/2212415.html" target="_blank" rel="noopener">TCP 三次握手及四次挥手详细图解</a></li><li><a href="http://www.cnblogs.com/rootq/articles/1377355.html" target="_blank" rel="noopener">TCP 协议三次握手过程分析</a></li><li><a href="http://baike.baidu.com/subview/32754/8048820.htm" target="_blank" rel="noopener">百度百科：SYN 攻击</a></li><li><a href="http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/" target="_blank" rel="noopener">TCP-Keepalive-HOWTO</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么 Redis 这么快？</title>
      <link href="/blog/2019-09-19/Why-redis-is-so-fast/"/>
      <url>/blog/2019-09-19/Why-redis-is-so-fast/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="太长不看版"><a href="#太长不看版" class="headerlink" title="太长不看版"></a>太长不看版</h2><ol><li><p>Redis 是基于内存的访问，内存的读写速度非常快；</p></li><li><p>Redis 是单线程的模型。保证了每个操作的原子性，省去了很多上下文切换线程的时间以及竞态而产生的消耗；</p></li><li><p>Redis 使用多路复用技术，可以处理并发的连接。非阻塞 IO 内部实现采用 epoll，采用了 epoll+自己实现的简单的事件轮询（event loop）框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 io 上浪费一点时间。</p></li><li><p>数据结构。Redis 全程使用 hash 结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</p></li></ol><h2 id="为什么-Redis-使用单线程"><a href="#为什么-Redis-使用单线程" class="headerlink" title="为什么 Redis 使用单线程"></a>为什么 Redis 使用单线程</h2><p>因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案。</p><h3 id="详细原因"><a href="#详细原因" class="headerlink" title="详细原因"></a>详细原因</h3><ol><li><p>不需要各种锁的性能消耗</p><p> Redis 的数据结构并不全是简单的 Key-Value，还有 list，hash 等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在 hash 当中添加或者删除</p><p> 一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p><p> 总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p></li><li><p>单线程多进程集群方案</p><p> 单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p><p> 所以单线程、多进程的集群不失为一个时髦的解决方案。</p></li><li><p>CPU 消耗</p><p> 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p></li></ol><h2 id="但是如果-CPU-成为-Redis-瓶颈，或者不想让服务器其他-CUP-核闲置，那怎么办"><a href="#但是如果-CPU-成为-Redis-瓶颈，或者不想让服务器其他-CUP-核闲置，那怎么办" class="headerlink" title="但是如果 CPU 成为 Redis 瓶颈，或者不想让服务器其他 CUP 核闲置，那怎么办"></a>但是如果 CPU 成为 Redis 瓶颈，或者不想让服务器其他 CUP 核闲置，那怎么办</h2><p>可以考虑多起几个 Redis 进程，Redis 是 key-value 数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些 key 放在哪个 Redis 进程上就可以了。</p><h2 id="Redis-单线程的优劣势"><a href="#Redis-单线程的优劣势" class="headerlink" title="Redis 单线程的优劣势"></a>Redis 单线程的优劣势</h2><ol><li><p>单进程单线程优势</p><ul><li>代码更清晰，处理逻辑更简单；</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>不存在多进程或者多线程导致的切换而消耗 CPU； </li></ul></li><li><p>单进程单线程弊端<br> 无法发挥多核 CPU 性能，不过可以通过在单机开多个 Redis 实例来完善；</p></li></ol><h2 id="IO-多路复用技术"><a href="#IO-多路复用技术" class="headerlink" title="IO 多路复用技术"></a>IO 多路复用技术</h2><p>Redis 采用网络 IO 多路复用技术来保证在多连接的时候，系统的高吞吐量。</p><p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了 Redis 具有很高的吞吐量。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/u011663149/article/details/85307615" target="_blank" rel="noopener">Redis 为什么是单线程、及高并发快的大原因详解</a></li><li><a href="https://www.jianshu.com/p/3d54131ee94c" target="_blank" rel="noopener">Redis 为什么快？</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用 Gunicorn+Gevent+Supervisor+Nginx 部署 Flask 应用</title>
      <link href="/blog/2019-08-07/how-to-deploy-flask-with-nginx-gunicorn-gevent-supervisor/"/>
      <url>/blog/2019-08-07/how-to-deploy-flask-with-nginx-gunicorn-gevent-supervisor/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h2><ol><li><p>Nginx: 高性能<code>Web</code>服务器+负责反向代理;</p></li><li><p>gunicorn: 高性能 WSGI 服务器;</p></li><li><p>gevent: 将<code>Python</code>同步代码转换为异步的协议库;</p></li><li><p>supervisor: 监控服务流程的工具;</p></li></ol><h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-bash-4.2<span class="comment"># gunicorn --version</span></span><br><span class="line">gunicorn (version 19.9.0)</span><br></pre></td></tr></table></figure><h2 id="安装-gunicorn-和-gevent"><a href="#安装-gunicorn-和-gevent" class="headerlink" title="安装 gunicorn 和 gevent"></a>安装 gunicorn 和 gevent</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install gunicorn</span><br><span class="line">pip install gevent</span><br></pre></td></tr></table></figure><h2 id="配置-gunicorn"><a href="#配置-gunicorn" class="headerlink" title="配置 gunicorn"></a>配置 gunicorn</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gun.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> gevent.monkey</span><br><span class="line"></span><br><span class="line">gevent.monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'log'</span>):</span><br><span class="line">    os.mkdir(<span class="string">'log'</span>)</span><br><span class="line">debug = <span class="keyword">True</span></span><br><span class="line">loglevel = <span class="string">'debug'</span></span><br><span class="line"><span class="comment"># 绑定的ip及端口号</span></span><br><span class="line">bind = <span class="string">'0.0.0.0:5000'</span></span><br><span class="line">pidfile = <span class="string">'log/gunicorn.pid'</span></span><br><span class="line">logfile = <span class="string">'log/debug.log'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动的进程数</span></span><br><span class="line">workers = multiprocessing.cpu_count() * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">worker_class = <span class="string">'gunicorn.workers.ggevent.GeventWorker'</span></span><br><span class="line"></span><br><span class="line">x_forwarded_for_header = <span class="string">'X-FORWARDED-FOR'</span></span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-bash-4.2<span class="comment"># gunicorn -k gevent -c gun.py runserver:app</span></span><br><span class="line">[2019-08-07 16:00:20 +0800] [32111] [DEBUG] Current configuration:</span><br><span class="line">  config: gun.py</span><br><span class="line">  <span class="built_in">bind</span>: [<span class="string">'0.0.0.0:5000'</span>]</span><br><span class="line">  backlog: 2048</span><br><span class="line">  workers: 3</span><br><span class="line">  worker_class: gevent</span><br><span class="line">  threads: 1</span><br><span class="line"><span class="comment"># ………… 省略中间部分</span></span><br><span class="line">  ciphers: TLSv1</span><br><span class="line">  raw_paste_global_conf: []</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32111] [INFO] Starting gunicorn 19.9.0</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32111] [DEBUG] Arbiter booted</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32111] [INFO] Listening at: http://0.0.0.0:5000 (32111)</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32111] [INFO] Using worker: gevent</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32115] [INFO] Booting worker with pid: 32115</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32116] [INFO] Booting worker with pid: 32116</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32117] [INFO] Booting worker with pid: 32117</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32111] [DEBUG] 3 workers</span><br></pre></td></tr></table></figure><p>此时正常访问<code>http://10.10.15.111:5000/</code>应该可以看到首页信息提示表示连接服务正常。<br><strong>注意</strong>：此处 ip 和端口均由自己设置，所以访问时应该做相应调整。<br>如果无法正常访问，则需要验证防火墙是否正常：  </p><ul><li><p>CentOS 7 以下版本  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询</span></span><br><span class="line">-bash-4.2<span class="comment"># iptables -nL|grep 5000</span></span><br><span class="line"><span class="comment"># 开放指定端口</span></span><br><span class="line">-bash-4.2<span class="comment"># iptables -I INPUT -p tcp --dport 5000 -j ACCEPT</span></span><br><span class="line"><span class="comment"># 再次查询</span></span><br><span class="line">-bash-4.2<span class="comment"># iptables -nL|grep 5000</span></span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:5000</span><br></pre></td></tr></table></figure></li><li><p>CentOS 7<br>使用<code>firewall-cmd</code>管理防火墙端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --query-port=5000/tcp      <span class="comment"># no</span></span><br><span class="line">firewall-cmd --add-port=5000/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --query-port=5000/tcp  <span class="comment"># yes</span></span><br><span class="line">systemctl status firewall</span><br><span class="line">systemctl status firewalld</span><br><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure></li></ul><h2 id="安装-nginx-和-supervisor"><a href="#安装-nginx-和-supervisor" class="headerlink" title="安装 nginx 和 supervisor"></a>安装 nginx 和 supervisor</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install nginx supervisor</span><br></pre></td></tr></table></figure><h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h3><p>默认安装的 Nginx 配置文件<code>/etc/nginx/nginx.conf</code>内有如下配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include /etc/nginx/conf.d/*.conf;</span><br></pre></td></tr></table></figure><p>即从外部目录<code>/etc/nginx/conf.d/</code>文件夹下还引入了其他配置文件。<br>这样，我们不修改默认配置，只在<code>/etc/nginx/conf.d/</code>目录下增加一个<code>***.conf</code>，来在外面增加新配置。</p><p>在<code>/etc/nginx/conf.d/</code>增加<code>app.conf</code>，内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  80;     <span class="comment"># 如果80端口被占用，可以使用其他端口，记得在防火墙中打开相应端口</span></span><br><span class="line">    server_name localhost;</span><br><span class="line">    charset utf-8; </span><br><span class="line">    access_log /var/pmmt/access.log;</span><br><span class="line">    error_log /var/pmmt/error.log;</span><br><span class="line"></span><br><span class="line">    client_max_body_size 100M;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_pass  http://0.0.0.0:5000;</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_connect_timeout 300;</span><br><span class="line">            proxy_send_timeout 300;</span><br><span class="line">            proxy_read_timeout 300;</span><br><span class="line">            send_timeout 300;</span><br><span class="line">            proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">            proxy_set_header Connection <span class="string">"upgrade"</span>;</span><br><span class="line">            proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">            proxy_set_header X-Scheme <span class="variable">$scheme</span>;</span><br><span class="line">            proxy_set_header X-Forwarded-For <span class="variable">$remote_addr</span>;</span><br><span class="line">            proxy_set_header X-Forwarded-Port <span class="variable">$server_port</span>;</span><br><span class="line">            proxy_set_header X-Request-Start <span class="variable">$msec</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动服务-1"><a href="#启动服务-1" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><ul><li>报错<code>nginx: [emerg] getpwnam(&quot;nginx&quot;) failed in /etc/nginx/nginx.conf:5</code><br>查看配置该行内容为<code>user nginx;</code>，添加用户<code>useradd nginx</code>；</li></ul><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><ul><li><p>ERR_CONTENT_LENGTH_MISMATCH<br>  查看 nginx 错误日志</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tailf /var/<span class="built_in">log</span>/nginx/error.log</span><br><span class="line">2019/08/09 03:04:21 [crit] 24616<span class="comment">#0: *204 open() "/var/lib/nginx/tmp/proxy/2/03/0000000032" failed (13: Permission denied) while reading upstream, client: 10.10.15.199, server: localhost, request: "GET /static/js/app.1b53c809113e333c2727.js.map HTTP/1.1", upstream: "http://0.0.0.0:5000/static/js/app.1b53c809113e333c2727.js.map", host: "10.10.15.111:82"</span></span><br></pre></td></tr></table></figure><p>  参考这里：<a href="https://blog.csdn.net/mr_ooo/article/details/81068369" target="_blank" rel="noopener">ERR_CONTENT_LENGTH_MISMATCH 解决方法</a>      </p></li><li>进入首页出现<code>403 Forbidden</code><ol><li>nginx 启动用户和配置中的工作用户不一致（注意：如果你的<code>nginx</code>服务是<code>root</code>用户运行，则配置中<code>user</code>项配置为<code>root</code>）；</li><li>配置文件中缺少 index index.html index.htm index.php 行；</li><li>nginx 用户没有相应工作目录的操作权限（<code>chown -R nginx:nginx WORK_DIR_PATH</code>）；</li><li>防火墙设置。<br>参考这里：<a href="https://blog.csdn.net/onlysunnyboy/article/details/75270533" target="_blank" rel="noopener">解决 Nginx 出现 403 forbidden (13: Permission denied)报错的四种方法</a></li></ol></li></ul><h2 id="配置-Supervisor"><a href="#配置-Supervisor" class="headerlink" title="配置 Supervisor"></a>配置 Supervisor</h2><p>首先检查是否存在配置文件，一般配置文件的路径是<code>/etc/supervisord.conf</code>，如果配置文件不存在，我们可以通过命令来生成：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /etc/supervisord.conf</span><br></pre></td></tr></table></figure></p><p>配置文件的内容很多，项目配置可以参照<a href="http://www.supervisord.org/introduction.html" target="_blank" rel="noopener">官网文档</a></p><p>打开配置文件的最后一行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">;[include]</span><br><span class="line">;files = /etc/supervisord/*.conf    <span class="comment"># 注意：本人安装版本为ini格式，所以我们自写的配置也应该调整为相应的.ini格式[include] \n files = supervisord.d/*.ini</span></span><br></pre></td></tr></table></figure></p><p>默认一般是注释掉的，我们可以取消注释，这行配置的作用也很浅显，就是导入设置的路径下的所有<code>conf</code>文件，这使得我们如果有多个项目可以不用都写在同一个配置文件里，可以一个项目一个配置文件，更适合管理。这里的路径也是可以按照实际需求随意更改。<br>手动启动 Supervisord<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">supervisord -c /etc/supervisord.conf</span><br></pre></td></tr></table></figure></p><p>在设置的路径下新建一个配置文件，命令请根据上一步设置的扩展名。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[program:project_name]</span><br><span class="line"><span class="built_in">command</span>=/usr/bin/gunicorn -c gun.py runserver:app       <span class="comment"># 具体路径根据自己安装或者虚拟环境中的位置进行配置</span></span><br><span class="line">directory=/project_path/        <span class="comment"># 项目路径</span></span><br><span class="line">startsecs=0</span><br><span class="line">stopwaitsecs=0</span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line">autorestart=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p><code>project_name</code>按照你的实际需求修改，作为你这个服务的唯一标识，用于启动停止服务时使用。<br><code>command</code>修改为测试<code>gunicorn</code>时使用的命令，建议使用绝对路径。<br><code>directory</code>指定了工作路径，通常设置为项目根目录，我们填写的 gun.py 和 app 都是基于这个路径的。</p><p>管理<code>Supervisor</code>的项目是使用<code>supervisorctl</code>命令，我们可以启动项目试试看</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">supervisorctl start PROJECT_NAME</span><br></pre></td></tr></table></figure><p>如果没有报错，应该可以和上一步测试<code>gunicorn</code>一样可以正常访问项目了。<br>验证<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-bash-4.2<span class="comment"># supervisorctl</span></span><br><span class="line">app                              RUNNING   pid 24639, uptime 0:20:55</span><br></pre></td></tr></table></figure></p><h3 id="报错记录"><a href="#报错记录" class="headerlink" title="报错记录"></a>报错记录</h3><ul><li>Error: Another program is already listening on a port that one of our HTTP servers is configured to use.  Shut this program down first before starting supervisord. For help, use /usr/bin/supervisord -h  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以查看supervisor.sock并删除 </span></span><br><span class="line">-bash-4.2<span class="comment"># find / -name supervisor.sock </span></span><br><span class="line">/run/supervisor/supervisor.sock</span><br><span class="line">-bash-4.2<span class="comment"># unlink /run/supervisor/supervisor.sock</span></span><br></pre></td></tr></table></figure></li></ul><p>再次重新启动<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-bash-4.2<span class="comment"># supervisord -c /etc/supervisord.conf</span></span><br></pre></td></tr></table></figure></p><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><ol><li><a href="https://programmer.help/blogs/5c13afa73d10a.html" target="_blank" rel="noopener">Huawei Cloud Centos7 Flask+Gunicorn+Gevent+Supervisor+Nginx Multi-site Production Environment Deployment</a></li><li><a href="https://www.jianshu.com/p/192e62a5cdd2" target="_blank" rel="noopener">Flask + Nginx + Gunicorn + Gevent 部署</a></li><li><a href="https://www.jianshu.com/p/65fae00615b9" target="_blank" rel="noopener">gunicorn+gevent+nginx 部署 flask 应用</a></li><li><a href="https://blog.csdn.net/spark_csdn/article/details/80790929" target="_blank" rel="noopener">CentOS 上 Flask + uWSGI + Nginx 部署</a></li><li><a href="https://www.zhihu.com/question/38528616" target="_blank" rel="noopener">Nginx、Gunicorn 在服务器中分别起什么作用</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Web 开发 </tag>
            
            <tag> Flask </tag>
            
            <tag> Nginx </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 报错&quot;TypeError:a-bytes-like-object-is-required,not-&#39;str&#39;&quot;解决办法</title>
      <link href="/blog/2019-07-11/a-bytes-like-object-is-required-not-str-python3/"/>
      <url>/blog/2019-07-11/a-bytes-like-object-is-required-not-str-python3/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天在解析一个工具输出问题时遇到这两个编码错误，记录一下。</p><ul><li>TypeError: a bytes-like object is required, not ‘str’</li><li>UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xb3 in position 38: invalid start byte<a id="more"></a></li></ul><h2 id="先上代码"><a href="#先上代码" class="headerlink" title="先上代码"></a>先上代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecCommandError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecCommand</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cust_popen_list</span><span class="params">(cmdlist, close_fds=True)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        subprocess.call只接受数组变量作为命令，并将数组的第一个元素作为命令，剩下的全部作为该命令的参数。</span></span><br><span class="line"><span class="string">        :param cmdlist:</span></span><br><span class="line"><span class="string">        :param close_fds:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lastcmdlist = list()</span><br><span class="line">        lastcmdlist.extend(cmdlist)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            proc = subprocess.Popen(lastcmdlist, shell=<span class="keyword">False</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE,</span><br><span class="line">                                    close_fds=close_fds)</span><br><span class="line">            retcode = proc.wait()</span><br><span class="line">            <span class="keyword">return</span> retcode, proc</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> (ExecCommandError, e)</span><br><span class="line">            </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HwMaker</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.retcode = <span class="number">1</span></span><br><span class="line">        self.proc = <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exec_command</span><span class="params">(cmd_list=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        调用执行命令的程序</span></span><br><span class="line"><span class="string">        :param cmd_list: list,</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">assert</span> cmd_list</span><br><span class="line">        cmd = ExecCommand()</span><br><span class="line">        <span class="keyword">return</span> cmd.cust_popen_list(cmd_list)</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_label</span><span class="params">(label)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        如果以空格分割，则替换为 with_under_case,最后调用lower()返回lower_with_under_case</span></span><br><span class="line"><span class="string">        :param label:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        split_label = label.split()</span><br><span class="line">        label = <span class="string">'_'</span>.join([span.lower() <span class="keyword">for</span> span <span class="keyword">in</span> split_label]) <span class="keyword">if</span> len(split_label) &gt; <span class="number">1</span> <span class="keyword">else</span> label.lower()</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensorMaker</span><span class="params">(HwMaker)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">secs2hours</span><span class="params">(secs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        秒转化为小时</span></span><br><span class="line"><span class="string">        :param secs:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        mm, ss = divmod(secs, <span class="number">60</span>)</span><br><span class="line">        hh, mm = divmod(mm, <span class="number">60</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"%d:%02d:%02d"</span> % (hh, mm, ss)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_vertical_line</span><span class="params">(self, parser_data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        以“|” 分割之后获取有用信息</span></span><br><span class="line"><span class="string">        :param parser_data:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        _expect_info = dict()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> parser_data:</span><br><span class="line">            strip_line = line.strip().decode(<span class="string">'utf-8'</span>, <span class="string">"ignore"</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'|'</span> <span class="keyword">in</span> strip_line:</span><br><span class="line">                item, value = [item.strip() <span class="keyword">for</span> item <span class="keyword">in</span> strip_line.split(<span class="string">'|'</span>)]</span><br><span class="line">                lower_label = self.make_label(item)</span><br><span class="line">                _expect_info[lower_label] = value</span><br><span class="line">        <span class="keyword">return</span> _expect_info</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ipmi_pminfo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">         [SlaveAddress = B2h] [Module 2]</span></span><br><span class="line"><span class="string">         Item                           |                Value</span></span><br><span class="line"><span class="string">         ----                           |                -----</span></span><br><span class="line"><span class="string">         Status                         |     [STATUS OK](00h)</span></span><br><span class="line"><span class="string">         AC Input Voltage               |              237.0 V</span></span><br><span class="line"><span class="string">         AC Input Current               |               0.36 A</span></span><br><span class="line"><span class="string">         DC 12V Output Voltage          |              12.04 V</span></span><br><span class="line"><span class="string">         DC 12V Output Current          |               5.07 A</span></span><br><span class="line"><span class="string">         Temperature 1                  |              34C/94F</span></span><br><span class="line"><span class="string">         Temperature 2                  |              37C/98F</span></span><br><span class="line"><span class="string">         Fan 1                          |             5400 RPM</span></span><br><span class="line"><span class="string">         Fan 2                          |              985 RPM</span></span><br><span class="line"><span class="string">         DC 12V Output Power            |                 61 W</span></span><br><span class="line"><span class="string">         AC Input Power                 |                 78 W</span></span><br><span class="line"><span class="string">         PMBus Revision                 |               0xD222</span></span><br><span class="line"><span class="string">         PWS Serial Number              |      ³³³³³³³U³³³³³³³</span></span><br><span class="line"><span class="string">         PWS Module Number              |         ³³³³³³³³³³³³</span></span><br><span class="line"><span class="string">         PWS Revision                   |               ³³³³³³</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         out: &#123;'status': '[STATUS OK](00h)',</span></span><br><span class="line"><span class="string">             'ac_input_voltage': '237.0 V',</span></span><br><span class="line"><span class="string">             'ac_input_current': '0.39 A',</span></span><br><span class="line"><span class="string">             'dc_12v_output_voltage': '12.04 V',</span></span><br><span class="line"><span class="string">             'dc_12v_output_current': '5.19 A',</span></span><br><span class="line"><span class="string">             'temperature_1': '34C/94F',</span></span><br><span class="line"><span class="string">             'temperature_2': '37C/98F',</span></span><br><span class="line"><span class="string">             'fan_1': '5424 RPM',</span></span><br><span class="line"><span class="string">             'fan_2': '985 RPM',</span></span><br><span class="line"><span class="string">             'dc_12v_output_power': '63 W',</span></span><br><span class="line"><span class="string">             'ac_input_power': '71 W',</span></span><br><span class="line"><span class="string">             'pmbus_revision': '0xD222',</span></span><br><span class="line"><span class="string">             'pws_serial_number': 'U',</span></span><br><span class="line"><span class="string">             'pws_module_number': '',</span></span><br><span class="line"><span class="string">             'pws_revision': ''&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        _pm_info = &#123;&#125;</span><br><span class="line">        _cmd = [<span class="string">'ipmicfg'</span>, <span class="string">'-pminfo'</span>]</span><br><span class="line">        self.retcode, self.proc = self.exec_command(_cmd)</span><br><span class="line">        <span class="keyword">if</span> self.retcode == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 截取有用行（排除前三行）</span></span><br><span class="line">            out_data = self.out_data()</span><br><span class="line">            <span class="keyword">if</span> out_data:</span><br><span class="line">                _pm_info = self.parse_vertical_line(out_data[<span class="number">3</span>:])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> _pm_info</span><br></pre></td></tr></table></figure><h2 id="原因解释及解决方案"><a href="#原因解释及解决方案" class="headerlink" title="原因解释及解决方案"></a>原因解释及解决方案</h2><p>关于<code>TypeError: a bytes-like object is required, not &#39;str&#39;</code>错误，我们可以这样复现一下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: a = <span class="string">b'123|456'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: a.split(<span class="string">'|'</span>)                                                                                         </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-17</span>-d4229c89bf5f&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 a.split('|')</span><br><span class="line"></span><br><span class="line">TypeError: a bytes-like object <span class="keyword">is</span> required, <span class="keyword">not</span> <span class="string">'str'</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: a = <span class="string">b'123|456'</span>                                                                                        </span><br><span class="line">In [<span class="number">21</span>]: a.decode(<span class="string">'utf-8'</span>).split(<span class="string">'|'</span>)                                                                         </span><br><span class="line">Out[<span class="number">21</span>]: [<span class="string">'123'</span>, <span class="string">'456'</span>]</span><br></pre></td></tr></table></figure><p>关于问题<code>UnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0xb3 in position 38: invalid start byte</code>，主要是因为结果中有<code>³³³³³³³U³³³³³³³</code>,这个没有办法按照<code>utf-8</code>解码。<br>出现异常报错是由于设置了<code>decode()</code>方法的第二个参数<code>errors</code>为严格（<code>strict</code>）形式造成的，因为默认就是这个参数，将其更改为<code>ignore</code>即可。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/wang7807564/article/details/78164855/" target="_blank" rel="noopener">Python3 解决 UnicodeDecodeError: ‘utf-8’ codec can’t decode byte..问题 终极解决方案</a></li><li><a href="https://stackoverflow.com/questions/33054527/typeerror-a-bytes-like-object-is-required-not-str-when-writing-to-a-file-in" target="_blank" rel="noopener">TypeError: a bytes-like object is required, not ‘str’ when writing to a file in Python3</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在 Vue 中实现显示全部的功能？</title>
      <link href="/blog/2019-07-05/how-to-make-show-all-with-Vue/"/>
      <url>/blog/2019-07-05/how-to-make-show-all-with-Vue/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h2><p>我们可以简单分析一下功能实现：</p><ol><li>显示内容是从后台一次性获取到的，不存在点击“阅读更多”再去请求一次后台获取剩余数据的可能；</li><li>通过第一步其实可以得出，网站是通过控制显示元素的高度来实现这一功能，而非控制内容的获取；</li><li>可以看到“阅读更多”按钮上有一层渐变遮罩层，网站通过这一遮罩挡住剩余内容。</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-for=&quot;(item, key) in testItems&quot; v-show=&quot;key&lt;limitShowNum&quot;&gt;</span><br><span class="line">      &#123;&#123;item&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;el-button @click=&quot;showMore&quot; type=&quot;text&quot; style=&quot;color:#79bbff;&quot;&gt;&#123;&#123;showAllTip&#125;&#125;&lt;/el-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;</span><br><span class="line">&lt;!-- 引入组件库 --&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">          testItems: [&apos;海客谈瀛洲，烟涛微茫信难求；&apos;, &apos;越人语天姥，云霞明灭或可睹。&apos;, &apos;天姥连天向天横，势拔五岳掩赤城。&apos;, &apos;天台四万八千丈，对此欲倒东南倾。&apos;, &apos;我欲因之梦吴越，一夜飞度镜湖月。&apos;, &apos;湖月照我影，送我至剡溪。&apos;, &apos;谢公宿处今尚在，渌水荡漾清猿啼。&apos;, &apos;脚著谢公屐，身登青云梯。&apos;, &apos;半壁见海日，空中闻天鸡。&apos;, &apos;千岩万转路不定，迷花倚石忽已暝。&apos;, &apos;熊咆龙吟殷岩泉，栗深林兮惊层巅。&apos;, &apos;云青青兮欲雨，水澹澹兮生烟。&apos;, &apos;列缺霹雳，丘峦崩摧。&apos;, &apos;洞天石扉，訇然中开。&apos;, &apos;青冥浩荡不见底，日月照耀金银台。&apos;, &apos;霓为衣兮风为马，云之君兮纷纷而来下。&apos;, &apos;虎鼓瑟兮鸾回车，仙之人兮列如麻。&apos;, &apos;忽魂悸以魄动，恍惊起而长嗟。&apos;, &apos;惟觉时之枕席，失向来之烟霞。&apos;, &apos;世间行乐亦如此，古来万事东流水。&apos;, &apos;别君去兮何时还？且放白鹿青崖间。须行即骑访名山。&apos;, &apos;安能摧眉折腰事权贵，使我不得开心颜！&apos;],</span><br><span class="line">          isShow: true,</span><br><span class="line">  showAllTip: &apos;我全都要 😜&apos;,</span><br><span class="line">  limitShowNum: 5,</span><br><span class="line">      defaultShowNum:5</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        // 功能实现</span><br><span class="line">        showMore()&#123;</span><br><span class="line">let showDataLen = this.testItems.length</span><br><span class="line">this.isShow = !this.isShow;</span><br><span class="line">this.limitShowNum = this.isShow? this.defaultShowNum: showDataLen;</span><br><span class="line">this.showAllTip = this.isShow?&apos;我全都要 😜&apos;:&apos;收起&apos;</span><br><span class="line">&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h2><p>此处显示与直接代码运行效果不一样，主要是因为样式以及添加 i 标签图标等导致；样式不会写的话可以参考<code>element-ui</code>官方文档的实现。</p><p><img src="/images/show_all_example.gif" alt="显示全部与折叠"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/XuM222222/article/details/80189355" target="_blank" rel="noopener">利用 vue 实现“显示更多”功能</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> element-ui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask-sqlalchemy 中的多对多关系模型问题记录</title>
      <link href="/blog/2019-07-03/flask-sqlalchemy-many-to-many/"/>
      <url>/blog/2019-07-03/flask-sqlalchemy-many-to-many/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlalchemy.exc.InvalidRequestError: One or more mappers failed to initialize - can<span class="string">'t proceed with initialization of other mappers. Triggering mapper: '</span>mapped class Article-&gt;iy_article<span class="string">'. Original exception was: Error creating backref '</span>articles<span class="string">' on relationship '</span>Article.tags<span class="string">': property of that name exists on mapper '</span>mapped class Tag-&gt;iy_tag<span class="string">'</span></span><br></pre></td></tr></table></figure><p>出现这个错误是因为两个关系表中互相定义，意思是你的代码中可能同时包含下面的语句：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class Article:</span></span><br><span class="line"></span><br><span class="line">tags = db.relationship(<span class="string">'Tag'</span>, secondary=posts_tags_table, backref=db.backref(<span class="string">'articles'</span>, lazy=<span class="string">'dynamic'</span>),</span><br><span class="line">                               lazy=<span class="string">"dynamic"</span>)</span><br><span class="line"><span class="comment"># Class Tag:                            </span></span><br><span class="line">articles = db.relationship(<span class="string">'Article'</span>, secondary=posts_tags_table,</span><br><span class="line">    <span class="comment">#                            back_populates='tags')</span></span><br></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>当您使用<code>backref</code>时，<code>SQLAlchemy</code>会自动创建向后关联，因此它（backref）<strong>只应该</strong>在关系的一侧使用。所以应该删除上面其中的一句定义。</p><p>参见这里<br><a href="https://stackoverflow.com/questions/39869793/when-do-i-need-to-use-sqlalchemy-back-populates" target="_blank" rel="noopener">when-do-i-need-to-use-sqlalchemy-back-populates</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlalchemy.orm.exc.StaleDataError: DELETE statement on table <span class="string">'iy_post_tags'</span> expected to delete 4 row(s); Only 24 were matched.</span><br></pre></td></tr></table></figure><h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h3><p>出现这个问题原因是在多对多关系的关联表中，出现了重复数据。<br>书上说“将某个 Book 的 Writer 属性设置为 None,就会解除与 Writer 对象的关系。”<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">post_obj = Article.query.filter(Article.post_id == post_id).one()</span><br><span class="line"><span class="keyword">if</span> post_obj:</span><br><span class="line">    body_id = post_obj.body_id</span><br><span class="line">    post_obj.tags = <span class="keyword">None</span></span><br><span class="line">    db.session.commit()</span><br></pre></td></tr></table></figure></p><p>失败！！！</p><p>再次参考<a href="https://seagullbird.xyz/posts/how-to-delete-many-to-many-in-sqlalchemy/" target="_blank" rel="noopener">How to delete a Many-to-Many relationship in Flask-SQLAlchemy</a><br>作者提到可能是因为对数据手动处理的问题。<br>验证数据表中是否存在重复数据：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; delete from iy_post_tags where post_id=26;</span><br><span class="line">Query OK, 2 rows affected (0.22 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from iy_post_tags;</span><br><span class="line">+<span class="comment">---------+--------+</span></span><br><span class="line">| post_id | tag_id |</span><br><span class="line">+<span class="comment">---------+--------+</span></span><br><span class="line">|      20 |      7 |</span><br><span class="line">|      21 |      7 |</span><br><span class="line">|      22 |      7 |</span><br><span class="line">|      23 |      7 |</span><br><span class="line">|      24 |      7 |</span><br><span class="line">|      24 |      7 |</span><br><span class="line">|      20 |      7 |</span><br><span class="line">|      25 |      7 |</span><br><span class="line">|      27 |      7 |    <span class="comment">-- 注意这两行，表中出现同一篇文章，标签相同记录两次的情况，此时删除操作就会报错</span></span><br><span class="line">|      27 |      7 |</span><br><span class="line">+<span class="comment">---------+--------+</span></span><br></pre></td></tr></table></figure></p><p>的确存在，可以手动删除。</p><h3 id="利用代码限制永久解决"><a href="#利用代码限制永久解决" class="headerlink" title="利用代码限制永久解决"></a>利用代码限制永久解决</h3><p>还有<a href="https://stackoverflow.com/questions/36002638/how-to-fix-sqlalchemy-sawarning-delete-statement-on-table-expected-to-delete-1" target="_blank" rel="noopener">这里</a><br>修改表结构，解除确认删除。</p><p>利用主键唯一约束，在创建中间表的时候进行限制<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置： primary_key=True</span></span><br><span class="line">article_tag_rel = sa.Table(<span class="string">'article_tag_rel'</span>, Base.metadata,</span><br><span class="line">    sa.Column(<span class="string">'tag_id'</span>, sa.Integer, ForeignKey(<span class="string">'tag.id'</span>), primary_key=<span class="keyword">True</span>),</span><br><span class="line">    sa.Column(<span class="string">'article_id'</span>, sa.Integer, ForeignKey(<span class="string">'article.id'</span>), primary_key=<span class="keyword">True</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>参见<a href="https://github.com/kvesteri/sqlalchemy-continuum/issues/65" target="_blank" rel="noopener">这里</a><br>还有<a href="https://stackoverflow.com/questions/36002638/how-to-fix-sqlalchemy-sawarning-delete-statement-on-table-expected-to-delete-1" target="_blank" rel="noopener">这里</a>是修改表结构<br><a href="https://stackoverflow.com/questions/41941273/deleting-from-a-sqlalchemy-many-to-many-matches-the-wrong-number-of-rows" target="_blank" rel="noopener">这里</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上面的一种简便写法</span></span><br><span class="line"><span class="keyword">import</span> db</span><br><span class="line">posts_tags_table = db.Table(<span class="string">'iy_post_tags'</span>, db.Model.metadata,</span><br><span class="line">                            db.Column(<span class="string">'post_id'</span>, db.Integer, db.ForeignKey(<span class="string">'iy_article.post_id'</span>)),</span><br><span class="line">                            db.Column(<span class="string">'tag_id'</span>, db.Integer, db.ForeignKey(<span class="string">'iy_tag.id'</span>)),</span><br><span class="line">                            db.PrimaryKeyConstraint(<span class="string">'tag_id'</span>, <span class="string">'post_id'</span>)</span><br><span class="line">                            )</span><br></pre></td></tr></table></figure></p><p>出现这个问题，可能是因为删除主键字段的时候，tags含有对post_id的引用。<br>参见<a href="https://groups.google.com/forum/#!topic/sqlalchemy/vfoTsQkqfHI" target="_blank" rel="noopener">这里</a></p><blockquote><p>A human being should be able to change a diaper, plan an invasion, butcher a hog, conn a ship, design a building, write a sonnet, balance accounts, build a wall, set a bone, comfort the dying, take orders, give orders, cooperate, act alone, solve equations, analyze a new problem, pitch manure, program a computer, cook a tasty meal, fight efficiently, die gallantly. Specialization is for insects.</p><p>一个人应该能够更换尿布，策划战争，杀一头猪，开船掌舵，设计建筑，写十四行诗，会计结算，粉刷砌墙，治疗脱臼，安慰临终的人，执行命令，发布命令，携手合作，独立行动，解数学方程，分析问题，施肥铲粪，电脑编程，做可口的饭菜，高效地战斗，勇敢地死去。只有昆虫才专业化。</p></blockquote><p>– Robert A. Heinlein</p>]]></content>
      
      
      <categories>
          
          <category> 日常记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> SqlAlchemy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在 Linux 上安装 MySQL？</title>
      <link href="/blog/2019-06-23/how-to-install-mysql-on-Linux/"/>
      <url>/blog/2019-06-23/how-to-install-mysql-on-Linux/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>在<code>Linux</code>上面安装<code>MySQL</code>本应该是很容易的一件事，但是有的时候不注意细节还是很容易“翻车”，出现一些预料不到的问题。本文在实践中做一个简单的记录。</p><a id="more"></a><h1 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h1><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 mysql]<span class="comment"># uname -a</span></span><br><span class="line">Linux 172.18.1.117 3.10.0-957.el7.x86_64 <span class="comment">#1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line"><span class="comment"># 发行版本</span></span><br><span class="line">[root@172 mysql]<span class="comment"># cat /etc/redhat-release</span></span><br><span class="line">CentOS Linux release 7.6.1810 (Core)</span><br></pre></td></tr></table></figure><h2 id="MySQL-版本"><a href="#MySQL-版本" class="headerlink" title="MySQL 版本"></a>MySQL 版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装完成之后才可以查询到</span></span><br><span class="line">[root@172 mysql]<span class="comment"># mysql --version</span></span><br><span class="line">mysql  Ver 14.14 Distrib 5.7.26, <span class="keyword">for</span> linux-glibc2.12 (x86_64) using  EditLine wrapper</span><br></pre></td></tr></table></figure><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>点击<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">此链接</a>选择适宜版本下载；<br>如图所示进行选择</p><p><img src="/images/download-mysql.png" alt="选择合适版本下载"></p><p>或者使用<code>wget</code>下载：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure></p><h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><p>我一般习惯在工作目录新建<code>temp</code>文件夹，然后存放这些临时文件。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br><span class="line">/root/temp/</span><br><span class="line">tar -xzvf mysql-5.7.26-linux-glibc2.12-x86_64.tar.gz</span><br><span class="line"><span class="comment"># 省略解压结果</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure></p><h1 id="创建安装目录并切换"><a href="#创建安装目录并切换" class="headerlink" title="创建安装目录并切换"></a>创建安装目录并切换</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/mysql</span><br><span class="line"><span class="comment"># 将解压文件移动到新建目录</span></span><br><span class="line">mv mysql-5.7.26-linux-glibc2.12-x86_64/* /usr/<span class="built_in">local</span>/mysql/</span><br><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</span><br></pre></td></tr></table></figure><h1 id="检查并创建用户和用户组"><a href="#检查并创建用户和用户组" class="headerlink" title="检查并创建用户和用户组"></a>检查并创建用户和用户组</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># cat /etc/group | grep mysql</span></span><br><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># cat /etc/passwd |grep mysql</span></span><br><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># groupadd mysql</span></span><br><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># useradd -r -g mysql mysql</span></span><br></pre></td></tr></table></figure><h2 id="创建数据存储目录并赋权"><a href="#创建数据存储目录并赋权" class="headerlink" title="创建数据存储目录并赋权"></a>创建数据存储目录并赋权</h2><p><strong>注意</strong>：忘记授权会出问题，各种各样的问题。我第一次安装的时候没有新建用户并赋予相应权限，导致安装出现<br><code>Starting MySQL... ERROR! The server quit without updating PID file (/var/lib/mysql/xxx.pid).</code>等各种问题。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir data</span><br><span class="line"><span class="comment"># 用户赋权</span></span><br><span class="line">chown -R mysql mysql/</span><br><span class="line">chgrp -R mysql mysql/</span><br></pre></td></tr></table></figure></p><h1 id="安装并初始化"><a href="#安装并初始化" class="headerlink" title="安装并初始化"></a>安装并初始化</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysqld --initialize --user=mysql --basedir=/usr/<span class="built_in">local</span>/mysql/ --datadir=/usr/<span class="built_in">local</span>/mysql/data/   </span><br><span class="line">--pid-file=/usr/<span class="built_in">local</span>/mysql/data/mysql.pid --lc_messages_dir=/usr/<span class="built_in">local</span>/mysql/share --lc_messages=en_US</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:</p><ol><li><p>第一次安装时没有设置<code>--lc_messages_dir</code>和 <code>--lc_messages</code>出现以下报错，所以建议直接使用完整的命令，如果已经出现下面的报错。可以使用<code>rm -rf /usr/local/mysql/data/*</code>将数据删除之后重新初始化；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2019-06-23T08:38:15.774307Z 0 [ERROR] Can<span class="string">'t find error-message file '</span>/usr/<span class="built_in">local</span>/mysql/share/errmsg.sys<span class="string">'. Check error-message file location and '</span>lc-messages-dir<span class="string">' configuration directive.</span></span><br></pre></td></tr></table></figure></li><li><p>此步骤如果出现<code>ERROR</code>错误一定要注意解决，不能继续操作，如：</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ERROR] Can<span class="string">'t find error-message file '</span>/usr/<span class="built_in">local</span>/mysql/share/errmsg.sys<span class="string">'. Check error-message file location and '</span>lc-messages-dir<span class="string">' configuration directive.</span></span><br></pre></td></tr></table></figure></li><li><p>记住最后一行生成的随机密码，安装成功后第一次登录需要使用：</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此处密码随机生成，注意记录</span></span><br><span class="line">2019-06-23T08:52:37.416821Z 1 [Note] A temporary password is generated <span class="keyword">for</span> root@localhost: PDRO-ab.a8jd</span><br></pre></td></tr></table></figure></li><li><p>最容易出现这个错误：<code>Starting MySQL. ERROR! The server quit without updating PID file</code>，网上搜到的解决方案没有啥用，我本次安装走到这里没有出现这个错误，但是下面<em>启动服务</em>环节出现该报错，使用<code>rm  /etc/my.cnf -rf</code>居然有用，暂时不知道造成原因。</p><h2 id="使用-mysqld-safe-启动服务"><a href="#使用-mysqld-safe-启动服务" class="headerlink" title="使用 mysqld_safe 启动服务"></a>使用 mysqld_safe 启动服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysqld_safe --user=mysql</span><br><span class="line">2019-06-23T09:00:10.100530Z mysqld_safe error: <span class="built_in">log</span>-error <span class="built_in">set</span> to <span class="string">'/var/log/mariadb/mariadb.log'</span>, however file don<span class="string">'t exists. Create writable for user '</span>mysql<span class="string">'.</span></span><br></pre></td></tr></table></figure></li></ol><p>根据提示修改配置或者新建<code>log</code>日志存放目录<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 mysql]<span class="comment"># mkdir /var/log/mariadb</span></span><br><span class="line">[root@172 mysql]<span class="comment"># touch /var/log/mariadb/mariadb.log</span></span><br></pre></td></tr></table></figure></p><p>再次启动<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 mysql]<span class="comment"># bin/mysqld_safe --user=mysql</span></span><br><span class="line">2019-06-23T09:00:58.541328Z mysqld_safe Logging to <span class="string">'/var/log/mariadb/mariadb.log'</span>.</span><br><span class="line">2019-06-23T09:00:58.546897Z mysqld_safe Directory <span class="string">'/var/lib/mysql'</span> <span class="keyword">for</span> UNIX socket file don<span class="string">'t exists.</span></span><br></pre></td></tr></table></figure></p><h2 id="根据报错信息修改-my-cnf-中的配置项"><a href="#根据报错信息修改-my-cnf-中的配置项" class="headerlink" title="根据报错信息修改 my.cnf 中的配置项"></a>根据报错信息修改 my.cnf 中的配置项</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 mysql]<span class="comment"># vi /etc/my.cnf</span></span><br><span class="line"><span class="comment"># 此处省略，每个人的配置不一样（我已经将该文件删除了，没办法记住怎么配置的了，这里的错误信息很明确，根据错误修改到不报错即可）</span></span><br><span class="line">[root@172 mysql]<span class="comment"># bin/mysqld_safe --user=mysql</span></span><br><span class="line">2019-06-23T09:03:54.795490Z mysqld_safe Logging to <span class="string">'/var/log/mariadb/mariadb.log'</span>.</span><br><span class="line">2019-06-23T09:03:54.845647Z mysqld_safe Starting mysqld daemon with databases from /usr/<span class="built_in">local</span>/mysql/data</span><br><span class="line">2019-06-23T09:03:55.148856Z mysqld_safe mysqld from pid file /var/run/mariadb/mariadb.pid ended</span><br></pre></td></tr></table></figure><h2 id="加入开机自启动项"><a href="#加入开机自启动项" class="headerlink" title="加入开机自启动项"></a>加入开机自启动项</h2><p>将<code>/usr/local/mysql/support-files/mysql.server</code> 拷贝为<code>/etc/init.d/mysql</code>并设置运行权限，这样就可以使用<code>service mysql</code>命令启动/停止服务，<br>否则就只能使用<code>/usr/local/mysql/bin/mysqld_safe</code>命令来启动服务<br>如果自定义了安装路径,还需要把<code>mysql.server</code>中<code>basedir</code>的相关路径，改为自定义的路径，默认路径是<code>/usr/local/mysql</code>。本文使用默认路径，所以不用修改。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dbserver support-files]<span class="comment"># cp mysql.server /etc/init.d/mysql  </span></span><br><span class="line">[root@dbserver support-files]<span class="comment"># chmod +x /etc/init.d/mysql </span></span><br><span class="line">-- 把mysql注册为开机启动的服务</span><br><span class="line">[root@dbserver support-files]<span class="comment"># chkconfig --add mysql  </span></span><br><span class="line">-- 查看是否添加成功</span><br><span class="line">[root@dbserver support-files]<span class="comment">#  chkconfig --list mysql  </span></span><br><span class="line">Note: This output shows SysV services only and does not include native</span><br><span class="line">      systemd services. SysV configuration data might be overridden by native</span><br><span class="line">      systemd configuration.</span><br><span class="line"></span><br><span class="line">      If you want to list systemd services use <span class="string">'systemctl list-unit-files'</span>.</span><br><span class="line">      To see services enabled on particular target use</span><br><span class="line">      <span class="string">'systemctl list-dependencies [target]'</span>.</span><br><span class="line"></span><br><span class="line">mysql          0:off1:off2:on3:on4:on5:on6:off</span><br></pre></td></tr></table></figure></p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># service mysql start</span></span><br><span class="line">Starting MySQL. ERROR! The server quit without updating PID file (/usr/<span class="built_in">local</span>/mysql/data/172.18.1.117.pid).</span><br></pre></td></tr></table></figure><p>此时删除配置文件，可以解决该报错（原因未知，没有深究）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 mysql]<span class="comment"># rm  /etc/my.cnf -rf</span></span><br></pre></td></tr></table></figure></p><p>重新启动<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 mysql]<span class="comment"># /etc/init.d/mysql start</span></span><br><span class="line">Starting MySQL.Logging to <span class="string">'/usr/local/mysql/data/172.18.1.117.err'</span>.</span><br><span class="line"> SUCCESS!</span><br></pre></td></tr></table></figure></p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 mysql]<span class="comment"># /usr/local/mysql/bin/mysql -uroot -pPDRO-ab.a8jd</span></span><br></pre></td></tr></table></figure><p>修改密码<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有的文章说此处不能使用单引号，但是我使用单引号也成功了，好像没有问题。YOUR PASSWORD 为你自己设置的数据库的密码，这个要记住了，不然就要自己再去手动重置密码了！</span></span><br><span class="line">mysql&gt;  <span class="built_in">set</span> password=password(<span class="string">"YOUR PASSWORD"</span>);</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br><span class="line">mysql&gt; quit</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure></p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>上一步中启动 mysql 的时候使用的是全路径，有的时候会比较麻烦，可以通过配置环境变量修改；<br>执行<code>vi ~/.bash_profile</code>修改文件中<code>PATH</code>一行，将<code>/usr/local/mysql/bin</code> 加入到<code>PATH=$PATH:$HOME/bin</code>一行之后<br><strong>注意</strong>：这种方法只对当前登录用户生效。</p><h1 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h1><p><a href="https://blog.csdn.net/qq_30000313/article/details/85333971" target="_blank" rel="noopener">linux 安装 mysql5.7.24 - 绿色落日的博客 - CSDN 博客</a><br><a href="https://blog.csdn.net/zhou920786312/article/details/77750604" target="_blank" rel="noopener">linux 安装 mysql5.7.19</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用 flask-celery 实现异步任务？</title>
      <link href="/blog/2019-06-18/how-to-use-flask-celery/"/>
      <url>/blog/2019-06-18/how-to-use-flask-celery/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h1><ul><li><p><code>redis</code>版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli --version</span><br><span class="line">redis-cli 5.0.4</span><br></pre></td></tr></table></figure></li><li><p><code>celery</code>版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">celery --version</span><br><span class="line">4.3.0 (rhubarb)</span><br></pre></td></tr></table></figure></li><li><p><code>Flask</code>和 <code>Python</code> 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flask --version</span><br><span class="line">Flask 1.0.2</span><br><span class="line">Python 3.6.5 (default, Apr  1 2018, 05:46:30) </span><br><span class="line">[GCC 7.3.0]</span><br></pre></td></tr></table></figure></li><li><p><code>Linux</code> 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:Ubuntu</span><br><span class="line">Description:Ubuntu 18.04 LTS</span><br><span class="line">Release:18.04</span><br><span class="line">Codename:bionic</span><br><span class="line"><span class="comment"># ---</span></span><br><span class="line">uname -a</span><br><span class="line">Linux <span class="built_in">local</span> 4.15.0-22-generic <span class="comment">#24-Ubuntu SMP Wed May 16 12:15:17 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Celery是什么"><a href="#Celery是什么" class="headerlink" title="Celery是什么"></a><code>Celery</code>是什么</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>Celery</code> 是一个“自带电池”的专注于实时处理和任务调度的分布式任务队列，同时提供操作和维护分布式系统所需的<strong>工具</strong>。</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/images/structure-of-celery.png" alt="celery架构图"></p><center><span>celery架构图</span></center><p><code>Celery</code>支持定时任务（Celery Beat）和异步执行(Async Task)两种模式。同步模式为任务调用方等待任务执行完成，这种方式等同于 RPC(Remote Procedure Call)， 异步方式为任务在后台执行，调用方调用后就去做其他工作，之后再根据需要来查看任务结果。<code>Celery</code>自己没有实现消息队列，而是直接已存在的消息队列作为<code>Broker</code>角色。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>使用 <code>Celery</code> 运行后台任务并不像在线程中这样做那么简单，但是好处多多。<code>Celery</code> 具有分布式架构，使应用更加易于扩展。一个 <code>Celery</code> 安装有三个核心组件：</p><ul><li><code>Celery</code> 客户端: 用于发布后台作业。当与 <code>Flask</code> 一起工作的时候，客户端与 <code>Flask</code> 应用一起运行。</li><li>Celery workers: 任务消费者，是运行后台作业的进程。<code>Celery</code> 支持本地和远程的 <code>workers</code>，因此你就可以在 <code>Flask</code> 服务器上启动一个单独的 <code>worker</code>，随后随着你的应用需求的增加而新增更多的 <code>workers</code>。</li><li>消息代理（<code>Broker</code>）: 客户端通过消息队列和 <code>workers</code> 进行通信，<code>Celery</code> 支持多种方式来实现这些队列。常见的为 <code>RabbitMQ</code> 和 <code>Redis</code>。</li><li>任务结果存储：用来存储<code>workers</code>执行的任务结果。<br>详见<a href="http://docs.jinkan.org/docs/celery/getting-started/introduction.html#id19" target="_blank" rel="noopener">Celery 是……</a></li></ul><h2 id="Celery的安装配置"><a href="#Celery的安装配置" class="headerlink" title="Celery的安装配置"></a><code>Celery</code>的安装配置</h2><h3 id="安装-Celery"><a href="#安装-Celery" class="headerlink" title="安装 Celery"></a>安装 <code>Celery</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install celery</span><br></pre></td></tr></table></figure><p>安装时会自动解决依赖：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Installing collected packages: vine, amqp, kombu, billiard, celery</span><br></pre></td></tr></table></figure></p><p>验证<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">celery --version</span><br><span class="line">4.3.0 (rhubarb)</span><br></pre></td></tr></table></figure></p><h3 id="与-redis-结合使用"><a href="#与-redis-结合使用" class="headerlink" title="与 redis 结合使用"></a>与 <code>redis</code> 结合使用</h3><p>redis 安装可以参考之前写的这篇文章<a href="https://imoyao.github.io/blog/2019-04-11/how-to-install-Redis-on-Linux/">Linux 下如何安装 Redis？</a></p><p><strong>注意</strong>： 此处需要同时安装<code>redis</code>客户端和<code>redis</code>的<code>Python</code>支持。</p><h3 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">imoyao@<span class="built_in">local</span>:~$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"_kombu.binding.celery"</span></span><br><span class="line">2) <span class="string">"celery-task-meta-a9db6911-e15a-4b9e-b321-958f5298652a"</span></span><br><span class="line">3) <span class="string">"celery-task-meta-e22b0603-8117-4f0d-ac6b-ad621738e256"</span></span><br><span class="line">4) <span class="string">"unacked_mutex"</span></span><br><span class="line">5) <span class="string">"_kombu.binding.celery.pidbox"</span></span><br><span class="line">6) <span class="string">"celery-task-meta-aac524bd-cb47-4493-b0dd-9712a98a3f14"</span></span><br><span class="line">7) <span class="string">"_kombu.binding.celeryev"</span></span><br><span class="line">8) <span class="string">"celery-task-meta-ccd8d274-7f14-4abc-8244-e80f01932097"</span></span><br><span class="line">9) <span class="string">"celery-task-meta-3b2b3efa-4ad7-4c7e-b92d-27636eaeaa6b"</span></span><br><span class="line">127.0.0.1:6379&gt; get celery-task-meta-a9db6911-e15a-4b9e-b321-958f5298652a</span><br><span class="line"><span class="string">"&#123;\"status\": \"SUCCESS\", \"result\": 30, \"traceback\": null, \"children\": [], \"task_id\": \"a9db6911-e15a-4b9e-b321-958f5298652a\", \"date_done\": \"2019-06-13T18:43:43.491009\"&#125;"</span></span><br></pre></td></tr></table></figure><h2 id="如何在项目中使用Celery"><a href="#如何在项目中使用Celery" class="headerlink" title="如何在项目中使用Celery"></a>如何在项目中使用<code>Celery</code></h2><p>以与<code>Flask</code>结合为例(使用<code>redis</code>作为<code>backend</code>)</p><ul><li>创建<code>celery</code>实例</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app\__init__.py</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_celery</span><span class="params">(app)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参见：http://docs.jinkan.org/docs/flask/patterns/celery.html</span></span><br><span class="line"><span class="string">    初始化celery</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    celery = Celery(app.import_name, broker=app.config[<span class="string">'CELERY_BROKER_URL'</span>])</span><br><span class="line">    celery.conf.update(app.config)</span><br><span class="line">    TaskBase = celery.Task</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ContextTask</span><span class="params">(TaskBase)</span>:</span></span><br><span class="line">        abstract = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">with</span> app.app_context():</span><br><span class="line">                <span class="keyword">return</span> TaskBase.__call__(self, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    celery.Task = ContextTask</span><br><span class="line">    <span class="keyword">return</span> celery</span><br></pre></td></tr></table></figure><ul><li>创建后台任务</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> celery.utils.log <span class="keyword">import</span> get_task_logger</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> create_app, init_celery</span><br><span class="line"></span><br><span class="line">lg = get_task_logger(__name__)      <span class="comment"># 记录日志</span></span><br><span class="line">celery = init_celery(create_app(os.getenv(<span class="string">'FLASK_CONFIG'</span>, <span class="string">'default'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># @celery.task(name='pmrearend.task.log_it')        # 此处是解决导入失败的一种方案，但是感觉不够优雅，需要深入了解</span></span><br><span class="line"><span class="meta">@celery.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_it</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">    msg = num1 + num2</span><br><span class="line">    print(msg)</span><br><span class="line">    lg.debug(<span class="string">"in log_test()"</span>)</span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># task = log_it.delay(5,8)</span></span><br><span class="line">    task = log_it.apply_async(args=[<span class="number">10</span>, <span class="number">20</span>], countdown=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><ul><li><p>新建目录及文件</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /var/<span class="built_in">log</span>/celery/</span><br><span class="line">sudo touch /var/<span class="built_in">log</span>/celery/celery.log</span><br></pre></td></tr></table></figure></li><li><p>启动 celery worker 服务</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">celery -A task worker -l debug -f /var/<span class="built_in">log</span>/celery/celery.log</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="遇到的问题记录"><a href="#遇到的问题记录" class="headerlink" title="遇到的问题记录"></a>遇到的问题记录</h3><ol><li><p>sqlalchemy.exc.InvalidRequestError</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlalchemy.exc.InvalidRequestError: Table <span class="string">'user'</span> is already defined <span class="keyword">for</span> this MetaData instance.  </span><br><span class="line">Specify <span class="string">'extend_existing=True'</span> to redefine options and columns on an existing Table object.</span><br></pre></td></tr></table></figure><p> 解决：在对应 model 中添加<code>&#39;extend_existing&#39;: True</code></p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__table_args__ = &#123;<span class="string">'extend_existing'</span>: <span class="keyword">True</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>celery: command not found</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo: celery: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p> 解决：按照绝对路径调用<code>celery</code></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> celery</span><br><span class="line">/home/imoyao/envs/py3flk/bin/celery</span><br></pre></td></tr></table></figure><p> 替换此处<code>celery</code>的位置即可运行（TODO：不够优雅，暂时测试性解决方案）</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /home/imoyao/envs/py3flk/bin/celery -A pmrearend.task worker -l debug -f /var/<span class="built_in">log</span>/celery/celery.log</span><br></pre></td></tr></table></figure></li><li><p>没有导入<code>task</code>模块</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2019-06-14 02:32:40,115: ERROR/MainProcess] Received unregistered task of <span class="built_in">type</span> <span class="string">'pmrearend.log_it'</span>.</span><br><span class="line">The message has been ignored and discarded.</span><br><span class="line"></span><br><span class="line">Did you remember to import the module containing this task?</span><br><span class="line">Or maybe you<span class="string">'re using relative imports?</span></span><br></pre></td></tr></table></figure><p> 解决：每个任务必须有不同的名称。如果没有显示提供名称，任务装饰器将会自动产生一个，产生的名称会基于这些信息： 1）任务定义所在的模块， 2）任务函数的名称</p><p> 显示设置任务名称的例子：在装饰器<a href="mailto:`@app.task" target="_blank" rel="noopener">`@app.task</a><code>中加入参数</code>name<code>，就可以被</code>celery`读取到。  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@celery.task(name='pmrearend.task.log_it')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_it</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">    msg = num1 + num2</span><br><span class="line">    print(msg)</span><br><span class="line">    lg.debug(<span class="string">"in log_test()"</span>)</span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line">```   </span><br><span class="line">正常运行结果</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">43</span>,<span class="number">139</span>: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at <span class="number">0x7f72a03fef28</span>&gt; (args:(<span class="string">'pmrearend.task.log_it'</span>, <span class="string">'a9db6911-e15a-4b9e-b321-958f5298652a'</span>, &#123;<span class="string">'lang'</span>: <span class="string">'py'</span>, <span class="string">'task'</span>: <span class="string">'pmrearend.task.log_it'</span>, <span class="string">'id'</span>: <span class="string">'a9db6911-e15a-4b9e-b321-958f5298652a'</span>, <span class="string">'shadow'</span>: <span class="keyword">None</span>, <span class="string">'eta'</span>: <span class="string">'2019-06-13T18:43:43.139123+00:00'</span>, <span class="string">'expires'</span>: <span class="keyword">None</span>, <span class="string">'group'</span>: <span class="keyword">None</span>, <span class="string">'retries'</span>: <span class="number">0</span>, <span class="string">'timelimit'</span>: [<span class="keyword">None</span>, <span class="keyword">None</span>], <span class="string">'root_id'</span>: <span class="string">'a9db6911-e15a-4b9e-b321-958f5298652a'</span>, <span class="string">'parent_id'</span>: <span class="keyword">None</span>, <span class="string">'argsrepr'</span>: <span class="string">'[10, 20]'</span>, <span class="string">'kwargsrepr'</span>: <span class="string">'&#123;&#125;'</span>, <span class="string">'origin'</span>: <span class="string">'gen4669@local'</span>, <span class="string">'reply_to'</span>: <span class="string">'a2563c50-9249-3718-85a8-9ad44174831c'</span>, <span class="string">'correlation_id'</span>: <span class="string">'a9db6911-e15a-4b9e-b321-958f5298652a'</span>, <span class="string">'delivery_info'</span>: &#123;<span class="string">'exchange'</span>: <span class="string">''</span>, <span class="string">'routing_key'</span>: <span class="string">'celery'</span>, <span class="string">'priority'</span>: <span class="number">0</span>, <span class="string">'redelivered'</span>: <span class="keyword">None</span>&#125;&#125;, <span class="string">b'[[10, 20], &#123;&#125;, &#123;"callbacks": null, "errbacks": null, "chain": null, "chord": null&#125;]'</span>, <span class="string">'application/json'</span>, <span class="string">'utf-8'</span>) kwargs:&#123;&#125;)</span><br><span class="line">[2019-06-14 02:43:43,281: DEBUG/MainProcess] basic.qos: prefetch_count-&gt;4</span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">43</span>,<span class="number">284</span>: WARNING/ForkPoolWorker<span class="number">-1</span>] <span class="number">30</span></span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">43</span>,<span class="number">286</span>: DEBUG/MainProcess] Task accepted: pmrearend.task.log_it[a9db6911-e15a<span class="number">-4</span>b9e-b321<span class="number">-958</span>f5298652a] pid:<span class="number">4089</span></span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">43</span>,<span class="number">287</span>: DEBUG/ForkPoolWorker<span class="number">-1</span>] pmrearend.task.log_it[a9db6911-e15a<span class="number">-4</span>b9e-b321<span class="number">-958</span>f5298652a]: <span class="keyword">in</span> log_test()</span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">43</span>,<span class="number">504</span>: INFO/ForkPoolWorker<span class="number">-1</span>] Task pmrearend.task.log_it[a9db6911-e15a<span class="number">-4</span>b9e-b321<span class="number">-958</span>f5298652a] succeeded <span class="keyword">in</span> <span class="number">0.22014467700500973</span>s: <span class="number">30</span></span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">44</span>,<span class="number">751</span>: INFO/MainProcess] Received task: pmrearend.task.log_it[aac524bd-cb47<span class="number">-4493</span>-b0dd<span class="number">-9712</span>a98a3f14]  ETA:[<span class="number">2019</span><span class="number">-06</span><span class="number">-13</span> <span class="number">18</span>:<span class="number">43</span>:<span class="number">54.619709</span>+<span class="number">00</span>:<span class="number">00</span>] </span><br><span class="line">[2019-06-14 02:43:44,752: DEBUG/MainProcess] basic.qos: prefetch_count-&gt;5</span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">54</span>,<span class="number">621</span>: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at <span class="number">0x7f72a03fef28</span>&gt; (args:(<span class="string">'pmrearend.task.log_it'</span>, <span class="string">'aac524bd-cb47-4493-b0dd-9712a98a3f14'</span>, &#123;<span class="string">'lang'</span>: <span class="string">'py'</span>, <span class="string">'task'</span>: <span class="string">'pmrearend.task.log_it'</span>, <span class="string">'id'</span>: <span class="string">'aac524bd-cb47-4493-b0dd-9712a98a3f14'</span>, <span class="string">'shadow'</span>: <span class="keyword">None</span>, <span class="string">'eta'</span>: <span class="string">'2019-06-13T18:43:54.619709+00:00'</span>, <span class="string">'expires'</span>: <span class="keyword">None</span>, <span class="string">'group'</span>: <span class="keyword">None</span>, <span class="string">'retries'</span>: <span class="number">0</span>, <span class="string">'timelimit'</span>: [<span class="keyword">None</span>, <span class="keyword">None</span>], <span class="string">'root_id'</span>: <span class="string">'aac524bd-cb47-4493-b0dd-9712a98a3f14'</span>, <span class="string">'parent_id'</span>: <span class="keyword">None</span>, <span class="string">'argsrepr'</span>: <span class="string">'[10, 20]'</span>, <span class="string">'kwargsrepr'</span>: <span class="string">'&#123;&#125;'</span>, <span class="string">'origin'</span>: <span class="string">'gen4706@local'</span>, <span class="string">'reply_to'</span>: <span class="string">'ee66dc1c-aebd-3111-9ef4-f07a71943fc0'</span>, <span class="string">'correlation_id'</span>: <span class="string">'aac524bd-cb47-4493-b0dd-9712a98a3f14'</span>, <span class="string">'delivery_info'</span>: &#123;<span class="string">'exchange'</span>: <span class="string">''</span>, <span class="string">'routing_key'</span>: <span class="string">'celery'</span>, <span class="string">'priority'</span>: <span class="number">0</span>, <span class="string">'redelivered'</span>: <span class="keyword">None</span>&#125;&#125;, <span class="string">b'[[10, 20], &#123;&#125;, &#123;"callbacks": null, "errbacks": null, "chain": null, "chord": null&#125;]'</span>, <span class="string">'application/json'</span>, <span class="string">'utf-8'</span>) kwargs:&#123;&#125;)</span><br><span class="line">[2019-06-14 02:43:54,631: DEBUG/MainProcess] basic.qos: prefetch_count-&gt;4</span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">54</span>,<span class="number">637</span>: WARNING/ForkPoolWorker<span class="number">-1</span>] <span class="number">30</span></span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">54</span>,<span class="number">639</span>: DEBUG/ForkPoolWorker<span class="number">-1</span>] pmrearend.task.log_it[aac524bd-cb47<span class="number">-4493</span>-b0dd<span class="number">-9712</span>a98a3f14]: <span class="keyword">in</span> log_test()</span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">54</span>,<span class="number">645</span>: DEBUG/MainProcess] Task accepted: pmrearend.task.log_it[aac524bd-cb47<span class="number">-4493</span>-b0dd<span class="number">-9712</span>a98a3f14] pid:<span class="number">4089</span></span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">54</span>,<span class="number">650</span>: INFO/ForkPoolWorker<span class="number">-1</span>] Task pmrearend.task.log_it[aac524bd-cb47<span class="number">-4493</span>-b0dd<span class="number">-9712</span>a98a3f14] succeeded <span class="keyword">in</span> <span class="number">0.012691148993326351</span>s: <span class="number">30</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">celery.platforms.LockFailed: [Errno 13] Permission denied: <span class="string">'/home/xxx/celerybeat.pid'</span></span><br><span class="line">```    </span><br><span class="line">pid 文件没有权限；这种情况有两种解决办法：</span><br><span class="line">- 修改 pid 文件存储路径，放到当前执行用户有权限的位置</span><br><span class="line">```bash</span><br><span class="line">celery beat -A celeryapp --loglevel=INFO --pidfile=<span class="string">"/tmp/celerybeat.pid"</span>        <span class="comment"># 修改路径</span></span><br></pre></td></tr></table></figure><ul><li>对 pid 文件所在目录加权限，然后执行：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown -R YOUR_USER_NAME:YOUR_USER_NAME  CURRENT_PATH</span><br><span class="line">celery -A celery_worker:celery beat --loglevel=INFO</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://github.com/celery/celery/issues/3828" target="_blank" rel="noopener">参见这里</a></p><h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><p><strong>不要</strong>将 task 写进类中，因为可能导致执行出错等各种问题，如果真的要这么做，可以参考这里：<br>参见 <a href="https://stackoverflow.com/questions/9250317/using-class-methods-as-celery-tasks" target="_blank" rel="noopener">using class methods as celery tasks</a></p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>因为个人时间关系，这个暂时没有学完。关于<code>Celery</code>的使用需要进一步实践学习。</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="http://docs.celeryproject.org/en/latest/" target="_blank" rel="noopener">Celery 4.3.0 documentation »</a><br><a href="https://www.jianshu.com/p/807efde55d81" target="_blank" rel="noopener">在 Flask 中使用 Celery 的最佳实践</a><br><a href="https://blog.csdn.net/libing_thinking/article/details/78547816" target="_blank" rel="noopener">Celery 中文文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> HOWTO </tag>
            
            <tag> Celery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解 cookie、session 与 token</title>
      <link href="/blog/2019-06-18/diff-cookie-session-token/"/>
      <url>/blog/2019-06-18/diff-cookie-session-token/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="https://segmentfault.com/a/1190000017831088" target="_blank" rel="noopener">彻底弄懂 session，cookie，token</a><br><a href="https://segmentfault.com/a/1190000015881055" target="_blank" rel="noopener">token 与 sessionId 的区别——学习笔记</a><br><a href="https://www.liangzl.com/get-article-detail-16019.html" target="_blank" rel="noopener">彻底理解 cookie，session，token</a><br><a href="https://www.zhihu.com/question/23202402" target="_blank" rel="noopener">HTTP 是一个无状态的协议。这句话里的无状态是什么意思？</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 之 Web 开发框架对比——Flask vs webpy</title>
      <link href="/blog/2019-06-05/Flask-vs-webpy/"/>
      <url>/blog/2019-06-05/Flask-vs-webpy/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><code>Python</code> 常用的<code>web</code>开发框架有很多如<code>Django</code>、<code>Flask</code>、<code>Tornado</code>、<code>Web.py</code>等，我们之前项目中使用的是 <code>Web.py</code>,但是新项目中选择哪个？或许是个值得思考的问题。本文主要对<code>Web.py</code>和<code>Flask</code>进行一个简单的对比。</p><a id="more"></a><h2 id="为什么要从Web-py迁移到Flask"><a href="#为什么要从Web-py迁移到Flask" class="headerlink" title="为什么要从Web.py迁移到Flask"></a>为什么要从<code>Web.py</code>迁移到<code>Flask</code></h2><p>大势所趋。根据最新的<a href="https://www.jetbrains.com/research/python-developers-survey-2018/" target="_blank" rel="noopener">Python 开发者调研-2018</a>结果显示，<code>Flask</code>和<code>Django</code>已经成为最流行的<code>web</code>开发框架。对企业的良性发展和开发者个人成长而言，使用热门技术都是值得鼓励且必要的。而且，众所周知，官方计划在<code>2020</code>年停止<code>Python2</code>支持，而相比<code>Flask</code>而言,<code>Web.py</code>的版本更新计划有点跟不上节奏的感觉。</p><p><img src="/images/Web-frameworks-python-developers-survey-2018.jpg" alt="Web-frameworks-python-developers-survey-2018"></p><center><span>Web-frameworks-python-developers-survey-2018</span></center><h2 id="TL-DR，Flask-对比-Web-py-的不同点"><a href="#TL-DR，Flask-对比-Web-py-的不同点" class="headerlink" title="TL;DR，Flask 对比 Web.py 的不同点"></a>TL;DR，<code>Flask</code> 对比 <code>Web.py</code> 的不同点</h2><p><code>Flask</code>拥有活跃的社区文化和丰富而强大的第三方扩展，而<code>Web.py</code>在原作者（Aaron Swartz）自杀之后自身维护已举步维艰，第三方扩展的发展更是不言而喻。</p><ul><li><p><strong>维护积极性</strong>  - 最新版本分别为<code>Flask-1.0.2</code>和 <code>webpy-0.39</code>。</p>  <figure class="half"><br>      <img src="/images/flask-contributors.jpg" alt="flask-contributors"><br>      <center><span>flask-contributors</span></center><br>      <img src="/images/webpy-contributors.jpg" alt="webpy-contributors"><br>      <center><span>webpy-contributors</span></center><br>  </figure></li><li><p><strong>官方文档</strong> - <code>Flask</code>具有良好的官方文档，并且有国内使用者翻译的中文文档；<code>Web.py</code>只有勉强够用、捉襟见肘的入门级官方文档，剩下的需要开发人员自行摸索。</p></li><li><strong>社区活跃度</strong> - <code>Flask</code>拥有活跃的社区文化和数量庞大的拥趸者，<code>Web.py</code>国内只有不活跃的专门的豆瓣小组或者在一些热门<code>Python</code>社区偶有提及。</li><li>第三方扩展  <ul><li>表单 - <code>Flask</code> 使用扩展<code>Flask-WTF</code>和<code>WTForms</code>可以实现很好的表单验证和 <code>csrf</code> 安全保护；（参阅<a href="https://www.jianshu.com/p/7e16877757f8" target="_blank" rel="noopener">Flask-WTF 与 WTForms 的用法详解</a>）；而<code>Web.py</code>自带<a href="http://webpy.org/form" target="_blank" rel="noopener">Form 库</a>，可以实现表单及简单校验。</li><li>数据库 -  <code>Flask</code> 使用扩展<code>Flask-SQLAlchemy</code>实现对数据库的<code>ORM</code>操作,可以很好地管理和实现数据库的迁移(借助<code>Flask-Migrate</code>)工作；<code>Web.py</code>我们使用自己封装的<code>database.py</code>。</li><li>身份验证和权限 - <code>Flask</code>提供安全<code>cookie</code>作为您自己实现的工具，第三方扩展如<code>Flask-Login</code>(用户会话管理)，<code>Flask-HTTPAuth</code><sup>①</sup>（简化了使用<code>Flask</code>路由的<code>HTTP</code>身份验证的使用），<code>Flask-Security</code>（提供一站式管理）， <code>Flask-Social</code>（用于添加“社交”或<code>OAuth</code>登录和连接管理）等，这些扩展良莠不齐，使用时需要对其有个初步了解并进行遴选；<code>Web.py</code>还是要自己造轮子。</li><li><code>RESTful</code> - 使用<code>Flask-RESTful</code> 可以创建<code>REST</code>的<code>API</code>。</li><li>强大的页面渲染 -<code>Flask</code>使用<code>jinja2</code>作为模板引擎；<code>Web.py</code>使用<code>Templetor</code>,类 <code>python</code>,写起来信手拈来，无痛衔接，也可以使用<code>Mako</code>模板引擎，两者平分秋色。性能对比见这里 &gt;&gt; <a href="http://www.pythontip.com/blog/post/2239/" target="_blank" rel="noopener">几个模板系统的性能对比</a></li></ul></li><li>伸缩性 - <code>Flask</code>既可以像<code>Web.py</code>那样做微框架开发一个很小的<code>web</code>应用，也可以借助上方的各种扩展做到<code>Django</code>级别的应用。</li></ul><h2 id="Flask-框架"><a href="#Flask-框架" class="headerlink" title="Flask 框架"></a>Flask 框架</h2><blockquote><p>Flask is a microframework for Python based on Werkzeug, Jinja 2 and good intentions.<br>Flask 是一个基于 <code>Jinja2</code> 模板引擎和 <code>Werkzeug WSGI</code> 套件的一个微型的<code>Web</code>开发框架。体现了<code>logo</code>中的口号<code>web development, one drop at a time.</code>(<code>web</code>开发,一次一滴。)</p></blockquote><h3 id="什么是-“微”"><a href="#什么是-“微”" class="headerlink" title="什么是 “微”"></a>什么是 “微”</h3><blockquote><p>“微” (“Micro”) 并不是意味着把整个 <code>Web</code> 应用放入到一个 <code>Python</code> 文件，尽管确实可以这么做。当然“微” (“Micro”) 也不是意味 <code>Flask</code> 的功能上是不足的。微框架中的 “微” (“Micro”) 是指 <code>Flask</code> 旨在保持代码简洁且易于扩展。<code>Flask</code> 不会替你做出太多决策——比如使用何种数据库。而那些 <code>Flask</code> 所选择的——比如使用何种模板引擎——则很容易替换。除此之外的一切都可由你掌握。如此，<code>Flask</code> 可以与您珠联璧合。<br>默认情况下，<code>Flask</code> 并不包含数据库抽象层，表单验证或者任何其他现有的库( <code>Django</code> )能够处理的。相反，<code>Flask</code> 支持扩展，这些扩展能够添加功能到你的应用，像是 <code>Flask</code> 本身实现的一样。众多的扩展提供了数据库集成，表单验证，上传处理，多种开放的认证技术等功能。<code>Flask</code> 可能是“微”型的，但它可以游刃有余地应付需求繁杂的生产环境的使用。</p></blockquote><p>① 在 <code>Web</code> 应用中，我们经常需要保护我们的 <code>api</code>，以避免非法访问。比如，只允许登录成功的用户发表评论等。<code>Flask-HTTPAuth</code> 扩展可以很好地对 <code>HTTP</code> 的请求进行认证，不依赖于 <code>Cookie</code> 和 <code>Session</code>。而是基于密码和基于令牌 (<code>token</code>)。</p><h2 id="Web-py-框架"><a href="#Web-py-框架" class="headerlink" title="Web.py 框架"></a><code>Web.py</code> 框架</h2><blockquote><p>Web.py is a web framework for Python that is as simple as it is powerful.<br>Web.py 是一个简单且功能强大的用于 Python 语言的 web 框架。</p></blockquote><h3 id="Web-py设计哲学"><a href="#Web-py设计哲学" class="headerlink" title="Web.py设计哲学"></a><code>Web.py</code>设计哲学</h3><p><code>Web.py</code>的口号是<code>Think about the ideal way to write a web app. Write the code to make it happen.</code>（思考编写<code>web</code>应用程序的理想方式，然后去编写代码实现它。）<br>在用<code>Python</code>编写<code>web</code>应用程序的时候，我想象自己想要<code>API</code>的方式。它始于导入<code>web</code>，然后有一个定义<code>URL</code>的地方，处理<code>GET</code>和<code>POST</code>的简单函数和一些处理输入变量的东西。一旦代码对我来说看起来是正确的, 我就会想尽办法使它在不更改应用程序代码的情况下执行——结果就是 <code>Web.py</code>。<br>有人抱怨说我“搞了另一套模板语言”（yet another template language），我写了更多文字关于我的设计理念：<a href="http://groups.google.com/group/webpy/msg/f266701d97e7ceb1" target="_blank" rel="noopener">参阅</a></p><p>你不必使用它——<code>Web.py</code>的每个部分都与其他部分完全分离。但你是对的, 它是“另一种模板语言”，而我不会为此道歉。<br><code>Web.py</code> 的目标是构建制作 <code>web</code> 应用程序的理想方法。如果为了实现这个目标需要有微小差异化的来重塑陈旧的东西, 我会捍卫自己对它们进行改造的权利。<code>理想的方式</code>和<code>几乎理想的方式</code>之间的区别, 正如马克·吐温所言：是闪电和萤火虫之间的区别。（The difference between the right word and the almost right word is the difference between lightning and the lightning Bug.）<br>但这些不仅仅是细微的差异。<code>Web.py</code> 允许您构建 <code>http</code> 响应, 而不暴露 <code>Python</code> 对象。<code>Web.py</code> 使数据库更易使用,而不试图使数据库看起来像一个对象。 <code>Web.py</code> 模板系统试图把 <code>Python</code> 纳入 <code>HTML</code>而不是想出另一种方法来编写 <code>HTML</code>。没多少人真正尝试过这么做的可能性。<br>你可以不同意这些方法更好并给出原因，但仅仅批评它们与众不同是浪费时间。是的, 它们天生骄傲。我的话讲完了。<br>文字来源：<a href="http://webpy.org/philosophy" target="_blank" rel="noopener">The Web.py Philosophy</a></p><h2 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h2><h3 id="Web-py"><a href="#Web-py" class="headerlink" title="Web.py"></a>Web.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line">urls = (</span><br><span class="line">    <span class="string">'/'</span>, <span class="string">'Index'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, world!"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># def POST(self):</span></span><br><span class="line">    <span class="comment">#     pass    # TODO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    web.config.debug = <span class="keyword">False</span></span><br><span class="line">    app = web.application(urls, globals())</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><ol><li>导入<code>web</code>模块；</li><li>组装<code>url</code>结构；<ul><li>第一部分为匹配<code>URL</code>的正则表达式，第二部分是接受请求的类名称</li></ul></li><li>定义类<ul><li>定义处理<code>GET</code>请求的方法；</li><li>定义（可选的）处理<code>POST</code>请求的方法；</li></ul></li><li><code>debug</code>模式<br> 当应用在内建的服务器中运行时，它会以<code>debug</code>模式启动程序。在<code>debug</code>模式下，任何代码、模板的修改，都会让服务器重新加载它们，然后还会输出有用的错误消息。<br> 只有在生产环境中<code>debug</code>模式是关闭的，如果你想禁用<code>debug</code>模式，你可以在创建程序/模板前添加置为<code>False</code>。</li><li>创建应用，这个<code>application</code>会在这个文件的全局命名空间中查找<code>urls</code>中定义的对应类。</li><li>启动应用。</li></ol><h3 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/',methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    打开调试模式的另一种设置方式</span></span><br><span class="line"><span class="string">    app.debug = True</span></span><br><span class="line"><span class="string">    app.run()</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>运行之后，浏览<code>http://0.0.0.1:5000/</code>即可访问。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python app.py</span><br><span class="line"> * Running on http://0.0.0.1:5000/</span><br></pre></td></tr></table></figure></p><p>代码解释</p><ol><li>导入<code>Flask</code>类；</li><li>实例化，即生成我们的 <code>WSGI</code> 应用，第一个参数是应用模块的名称。 如果你使用的是单一的模块（就如本例），第一个参数应该使用 <code>__name__</code>。我们还可以传递给它模块或包的名称。这样 <code>Flask</code> 才会知道去哪里寻找模板、静态文件等等。</li><li>使用装饰器 <code>route()</code> 告诉 <code>Flask</code> 哪个 <code>URL</code> 才能触发我们的函数。<ul><li>默认情况下，路由只会响应 <code>GET</code> 请求， 但是能够通过给 <code>route()</code> 装饰器提供 <code>methods</code> 参数改变。</li></ul></li><li>定义函数，该函数名也是用来给特定函数生成 <code>URLs</code>，并且返回我们想要显示在用户浏览器上的信息。</li><li>最后我们用函数 <code>run()</code> 启动本地服务器来运行我们的应用。<ul><li><code>host=&#39;0.0.0.0&#39;</code>你可以让你的服务器对外可见。</li><li><code>debug=True</code>开启调式模式,仅适用于开发阶段，在代码修改的时候服务器能够自动加载，发生错误之后可以更好追踪调试； <strong>生产模式时，一定要关闭该选项。</strong></li></ul></li></ol><p><strong>注意</strong><br>可能有人想要使用<code>Flask</code>实现<code>Web.py</code>类似的<code>RESTful</code>的代码设计风格，借助<code>Flask-RESTful</code>可以实现像<code>Web.py</code>一样的<code>RESTful</code>设计。示例如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_restful <span class="keyword">import</span> Resource, Api</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">api = Api(app)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span><span class="params">(Resource)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'hello'</span>: <span class="string">'world'</span>&#125;</span><br><span class="line"></span><br><span class="line">api.add_resource(HelloWorld, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><h2 id="关于-Flask-的蓝本-蓝图（Blueprint）"><a href="#关于-Flask-的蓝本-蓝图（Blueprint）" class="headerlink" title="关于 Flask 的蓝本/蓝图（Blueprint）"></a>关于 Flask 的蓝本/蓝图（Blueprint）</h2><p>在<code>Flask</code>中可以用<code>Blueprint</code> (蓝图) 实现应用的<strong>模块化</strong>，应用层次清晰，蓝图可以极大地<strong>简化大型应用</strong>并为扩展提供集中的注册入口。<br>蓝图通常作用于相同的<code>URL</code>前缀，如<code>/user/:id</code>、<code>/user/profile</code>这样的地址，都以<code>/user</code>开头，它们是一组用户相关的操作，那么就可以放在一个模块中。<br>在大型项目中，一般都是协同开发各共同进行的，使用蓝图可以避免互相干扰，开发人员一看路由就能很快的找到对应的视图，可以更容易地<strong>开发和维护</strong>项目。</p><p>一个典型的使用蓝图组织应用的项目结构：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">app/</span><br><span class="line">    __init__.py</span><br><span class="line">    admin/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    home/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    control_panel/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    models.py</span><br><span class="line">    runserver.py</span><br></pre></td></tr></table></figure></p><p>参阅：<a href="https://www.zhihu.com/question/31748237" target="_blank" rel="noopener">如何理解 Flask 中的蓝本？</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>需求驱动，没有最好的框架，只有适合你的框架。<br>两者都是轻量级<code>web</code>开发框架（相较于<code>Django</code>而言），都具有良好的扩展性并遵循<code>Pythonic</code>设计，非常适合初学者学习与使用。<br><code>Web.py</code>坚持小而美的设计理念。简单直接，学习成本更低，对于新手理解 web 处理流程很有帮助，更适合敏捷开发和定制化，当然也就意味着可能需要自己造更多的轮子。<br>而<code>Flask</code>拥有庞杂的第三方扩展可以参考使用，具备良好的扩展性，遇到问题更好向社区寻求答案。当然，随着开发的深入，可能伴随一系列扩展的了解和学习，会消耗较多时间。但是相比<code>Django</code>这种<code>完美主义者用来赶期限的选择</code>，你不必一开始就学所有的东西（session、ORM、CSRF、Form、Template、Middleware 等），可以自主搭配，渐进开发。<br>所以，对于全新项目，为了后续的可持续迭代和维护，相比<code>Web.py</code>更建议选择<code>Flask</code>。</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><h3 id="框架对比"><a href="#框架对比" class="headerlink" title="框架对比"></a>框架对比</h3><ul><li><a href="https://kite.com/blog/python/flask-vs-django-python" target="_blank" rel="noopener">Flask vs Django</a></li><li><a href="https://www.douban.com/group/topic/29598761/" target="_blank" rel="noopener">Web.py,web2py,django 三者间到底是什么关系？有什么不同呢？- 豆瓣</a></li><li><a href="https://www.zhihu.com/question/20708601" target="_blank" rel="noopener">Flask 框架怎么样，比起 Web.py 有哪些不同？- 知乎</a></li><li><a href="https://stackoverflow.com/questions/5695689/web-py-and-flask" target="_blank" rel="noopener">Web.py-and-flask- StackOverflow</a></li><li><a href="https://www.quora.com/Which-is-better-Flask-vs-web-py-Why" target="_blank" rel="noopener">Which is better: Flask vs Web.py? Why?-Quora</a></li><li><a href="https://www.reddit.com/r/Python/comments/28qr7c/can_anyone_explain_the_differences_between_web2py/" target="_blank" rel="noopener">Can anyone explain the differences between web2py, Django, Flask, etc, and when I should use one or the other and what the benefits and drawbacks of each?-Reddit</a></li></ul><h3 id="Flask学习资源"><a href="#Flask学习资源" class="headerlink" title="Flask学习资源"></a><code>Flask</code>学习资源</h3><ul><li><a href="http://flask.pocoo.org/" target="_blank" rel="noopener">Welcome | Flask (A Python Microframework)</a></li><li><a href="http://docs.jinkan.org/docs/flask/index.html" target="_blank" rel="noopener">Flask 中文文档</a></li><li><a href="https://www.ctolib.com/docs/sfile/head-first-flask/" target="_blank" rel="noopener">Flask Web 开发入门</a></li><li><a href="http://www.pythondoc.com/flask-mega-tutorial/index.html" target="_blank" rel="noopener">欢迎进入 Flask 大型项目教程</a></li><li><a href="https://book.douban.com/subject/26274202/" target="_blank" rel="noopener">Flask Web 开发：基于 Python 的 Web 应用开发实战 -（狗书）</a></li><li><a href="https://book.douban.com/subject/30310340/" target="_blank" rel="noopener">Flask Web 开发实战 -（狼书）</a></li></ul><h3 id="Flask扩展"><a href="#Flask扩展" class="headerlink" title="Flask扩展"></a><code>Flask</code>扩展</h3><ul><li><a href="https://github.com/humiaozuzu/awesome-flask" target="_blank" rel="noopener">Awesome Flask(Flask 资源和插件的精选列表)</a></li><li><a href="http://www.pythondoc.com/" target="_blank" rel="noopener">Flask 文档和主流第三方扩展文档</a></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://www.zhihu.com/question/20711220" target="_blank" rel="noopener">亚伦·斯沃茨 (Aaron Swartz) 是怎么样一个人？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web 开发 </tag>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 中存储 IP 地址应该选用何种数据类型？</title>
      <link href="/blog/2019-05-11/which-mysql-datatype-use-for-store-an-ip-address/"/>
      <url>/blog/2019-05-11/which-mysql-datatype-use-for-store-an-ip-address/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天在项目开发时，遇到需要在数据库中存储 ip 地址，那么应该选用何种数据类型更加高效呢？<br>如果存储的是<code>IPV4</code>地址，可以选择使用<code>INT UNSIGNED</code>，然后借助 <code>MySQL</code> 自带的 <code>INET_ATON()</code> 和  <code>INET_NTOA()</code>来存取数据；<br>如果存储的是<code>IPV6</code>地址，可以选择使用<code>VARBINARY()</code>，然后借助 <code>INET6_ATON()</code>和<code>INET6_NTOA()</code> (<code>MySQL5.6+</code>支持)方法存取数据。</p><a id="more"></a><h2 id="针对IPv4地址"><a href="#针对IPv4地址" class="headerlink" title="针对IPv4地址"></a>针对<code>IPv4</code>地址</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select inet_aton('127.0.0.1');</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| inet_aton('127.0.0.1') |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">|             2130706433 |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">inet_ntoa</span>(<span class="number">2130706433</span>);</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| inet_ntoa(2130706433) |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| 127.0.0.1             |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h3><ul><li><p>存数据</p>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`ip_addresses`</span> (<span class="string">`ip_address`</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="keyword">INET_ATON</span>(<span class="string">'127.0.0.1'</span>));</span><br></pre></td></tr></table></figure></li><li><p>取数据</p>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">INET_NTOA</span>(<span class="string">`ip_address`</span>) <span class="keyword">AS</span> ip</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`ip_addresses`</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a><code>Python</code>实现</h3><p>对于上面的代码，如果我们不想使用内置的<code>MySQL</code>方法，也可以在应用层使用自己封装的方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket, struct</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ip2long</span><span class="params">(ip)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> struct.unpack(<span class="string">"!L"</span>,socket.inet_aton(ip))[<span class="number">0</span>]  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long2ip</span><span class="params">(longip)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> socket.inet_ntoa(struct.pack(<span class="string">'!L'</span>, longip))  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    print(<span class="string">'local ip address to long is %s'</span>%ip2long(<span class="string">'127.0.0.1'</span>))  </span><br><span class="line">    print(<span class="string">'local ip address to long is %s'</span>%ip2long(<span class="string">'255.255.255.255'</span>))  </span><br><span class="line">    print(<span class="string">'local ip address long to ip is %s'</span>%long2ip(<span class="number">2130706433</span>))  </span><br><span class="line">    print(<span class="string">'local ip address long to ip is %s'</span>%long2ip(<span class="number">4294967295</span>))</span><br></pre></td></tr></table></figure><h2 id="针对IPv6地址"><a href="#针对IPv6地址" class="headerlink" title="针对IPv6地址"></a>针对<code>IPv6</code>地址</h2><p>MySQL 提供内置函数<code>inet6_aton()</code>来存储和检索<code>IPv6</code>地址。敲黑板，不要把<code>IPv6</code>地址存储为整数，因为数字格式的<code>IPv6</code>地址需要比<code>UNSIGNED BIGINT</code>更多的字节。所以下面的函数返回<code>VARBINARY(16)</code>数据类型。让我们看一个例子。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select hex(inet6_aton('127.0.0.1'));</span><br><span class="line">+<span class="comment">---------------------------------+</span></span><br><span class="line">| hex(inet6_aton('127.0.0.1'))    |</span><br><span class="line">+<span class="comment">---------------------------------+</span></span><br><span class="line">| 7F000001                        |</span><br><span class="line">+<span class="comment">---------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">hex</span>(<span class="keyword">inet6_aton</span>(<span class="string">'2001:0db8:85a3:0000:0000:8a2e:0370:7334'</span>));</span><br><span class="line">+<span class="comment">---------------------------------------------------------------------------+</span></span><br><span class="line">| hex(inet6_aton('2001:0db8:85a3:0000:0000:8a2e:0370:7334'))                |</span><br><span class="line">+<span class="comment">---------------------------------------------------------------------------+</span></span><br><span class="line">| 20010DB885A3000000008A2E03707334                                          |</span><br><span class="line">+<span class="comment">---------------------------------------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">inet6_ntoa</span>(<span class="keyword">unhex</span>(<span class="string">'20010DB885A3000000008A2E03707334'</span>));</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------+</span></span><br><span class="line">| inet6_ntoa(unhex('20010DB885A3000000008A2E03707334'))                      |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------+</span></span><br><span class="line">| 2001:db8:85a3::8a2e:370:7334                                               |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong></p><p>假设你正在编写查找以<code>ip</code>地址为<code>127.0.0.1</code>连接的用户，可能写出如下的查询语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">inet_ntoa</span>(ipaddress)=<span class="string">'127.0.0.1'</span>;</span><br></pre></td></tr></table></figure><p>请注意，此查询不会使用在<code>ipaddress</code>列上创建的索引，因为我们在<code>SQL</code>执行期间修改了索引列，它也会逐行将整数转换为真实的<code>IP</code>地址。所以要想让索引生效应该：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @ip = <span class="keyword">inet_aton</span>(<span class="string">'127.0.0.1'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> ipaddress = @ip;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> ipaddress = <span class="keyword">inet_aton</span>(<span class="string">'127.0.0.1'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.rathishkumar.in/2017/08/how-to-store-ip-address-in-mysql.html" target="_blank" rel="noopener">How to store IP (internet protocol) address in MySQL?</a></li><li><a href="https://itsolutionstuff.com/post/which-mysql-datatype-use-for-store-an-ip-address" target="_blank" rel="noopener">Which MySQL datatype use for store an IP address?</a></li><li><a href="https://stackoverflow.com/questions/2542011/most-efficient-way-to-store-ip-address-in-mysql" target="_blank" rel="noopener">Most efficient way to store IP Address in MySQL</a></li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/miscellaneous-functions.html#function_inet6-aton" target="_blank" rel="noopener">MySQL doc-function_inet6-aton</a></li><li><a href="https://www.cnblogs.com/gomysql/p/4595621.html" target="_blank" rel="noopener">IP 地址在数据库里面的存储方式</a></li><li><a href="https://www.cnblogs.com/skynet/archive/2011/01/09/1931044.html" target="_blank" rel="noopener">论 IP 地址在数据库中应该用何种形式存储?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何配置 Pycharm 使用远程的 Flask 虚拟开发环境？</title>
      <link href="/blog/2019-05-06/pycharm-with-remote-flask-venv/"/>
      <url>/blog/2019-05-06/pycharm-with-remote-flask-venv/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>学习<code>Flask</code>开发的时候，因为主机是<code>Windows</code>环境，而日常跑服务的是<code>Linux</code>环境，所以需要通过配置<code>pycharm</code>使之使用远端的虚拟环境。</p><a id="more"></a><h2 id="创建虚拟机Flask环境"><a href="#创建虚拟机Flask环境" class="headerlink" title="创建虚拟机Flask环境"></a>创建虚拟机<code>Flask</code>环境</h2><p>略</p><p>此处在网上可以找到很多写好的教程，不需要我再次叠床架屋了。</p><h2 id="配置Pycharm环境"><a href="#配置Pycharm环境" class="headerlink" title="配置Pycharm环境"></a>配置<code>Pycharm</code>环境</h2><p>打开 Pycharm 的 setting 对话框，按照如下配置  </p><p><img src="/images/snipaste_20190506_141224.jpg" alt="setting_start"></p><p>依次输入真实远端信息之后，点击下一步，直到出现下方对话框</p><p><img src="/images/snipaste_20190506_142141.jpg" alt="setting_end"></p><p>依次修改将要使用的解释器和主机与远端需要保持同步的目录；</p><p><img src="/images/snipaste_20190506_143428.jpg" alt="setting_flask"></p><p>如图设置之后运行，<code>Run</code>出现如下结果<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FLASK_APP = app</span><br><span class="line">FLASK_ENV = development</span><br><span class="line">FLASK_DEBUG = 1</span><br><span class="line">In folder D:/MYcode/flk</span><br><span class="line">ssh://root@192.168.116.21:22/home/imoyao/envs/flk/bin/python -u -m flask run --host=0.0.0.0</span><br><span class="line"> * Serving Flask app "app" (lazy loading)</span><br><span class="line"> * Environment: development</span><br><span class="line"> * Debug mode: on</span><br><span class="line"> * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line"> * Restarting with stat</span><br><span class="line"> * Debugger is active!</span><br><span class="line"> * Debugger PIN: 820-491-228</span><br></pre></td></tr></table></figure></p><p>之后在本机访问虚拟机<code>ip</code>，比如本例中的<code>192.168.116.21:5000</code>，即可进入<code>app</code>首页。</p><h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><p>在配置好上述选项之后，运行可能会提示 <code>NoAppException: Could not import &quot;app&quot;.</code>。这个问题暂时不知道是什么原因引起，可能是<code>Pycharm</code>识别路径有误导致，暂时没有找到很好的解决办法。大家可以参考下图尝试配置（递归手动设置目录，可能有用）。</p><p><img src="/images/snipaste_20190507_133810.jpg" alt="can&#39;t_import_app"></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>今天突然出现不能访问的问题，使用<code>netstat nap|grep 5000(flask 运行端口)</code>查看端口状态：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcp        0      0 0.0.0.0:5000            0.0.0.0:*               LISTEN      8195/python</span><br></pre></td></tr></table></figure></p><p>说明端口正常开放，怀疑是防火墙的原因<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure></p><p>关闭之后可以正常访问，确认是其问题。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=5000/tcp --permanent</span><br><span class="line">Warning: ALREADY_ENABLED: 5000:tcp</span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>重启防火墙之后可以正常访问：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 ~]<span class="comment"># systemctl stop firewalld</span></span><br><span class="line"></span><br><span class="line">[root@172 ~]<span class="comment"># firewall-cmd --reload</span></span><br><span class="line">FirewallD is not running</span><br><span class="line"></span><br><span class="line">[root@172 ~]<span class="comment"># firewall-cmd --state</span></span><br><span class="line">running</span><br></pre></td></tr></table></figure></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jetbrains.com/help/pycharm/run-debug-configuration-flask-server.html" target="_blank" rel="noopener">配置<code>flask</code>服务进行调试</a></li><li><a href="https://www.jetbrains.com/help/pycharm/configuring-python-interpreter.html" target="_blank" rel="noopener">配置<code>Python</code>解释器</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> HOWTO </tag>
            
            <tag> PyCharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 传值还是传引用？| 通过对象引用传递</title>
      <link href="/blog/2019-04-13/python-pass-by-object-reference/"/>
      <url>/blog/2019-04-13/python-pass-by-object-reference/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>哈姆雷特不是莎士比亚写的;它只是由一个名叫莎士比亚的人写的。<br>Python 通过对象引用传递。</p><a id="more"></a><p>本文译自 <a href="https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/" target="_blank" rel="noopener">Is Python pass-by-reference or pass-by-value?</a></p><blockquote><p>“假设我对 Fat 说，或 Kevin 对 Fat 说，“你没有经历过上帝。你只不过经历了一些与上帝的品质、方面、性质、力量、智慧和善良有关的事情。”这就像是关于德国人讲的一个双重抽象倾向的笑话；德国英国文学权威宣称，“哈姆雷特不是莎士比亚写的;它只是由一个名叫莎士比亚的人写的。”在英语语境中，这句话的区别只是口头的，没有实际意义，尽管德语中这种表达存在差异（这解释了德国思想的一些奇怪特征）。”<br>  </p><p align="right"> –Valis，p71（Book-of-the-Month-Club Edition）</p><p></p></blockquote><p>Philip K. Dick 并不以其轻松或易懂的散文而闻名。绝大多数角色都很高。就像，真的，真的，真的很高。然而，在 Valis 的上述引文（1981 年出版）中，他对臭名昭着的<code>Python</code>参数传递范式给出了非常有远见的解释。Plus ça change, plus c’est omnomnomnom drugs.</p><p>在编程语言中参数传递的两种最广为人知且易于理解的方法是按引用传递( pass-by-reference )和按值传递 ( pass-by-value )。不幸的是，<code>Python</code>是“传递对象引用”( pass-by-object-reference )，经常说：</p><p>“对象引用按值传递。”(Object references are passed by value.)</p><p>当我第一次看到这个沾沾自喜和过于精辟的定义时，我想捶人。在从手上取下玻璃碎片并被护送出脱衣舞俱乐部后，<del>我意识到所有 3 种范例都可以理解它们如何导致以下 2 个功能的表现：</del></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reassign</span><span class="params">(alist)</span>:</span></span><br><span class="line">    alist = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(alist)</span>:</span></span><br><span class="line">    alist.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">0</span>]</span><br><span class="line">reassign(alist)</span><br><span class="line">append(alist)</span><br></pre></td></tr></table></figure><p>让我们来一探究竟。</p><h2 id="变量不是对象"><a href="#变量不是对象" class="headerlink" title="变量不是对象"></a>变量不是对象</h2><p>“哈姆雷特不是莎士比亚写的;它只是由一个名叫莎士比亚的人写的。” Python 和 PKD（ Philip K. Dick）都在一个东西的本质与我们用来指代那个东西的标签之间做出了至关重要的区分。 “这个名叫莎士比亚的男人”是一个具体的人。 而“莎士比亚”只是一个名字。如果我们这样做：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br></pre></td></tr></table></figure></p><p><code>[]</code>是一个空列表。 a 是指向空列表的变量，但其本身并不是空列表。我画图并将变量称为包含对象的“盒子”;但无论如何你构想它，这种差异是关键。<br><img src="https://robertheaton.com/images/Intro.jpg" alt="Pass-by-reference"></p><h2 id="通过引用传递"><a href="#通过引用传递" class="headerlink" title="通过引用传递"></a>通过引用传递</h2><p>在 pass-by-reference 中，box（变量）直接传递给函数，其内容（由变量表示的对象）隐性地随之而来。在函数上下文中，参数本质上是调用者传入的变量的完整别名。它们都是完全相同的盒子，因此也指向内存中完全相同的对象。<br><img src="https://robertheaton.com/images/PBRIntro.jpg" alt></p><p>因此，函数对变量或它所代表的对象所做的任何操作都将对调用者可见。例如，该函数可以完全更改变量的内容，并将其指向完全不同的对象：</p><p><img src="https://robertheaton.com/images/PBRReassign.jpg" alt></p><p>该函数还可以在不重新分配对象的情况下操作对象，效果相同：<br><img src="https://robertheaton.com/images/PBRAppend.jpg" alt></p><p>重申一下，在<code>pass-by-reference</code>中，函数和调用者都使用完全相同的变量和对象。</p><h2 id="通过值传递"><a href="#通过值传递" class="headerlink" title="通过值传递"></a>通过值传递</h2><p>在<code>pass-by-value</code>中，函数接收调用者传递给它的参数对象的副本，并在内存中开辟新的空间保存。</p><p><img src="https://robertheaton.com/images/PBVIntro.jpg" alt></p><p>然后，该函数有效地提供其自己的盒子以将值放入，并且函数和调用者引用的变量或对象之间不再存在任何关系。这些对象碰巧具有相同的值，但它们完全是分开的，一个对象不会影响到另一个。如果我们再次尝试重新分配：</p><p><img src="https://robertheaton.com/images/PBVReassign.jpg" alt></p><p>在函数之外，没有任何反应。同理：</p><p><img src="https://robertheaton.com/images/PBVAppend.jpg" alt></p><p>调用者上下文中的变量和对象的副本是完全隔离的。</p><h2 id="通过对象引用传递"><a href="#通过对象引用传递" class="headerlink" title="通过对象引用传递"></a>通过对象引用传递</h2><p>在<code>Python</code>是不同的。众所周知，在<code>Python</code>中，“对象引用按值传递”（<code>Object references are passed by value</code>）。</p><p>函数接收对（并将访问）内存中与调用者使用的相同对象的引用。但是，它不会收到调用者正在存储此对象的盒子;在<code>pass-by-value</code>中，函数提供自己的筐并为自己创建一个新变量。让我们再次执行<code>append</code>：</p><p><img src="https://robertheaton.com/images/PBORAppend.jpg" alt></p><p>函数和调用者都引用内存中的同一个对象，所以当<code>append</code>函数向列表中添加一个额外的项时，我们也会在调用者中看到这个！它们是同一个东西的不同名称;包含相同对象的不同筐。这意味着是通过值传递对象引用的——函数和调用者在内存中使用相同的对象，但是通过不同的变量访问。这意味着同一个对象被存储在多个不同的筐中，而这种隐喻会被打破。<del>假定它是量子或其他东西。</del></p><p>但关键是它们真的是不同的名字和不同的盒子。在<code>pass-by-reference</code>中，它们是相同的盒子。当你试图重新分配一个变量，并将一些不同的东西放入函数的盒子中时，你也将它放入调用者的盒子中，因为它们是同一个盒子。但是，在<code>pass-by-object-reference</code>中：</p><p><img src="https://robertheaton.com/images/PBORReassign.jpg" alt></p><p>调用者不在乎你是否重新分配方法的盒子。不同的盒子，相同的内容。</p><p>现在我们看看菲利普·K·迪克试图告诉我们的事情。名字和人是不同的东西。变量和对象是不同的东西。有了这些知识，你或许可以开始推断当你做这样的事情时会发生什么</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listA = [0]</span><br><span class="line">listB = listA</span><br><span class="line">listB.append(1)</span><br><span class="line">print listA</span><br></pre></td></tr></table></figure><p>你可能还想了解这些概念与可变和不可变类型之间的有趣交互。但这些是另一回事了。现在，如果你能原谅我，我要去读《Dororoids Dream Of Electric Sheep？》了。 - 我对元编程有点生疏。</p><hr><p><a href="https://eev.ee/blog/2012/05/23/python-faq-passing/" target="_blank" rel="noopener">Does Python pass by reference or value?</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://foobarnbaz.com/2012/07/08/understanding-python-variables/" target="_blank" rel="noopener">http://foobarnbaz.com/2012/07/08/understanding-python-variables/</a> </li><li><a href="http://javadude.com/articles/passbyvalue.htm" target="_blank" rel="noopener">http://javadude.com/articles/passbyvalue.htm</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下如何安装 Redis？</title>
      <link href="/blog/2019-04-11/how-to-install-Redis-on-Linux/"/>
      <url>/blog/2019-04-11/how-to-install-Redis-on-Linux/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><code>Redis</code>是一款高性能的<code>key-value</code>数据库，本文主要记录如何在<code>Linux</code>系统上进行安装，以及为<code>Python</code>开发安装对应的<code>redis</code>模块。</p><a id="more"></a><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><ul><li><p><code>Linux</code>版本</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ubuntu 18.04 LTS &amp;&amp; NeoKylin 3.2</span><br></pre></td></tr></table></figure></li><li><p><code>Python</code>版本</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Python 2.7.15rc1 &amp;&amp; Python 2.6.6</span><br></pre></td></tr></table></figure></li><li><p><code>Redis</code>版本</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-5.0.4</span><br></pre></td></tr></table></figure></li><li><p><code>redis-py</code>版本</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-3.2.1 &amp;&amp; redis-2.10.6</span><br></pre></td></tr></table></figure></li></ul><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载地址：<code>http://redis.io/download</code>，下载最新稳定版本源码。</p><p>本文使用的版本为 <code>redis-5.0.4</code>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><ol><li><p>解压缩</p><p> 首先要解压<code>Redis</code>压缩包。进入压缩包下载的路径，执行：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar xzf redis-5.0.4.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>使用<code>GCC</code>编译源码</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis-5.0.4</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>安装<code>Redis</code></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>验证</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@local:~/temp# redis-server -v</span><br><span class="line">Redis server v=5.0.4 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=3dcf53963ddc396a</span><br><span class="line">root@local:~/temp# whereis redis-server</span><br><span class="line">redis-server: /usr/local/bin/redis-server</span><br></pre></td></tr></table></figure></li></ol><p>至此，<code>Redis</code>安装完成。</p><h3 id="CentOs"><a href="#CentOs" class="headerlink" title="CentOs"></a>CentOs</h3><ol><li><p>编译安装</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p> 此时报错</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CC adlist.o</span><br><span class="line">/bin/sh: cc: command not found</span><br><span class="line">make[1]: *** [adlist.o] Error 127</span><br><span class="line">make[1]: Leaving directory `/root/temp/redis-5.0.4/src'</span><br><span class="line">make: *** [all] Error 2</span><br></pre></td></tr></table></figure></li><li><p>安装 gcc</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install gcc -y</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>重新 make</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p> 此时报错</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">In file included from adlist.c:34:</span><br><span class="line">zmalloc.h:50:31: error: jemalloc/jemalloc.h: No such file or directory</span><br><span class="line">zmalloc.h:55:2: error: #error "Newer version of jemalloc required"</span><br><span class="line">make[1]: *** [adlist.o] Error 1</span><br><span class="line">make[1]: Leaving directory `/root/temp/redis-5.0.4/src'</span><br><span class="line">make: *** [all] Error 2</span><br></pre></td></tr></table></figure><p> 在构建<code>Redis</code>时选择非默认内存分配器是通过设置<code>MALLOC</code>环境变量完成的， 默认情况下 Redis 是使用<code>malloc</code>为<code>libc</code>编译和链接的。<br> 而<code>libc</code>并不是<code>Linux</code>上默认的分配器，默认的是 <code>jemalloc</code>, 因为 <code>jemalloc</code> 被证明比<code>libc</code>有更少的碎片问题（<code>fragmentation problems</code>）。<br> 但是如果你没有<code>jemalloc</code> 而只有<code>libc</code> 当然 <code>make</code> 出错。 所以有两种解决办法：</p></li></ol><ul><li><p><del>方法一</del>（不推荐）</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make MALLOC=libc</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p>方法二</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd deps/</span><br><span class="line">make hiredis jemalloc linenoise lua geohash-int</span><br></pre></td></tr></table></figure></li></ul><p>原因参见： <a href="http://www.jb51.net/article/100575.htm" target="_blank" rel="noopener">浅谈 redis 采用不同内存分配器 tcmalloc 和 jemalloc</a></p><blockquote><p>对于<code>tcmalloc</code>，<code>jemalloc</code>和<code>libc</code>对应的三个内存分配器。其性能和碎片率如何呢？<br>下面是一个简单测试结果，使用<code>Redis</code>自带的<code>redis-benchmark</code>写入等量数据进行测试，数据摘自采用不同分配器时<code>Redis info</code>信息。<br>我们可以看到，采用<code>tcmalloc</code>时碎片率是最低的，为<code>1.01</code>，<code>jemalloc</code>为<code>1.02</code>，而<code>libc</code>的分配器碎片率为<code>1.31</code>，</p></blockquote><ol start="4"><li><p>编译安装</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make $$ make install</span><br></pre></td></tr></table></figure></li><li><p>验证</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server -v</span><br><span class="line">Redis server v=5.0.4 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=b139020f90f1d493</span><br><span class="line">whereis redis-server</span><br><span class="line">redis-server: /usr/local/bin/redis-server</span><br></pre></td></tr></table></figure></li></ol><p>至此，<code>Redis</code>安装完成。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>通过配置文件，设置<code>Redis</code>服务开机自启动。</p><ol><li><p>设置自启动配置文件</p><ol><li><p>切换目录</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd utils/</span><br></pre></td></tr></table></figure></li><li><p>复制脚本文件</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp redis_init_script /etc/init.d/redisd</span><br></pre></td></tr></table></figure><p> 将<code>redis_init_script</code>文件重新命名为<code>redisd</code>，作为系统启动服务名（以<code>d</code>结尾表示是自启动服务，约定俗成）。</p></li><li><p>修改配置</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/init.d/redisd</span><br></pre></td></tr></table></figure></li><li><p>修改<code>redisd</code>文件，注意要在文件头部加上两句注释来设定该服务的运行级别</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chkconfig:   2345 90 10</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>设置<code>Redis</code>控制脚本的配置文件</p><ol><li><p>切换目录</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd -</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure></li><li><p>在<code>redis</code>安装目录下，找到<code>redis.conf</code>文件</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p> 如下</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">00-RELEASENOTES  INSTALL     runtest           tests</span><br><span class="line">BUGS             Makefile    runtest-cluster   utils</span><br><span class="line">CONTRIBUTING     MANIFESTO   runtest-sentinel</span><br><span class="line">COPYING          README.md   sentinel.conf</span><br><span class="line">deps             redis.conf  src</span><br></pre></td></tr></table></figure></li><li><p>复制配置文件并重命名</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp redis.conf /etc/redis/6379.conf</span><br></pre></td></tr></table></figure></li><li><p>编辑<code>Redis</code>配置文件</p><ol><li><p>设置<code>daemonize</code>为<code>yes</code>，使服务可以后台运行：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nu:136</span></span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure></li><li><p>设置<code>log</code>文件路径：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nu:171</span></span><br><span class="line">logfile /var/log/redis/redis-server.log</span><br></pre></td></tr></table></figure></li><li><p>设置持久化文件存放路径：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nu:263</span></span><br><span class="line">dir /var/lib/redis</span><br></pre></td></tr></table></figure></li></ol></li><li><p>保存退出，并创建相应的目录结构：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /var/log/redis</span><br><span class="line">touch /var/log/redis/redis-server.log</span><br><span class="line">mkdir /var/lib/redis</span><br></pre></td></tr></table></figure></li></ol></li><li><p>设置开机自启</p><h4 id="Ubuntu-1"><a href="#Ubuntu-1" class="headerlink" title="Ubuntu"></a>Ubuntu</h4> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 赋权</span></span><br><span class="line">chmod +x /etc/init.d/redisd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新系统启动项</span></span><br><span class="line">update-rc.d redisd defaults</span><br></pre></td></tr></table></figure><h4 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h4> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master init.d]# chmod +x ./redisd</span><br><span class="line">[root@master init.d]# chkconfig redisd on</span><br></pre></td></tr></table></figure></li></ol><h2 id="附：常用redis管理命令"><a href="#附：常用redis管理命令" class="headerlink" title="附：常用redis管理命令"></a>附：常用<code>redis</code>管理命令</h2><ul><li>启动<code>Redis</code>服务：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service redisd start</span><br><span class="line">[root@master init.d]# service redisd start</span><br><span class="line">Starting Redis server...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证</span></span><br><span class="line">[root@master init.d]# ps aux|grep redis|grep -v grep</span><br><span class="line">root      6728  0.1  0.4  55572  9820 ?        Ssl  11:03   0:00 /usr/local/bin/redis-server 127.0.0.1:6379</span><br></pre></td></tr></table></figure><ul><li>关闭服务：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master init.d]# service redisd stop</span><br><span class="line">Stopping ...</span><br><span class="line">Redis stopped</span><br><span class="line">[root@master init.d]# ps aux|grep redis|grep -v grep</span><br></pre></td></tr></table></figure><ul><li>重启服务：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service redisd restart</span><br></pre></td></tr></table></figure><ul><li>在控制台中登录<code>redis</code>客户端：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master init.d]# redis-cli</span><br><span class="line"># 测试redis连通性</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br></pre></td></tr></table></figure><h2 id="安装提供Python支持"><a href="#安装提供Python支持" class="headerlink" title="安装提供Python支持"></a>安装提供<code>Python</code>支持</h2><h3 id="pip-安装"><a href="#pip-安装" class="headerlink" title="pip 安装"></a>pip 安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install redis</span><br></pre></td></tr></table></figure><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p>去<code>https://pypi.org/project/redis/</code>下载源码，<code>Ubuntu</code>上使用最新版本<code>redis 3.2.1</code></p><ol><li><p>解压</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzvf redis-3.2.1.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>切换目录</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis-3.2.1</span><br></pre></td></tr></table></figure></li><li><p>安装</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></li><li><p>验证</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@local:~/temp/redis-3.2.1# python</span><br><span class="line">Python 2.7.15rc1 (default, Apr 15 2018, 21:51:34) </span><br><span class="line">[GCC 7.3.0] on linux2</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import redis</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import redis</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; r = redis.Redis(host=<span class="string">'localhost'</span>, port=6379, db=0)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; ret = r.get(<span class="string">'hello'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span> ret</span></span><br><span class="line">world</span><br></pre></td></tr></table></figure></li></ol><hr><p><strong>小插曲</strong></p><p>关于 redis-py 的 Python 低版本支持</p><p>在<code>CentOS</code>上安装<code>redis-3.2.1</code>的时候由于<code>python</code>版本较低（<code>2.6.6</code>）出现以下问题<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master redis-3.2.1]# python setup.py install</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "setup.py", line 4, in &lt;module&gt;</span><br><span class="line">    from setuptools import setup</span><br><span class="line">ImportError: No module named setuptools</span><br></pre></td></tr></table></figure></p><p>安装<code>setuptools-0.6c9</code>之后执行<code>python setup.py install</code>报错：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "setup.py", line 7, in &lt;module&gt;</span><br><span class="line">    from redis import __version__</span><br><span class="line">  File "/root/temp/pyredis-3.2.1/redis/__init__.py", line 1, in &lt;module&gt;</span><br><span class="line">    from redis.client import Redis, StrictRedis</span><br><span class="line">  File "/root/temp/pyredis-3.2.1/redis/client.py", line 3046</span><br><span class="line">    return &#123;decode(encode(k)): v for k, v in iteritems(data)&#125;</span><br><span class="line">                                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>去官网查看，发现最新版版本支持为：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Meta</span><br><span class="line">……</span><br><span class="line"> Tags: Redis, key-value store</span><br><span class="line"></span><br><span class="line">Requires: Python &gt;=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*</span><br></pre></td></tr></table></figure></p><p>以及</p><blockquote><p>Python Version Support<br>redis-py 3.0 now supports Python 2.7 and Python 3.4+. Python 2.6 and 3.3 support has been dropped.</p></blockquote><p>最后安装较低版本（<code>redis-2.10.6</code>）成功，步骤同上，不再赘述。</p><p>读者可以从 <a href="https://pypi.org/project/redis/#history" target="_blank" rel="noopener">这里</a> 获取历史版本：<code>https://pypi.org/project/redis/#history</code></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://redis.io/topics/quickstart" target="_blank" rel="noopener">Redis Quick Start</a></li><li><a href="https://blog.csdn.net/softwave/article/details/53838194" target="_blank" rel="noopener">Ubuntu 安装 Redis 并设置为开机自启动服务</a></li><li><a href="https://www.cnblogs.com/cnkai/p/7642787.html" target="_blank" rel="noopener">Python 操作 Redis 数据库</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> HOWTO </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何把当前改动追加到某次指定 commit 上（非上次）</title>
      <link href="/blog/2019-03-05/how-to-append-the-current-change-to-specified-commit/"/>
      <url>/blog/2019-03-05/how-to-append-the-current-change-to-specified-commit/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>注意：本例中使用<code>Gerrit</code>进行演示。</p><ol start="0"><li><p>暂存目前修改的代码</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash</span><br><span class="line">git stash list <span class="comment"># 可以验证暂存是否成功</span></span><br></pre></td></tr></table></figure></li><li><p>查找到需要指定的<code>commit</code>的编号；</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p> <img src="/images/snipaste_20190305_123504.jpg" alt="rebase"> </p></li><li><p>找到<code>git rebase</code>编号，即要修改的<code>commit</code>之前那个<code>commit</code>；</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase --interactive a6f372877d26xxx0690aedf6dc6b6e7c</span><br></pre></td></tr></table></figure><p> <img src="/images/InsertPic_C032-11-05-09-52-53.jpg" alt="rebase">   </p></li><li>找到要更改的<code>commit</code>, 将行首的<code>pick</code>更改为<code>edit</code>, 保存退出；<br> <img src="/images/InsertPic_36EE-11-05-09-52-53.jpg" alt="pick2edit">    </li><li><p>本地修改需要修改的代码</p></li><li><p>恢复暂存的修改</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p> <strong>注意</strong>：如果此时有冲突，需要自己手动解决冲突</p></li><li><p>解决冲突后，添加修改文件</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add xxx    <span class="comment"># 文件名称</span></span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure></li><li><p>回退到当前状态；</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p> <img src="/images/Catch-11-05-09-52-53.jpg" alt="pick2edit"><br> <strong>注意</strong>：如果<code>rebase</code>版本较多，可能需要多次重复上述步骤，且每<code>rebase</code>一步，可能都要解决与其他组员<code>commit</code>的冲突；</p></li><li><p>rebase 到 master 之后，push 当前版本到远程</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin 0d163929c240xxx745b520d07b854c207 ① :refs/changes/8xxx4 ②</span><br></pre></td></tr></table></figure><p> ①：此处为你自己需要<code>amend</code>的<code>commit</code>版本号；<br> ②：此处为远端你的<code>change</code>的编号，如果远端版本已经<code>closed</code>，则无法进行<code>amend</code>，只能 <code>git reset</code>；</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>git</code>非常智能化，每一次操作应该根据提示进行问题分析、逐步操作则可顺利达到预期效果。</p>]]></content>
      
      
      <categories>
          
          <category> 工作记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何获取 Ztree 的所有叶子节点？</title>
      <link href="/blog/2019-01-30/how-to-get-leaf-nodes-of-Ztree/"/>
      <url>/blog/2019-01-30/how-to-get-leaf-nodes-of-Ztree/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>使用<code>Ztree</code>时，<code>treeNode.children</code>只能获取到子节点，该如何拿到节点的叶子节点呢？</p><a id="more"></a><h2 id="创建初始化设置"><a href="#创建初始化设置" class="headerlink" title="创建初始化设置"></a>创建初始化设置</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setting = &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        simpleData: &#123;</span><br><span class="line">            enable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    callback: &#123;</span><br><span class="line">        onCheck:onCheck,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="创建点击响应事件"><a href="#创建点击响应事件" class="headerlink" title="创建点击响应事件"></a>创建点击响应事件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onCheck</span>(<span class="params">event, treeId, treeNode, clickFlag</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> treeObj = $(ELT).fn.zTree.getZTreeObj(<span class="string">"datarecdirs"</span>);</span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">        str = getAllChildNodes(treeNode,str);</span><br><span class="line">        <span class="comment">// // 加上被选择节点自身</span></span><br><span class="line">        <span class="comment">// str = str + ',' + treeNode.id;</span></span><br><span class="line">        <span class="comment">// 去掉最前面的逗号</span></span><br><span class="line">        <span class="keyword">var</span> ids = str.substring(<span class="number">1</span>, str.length);</span><br><span class="line">        <span class="comment">// 得到所有节点ID 的数组</span></span><br><span class="line">        <span class="keyword">var</span> idsArray = ids.split(<span class="string">','</span>);</span><br><span class="line">        <span class="comment">// 过滤掉序列中的空元素 [1,2,'3',"", ''] &gt;&gt;&gt; [1,2,'3']   (javascript 1.6 and above)</span></span><br><span class="line">        <span class="keyword">var</span> filterArr = idsArray.filter(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;<span class="keyword">return</span> n&#125;);       </span><br><span class="line">        <span class="comment">// 得到节点总数量</span></span><br><span class="line">        <span class="keyword">var</span> leafNodesLen = filterArr.length;</span><br><span class="line">        <span class="keyword">if</span>(filterArr)&#123;</span><br><span class="line">            <span class="keyword">var</span> nodeChecked = treeNode.checked;</span><br><span class="line">            <span class="keyword">if</span>(nodeChecked)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; leafNodesLen; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> idVal = filterArr[i];</span><br><span class="line">                    <span class="keyword">var</span> node = treeObj.getNodeByParam(<span class="string">"id"</span>, idVal, <span class="literal">null</span>);</span><br><span class="line">                    treeObj.setChkDisabled(node,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; leafNodesLen; j++) &#123;</span><br><span class="line">                    idVal = filterArr[j];</span><br><span class="line">                    <span class="comment">// 按照id获取节点，see:https://www.oschina.net/question/222309_131001</span></span><br><span class="line">                    node = treeObj.getNodeByParam(<span class="string">"id"</span>, idVal, <span class="literal">null</span>);       <span class="comment">// 注意：此处不可使用getNodeByTId()方法</span></span><br><span class="line">                    treeObj.setChkDisabled(node,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>);  <span class="comment">//取消禁用时，影响到子节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> nodes = treeObj.getCheckedNodes();</span><br><span class="line">                <span class="built_in">console</span>.log(nodes);</span><br><span class="line">                <span class="keyword">if</span> (nodes.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">var</span> c=<span class="number">0</span>;c&lt;nodes.length;c++)&#123;</span><br><span class="line">                        treeObj.checkNode(nodes[c],<span class="literal">false</span>,<span class="literal">true</span>);     <span class="comment">//注意，此处不可使用cancelSelectedNode()</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 递归，获取所有子节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAllChildNodes</span>(<span class="params">treeNode,result</span>)</span>&#123;     <span class="comment">// 获取节点的所有叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (treeNode.isParent) &#123;</span><br><span class="line">        <span class="keyword">var</span> childrenNodes = treeNode.children;</span><br><span class="line">        <span class="keyword">if</span> (childrenNodes) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; childrenNodes.length; i++) &#123;</span><br><span class="line">                result += <span class="string">','</span> + childrenNodes[i].id;</span><br><span class="line">                result = getAllChildNodes(childrenNodes[i], result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span class="label label-danger">注意</span><blockquote><p>zTree 里严格区分了选中和勾选这两个概念，选中是指节点被选择背景颜色有变化，因此 cancelSelectedNode()只是把你选择的节点，变成不选择状态，也就是节点的背景色发生变化。<br>而勾选是指节点的勾选框被选中，你要将节点的勾选状态由勾选变为不勾选，就不能使用 cancelSelectedNode()方法，只能使用 checknode()方法！</p></blockquote><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><ul><li><a href="https://blog.csdn.net/qq_15071263/article/details/82797734" target="_blank" rel="noopener">zTree 插件 - 获取当前选择节点下的全部子节点</a> </li><li><a href="https://tieba.baidu.com/p/4157358359?red_tag=3393089686" target="_blank" rel="noopener">为什么 cancelSelectedNode()取消不了节点的选中状态？</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zTree </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次 MySQL 错误 —— mysqld-dead-but-subsys-locked</title>
      <link href="/blog/2019-01-25/mysqld-dead-but-subsys-locked/"/>
      <url>/blog/2019-01-25/mysqld-dead-but-subsys-locked/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>记一次<code>MySQL</code>服务出错排查过程。</p><a id="more"></a><p>今天登录管理系统的时候输入账户信息没有反应，后台查看系统日志发现报错信息：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span></span></span><br><span class="line">tailf /var/log/ODSP.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> out(部分有用信息)</span></span><br><span class="line">2019-01-25 11:30:07 database [line:263]: Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2)</span><br></pre></td></tr></table></figure></p><h2 id="查看MySQL服务状态"><a href="#查看MySQL服务状态" class="headerlink" title="查看MySQL服务状态"></a>查看<code>MySQL</code>服务状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span></span></span><br><span class="line">/etc/init.d/mysqld status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> out</span></span><br><span class="line">mysqld dead but subsys locked</span><br></pre></td></tr></table></figure><h2 id="查看MySQL的log信息"><a href="#查看MySQL的log信息" class="headerlink" title="查看MySQL的log信息"></a>查看<code>MySQL</code>的<code>log</code>信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span></span></span><br><span class="line">tailf /var/log/mysqld.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> out（截取部分有用信息）</span></span><br><span class="line">700101 00:28:38 mysqld_safe mysqld from pid file /var/run/mysqld/mysqld.pid ended</span><br><span class="line">700101 00:28:42 mysqld_safe Starting mysqld daemon with databases from /secbox/var/db</span><br><span class="line">700101  0:28:42 [ERROR] This MySQL server doesn't support dates later then 2038</span><br><span class="line">700101  0:28:42 [ERROR] Aborting</span><br></pre></td></tr></table></figure><h2 id="查看系统时间"><a href="#查看系统时间" class="headerlink" title="查看系统时间"></a>查看系统时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master digitools]# date</span><br><span class="line">Wed Jan  1 00:31:52 CST 2070</span><br></pre></td></tr></table></figure><h2 id="重新设置系统时间"><a href="#重新设置系统时间" class="headerlink" title="重新设置系统时间"></a>重新设置系统时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master digitools]# date -s "20190125 11:28:50"</span><br><span class="line">Fri Jan 25 11:28:50 CST 2019</span><br></pre></td></tr></table></figure><h2 id="重新启动MySQL服务"><a href="#重新启动MySQL服务" class="headerlink" title="重新启动MySQL服务"></a>重新启动<code>MySQL</code>服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master digitools]# /etc/init.d/mysqld status</span><br><span class="line">mysqld dead but subsys locked</span><br><span class="line"></span><br><span class="line">[root@master digitools]# /etc/init.d/mysqld stop</span><br><span class="line">Stopping mysqld:                                           [  OK  ]</span><br><span class="line">[root@master digitools]# /etc/init.d/mysqld start</span><br><span class="line">Starting mysqld:                                           [  OK  ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面两步命令也可以直接合并为执行 `/etc/init.d/mysqld restart`</span></span><br><span class="line">[root@master digitools]# /etc/init.d/mysqld status</span><br><span class="line">mysqld (pid  19402) is running...</span><br></pre></td></tr></table></figure><h2 id="日志恢复正常"><a href="#日志恢复正常" class="headerlink" title="日志恢复正常"></a>日志恢复正常</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">190125 11:30:10  InnoDB: Initializing buffer pool, size = 8.0M</span><br><span class="line">190125 11:30:10  InnoDB: Completed initialization of buffer pool</span><br><span class="line">190125 11:30:10  InnoDB: Started; log sequence number 0 398010</span><br><span class="line">190125 11:30:10 [Note] Event Scheduler: Loaded 0 events</span><br><span class="line">190125 11:30:10 [Note] /usr/libexec/mysqld: ready for connections.</span><br><span class="line">Version: '5.1.71'  socket: '/var/lib/mysql/mysql.sock'  port: 3306  Source distribution</span><br></pre></td></tr></table></figure><p>至此，数据库异常问题修复，前台登录系统恢复正常。</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><ul><li><a href="https://en.wikipedia.org/wiki/Year_2038_problem" target="_blank" rel="noopener">Year 2038 problem</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pip 小老弟，你怎么肥四？</title>
      <link href="/blog/2018-09-21/get-some-trouble-with-pip/"/>
      <url>/blog/2018-09-21/get-some-trouble-with-pip/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天用<code>pip</code>的时候突然不能正常使用，在这里简单记录一下。<br><a id="more"></a></p><h2 id="提示pip版本不对"><a href="#提示pip版本不对" class="headerlink" title="提示pip版本不对"></a>提示<code>pip</code>版本不对</h2><h3 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You are using pip version 9.0.3, however version 18.0.1 is available.</span><br><span class="line">You should consider upgrading via the &apos;python -m pip install --upgrade pip&apos; command.</span><br></pre></td></tr></table></figure><h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h3><p>去<a href="https://pypi.org/project/pip/" target="_blank" rel="noopener">官网</a>下载最新版的包，直接解压安装即可；</p><h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><p><a href="https://blog.csdn.net/XavierDarkness/article/details/81234066" target="_blank" rel="noopener">Python2.7 自带的 pip9.0 升级到 pip18.0</a></p><h2 id="明确已经安装pip，但是系统提示找不到pip"><a href="#明确已经安装pip，但是系统提示找不到pip" class="headerlink" title="明确已经安装pip，但是系统提示找不到pip"></a>明确已经安装<code>pip</code>，但是系统提示找不到<code>pip</code></h2><h3 id="错误提示-1"><a href="#错误提示-1" class="headerlink" title="错误提示"></a>错误提示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-bash: /home/imoyao/.local/bin/pip: No such file or directory</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.which pip </span><br><span class="line">/usr/local/bin/pip</span><br><span class="line"></span><br><span class="line">2.pip </span><br><span class="line">-su: /usr/bin/pip: No such file or directory</span><br><span class="line"></span><br><span class="line">3.type pip </span><br><span class="line">pip is hashed (/usr/bin/pip) </span><br><span class="line">So pip is definintely in /usr/local/bin/pip but it is been cached as in /usr/bin/pip, thanks to the Stackoverflow question, the solution is very simple:</span><br><span class="line"></span><br><span class="line">4.hash -r </span><br><span class="line">When the cache is clear, pip is working again.</span><br></pre></td></tr></table></figure><h3 id="参考来源-1"><a href="#参考来源-1" class="headerlink" title="参考来源"></a>参考来源</h3><p><a href="https://blog.csdn.net/qq_32755575/article/details/80443714" target="_blank" rel="noopener">/usr/bin/pip: No such file or directory</a></p><h2 id="安装或升级pip时提示SSLError"><a href="#安装或升级pip时提示SSLError" class="headerlink" title="安装或升级pip时提示SSLError"></a>安装或升级<code>pip</code>时提示<code>SSLError</code></h2><h3 id="错误提示-2"><a href="#错误提示-2" class="headerlink" title="错误提示"></a>错误提示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;SSLError(SSLError(1, &apos;[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:833)&apos;),)&apos;: /simple/pip/</span><br><span class="line">Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;SSLError(SSLError(1, &apos;[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:833)&apos;),)&apos;: /simple/pip/</span><br><span class="line">Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;SSLError(SSLError(1, &apos;[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:833)&apos;),)&apos;: /simple/pip/</span><br><span class="line">Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;SSLError(SSLError(1, &apos;[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:833)&apos;),)&apos;: /simple/pip/</span><br><span class="line">Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;SSLError(SSLError(1, &apos;[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:833)&apos;),)&apos;: /simple/pip/</span><br><span class="line">Could not fetch URL https://pypi.python.org/simple/pip/: There was a problem confirming the ssl certificate: HTTPSConnectionPool(host=&apos;pypi.python.org&apos;, port=443): Max retries exceeded with url: /simple/pip/ (Caused by SSLError(SSLError(1, &apos;[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:833)&apos;),)) - skipping</span><br><span class="line">#其实本人遇到的错误是</span><br><span class="line">(Caused by SSLError(SSLError(1, u&apos;[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&apos;),))</span><br></pre></td></tr></table></figure><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>临时方案</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装时添加参数：</span><br><span class="line">--trusted-host pypi.python.org</span><br><span class="line">此方式表示信任该域名，但是每一次安装包的时候都需要该操作，比较麻烦；</span><br></pre></td></tr></table></figure><ul><li>永久方案</li></ul><p>修改<code>pip.conf</code> 配置文件，该文件在<code>Linux</code>系统中的可能位置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/pip.conf</span><br><span class="line"></span><br><span class="line">~/.pip/pip.conf</span><br><span class="line"></span><br><span class="line">~/.config/pip/pip.conf</span><br></pre></td></tr></table></figure></p><p>如果都没有的话，可以手动创建之后添加以下内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple/      # 本机使用阿里源代理</span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br><span class="line"></span><br><span class="line"># global字段还看到其他写法：</span><br><span class="line">[global]</span><br><span class="line">trusted-host = pypi.python.org</span><br><span class="line">               pypi.org</span><br><span class="line">               files.pythonhosted.org</span><br></pre></td></tr></table></figure><h3 id="参考来源-2"><a href="#参考来源-2" class="headerlink" title="参考来源"></a>参考来源</h3><p><a href="https://stackoverflow.com/questions/16370583/pip-issue-installing-almost-any-library" target="_blank" rel="noopener">pip issue installing almost any library</a><br><a href="https://www.cnblogs.com/yudar/p/4657511.html" target="_blank" rel="noopener">linux 设置 pip 镜像 Pip Warning：–trusted-host 问题解决方案</a></p><h2 id="安装MySQL-python时提示"><a href="#安装MySQL-python时提示" class="headerlink" title="安装MySQL-python时提示"></a>安装<code>MySQL-python</code>时提示</h2><h3 id="错误提示-3"><a href="#错误提示-3" class="headerlink" title="错误提示"></a>错误提示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EnvironmentError: mysql_config not found</span><br></pre></td></tr></table></figure><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>CentOS</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install libffi-devel </span><br><span class="line">pip install mysql-connector-python</span><br></pre></td></tr></table></figure><ul><li>Ubuntu</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install default-libmysqlclient-dev</span><br></pre></td></tr></table></figure><h3 id="参考来源-3"><a href="#参考来源-3" class="headerlink" title="参考来源"></a>参考来源</h3><p><a href="https://stackoverflow.com/questions/5178292/pip-install-mysql-python-fails-with-environmenterror-mysql-config-not-found" target="_blank" rel="noopener">pip install mysql-python fails with EnvironmentError: mysql_config not found</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRBD 备忘记录</title>
      <link href="/blog/2018-09-11/Record-of-drbd/"/>
      <url>/blog/2018-09-11/Record-of-drbd/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>这是一个关于 <code>DRBD</code> 的使用备忘录。<br><a id="more"></a></p><p><img src="https://docs.linbit.com/ug-src/users-guide-8.4/images/drbd-in-kernel.png" alt="DRBD在Linux内核I/O栈的位置"></p><p>开始阅读之前，请先注意示例中使用的 DRBD 版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm -V</span><br><span class="line"><span class="meta">#</span><span class="bash"> DRBDADM_VERSION=8.4.3</span></span><br></pre></td></tr></table></figure><p>注意：安装的 kernel-devel 的内核源码（内核源码路径/usr/src/kernel/）和当前系统的 kernel 版本(uname -r)不一致的话需要把当前内核更新一下。<br>在<code>2.6.33</code>及以上版本的内核默认中有<code>DRBD</code>,之前在用的<code>DRBD</code>主要<code>8.0</code>、<code>8.2</code>、<code>8.3</code> 三个版本,对应的<code>rpm</code>包是<code>drbd</code>,<code>drbd82</code>和<code>drbd83</code>，因此需要安装对应的内核模块，对应的名字为<code>kmod-drbd</code>,<code>kmod-drbd82</code>,<code>kmod-drbd83</code>。<br>由于<code>drbd</code>是作为内核模块进行工作的，故建议使用与内核对应的版本，对应关系如下表。</p><table><thead><tr><th style="text-align:left">Linux releases</th><th style="text-align:left">DRBD releases</th></tr></thead><tbody><tr><td style="text-align:left">2.6.33</td><td style="text-align:left">8.3.7</td></tr><tr><td style="text-align:left">2.6.34</td><td style="text-align:left">8.3.7</td></tr><tr><td style="text-align:left">2.6.35</td><td style="text-align:left">8.3.8</td></tr><tr><td style="text-align:left">2.6.36</td><td style="text-align:left">8.3.8.1</td></tr><tr><td style="text-align:left">2.6.37</td><td style="text-align:left">8.3.9</td></tr><tr><td style="text-align:left">2.6.38</td><td style="text-align:left">8.3.9</td></tr><tr><td style="text-align:left">2.6.39</td><td style="text-align:left">8.3.10</td></tr><tr><td style="text-align:left">3.0 - 3.4</td><td style="text-align:left">8.3.11</td></tr><tr><td style="text-align:left">3.5 - 3.7</td><td style="text-align:left">8.3.13</td></tr></tbody></table><p><strong>注意:</strong>目前官网上面 8.0 – 8.3.x 已标注为<code>Deprecated</code>即不建议使用状态。</p><h2 id="drbd-状态记录"><a href="#drbd-状态记录" class="headerlink" title="drbd 状态记录"></a>drbd 状态记录</h2><p><a href="https://imoyao.github.io/blog/2018-08-29/state-of-drbd/">本部分内容详见此处</a></p><h2 id="清除单个-DRBD-资源配置：-以-drbd10-为例"><a href="#清除单个-DRBD-资源配置：-以-drbd10-为例" class="headerlink" title="清除单个 DRBD 资源配置：(以 drbd10 为例)"></a>清除单个 <code>DRBD</code> 资源配置：(以 drbd10 为例)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbd-overview       # drbd概览</span><br><span class="line">drbdadm down drbd10         #down drbd</span><br><span class="line">echo yes|drbdadm wipe-md drbd10     #清除metadata</span><br><span class="line">cd /etc/drbd.d/         # 注意，此处根据drbd版本不同也可能在/usr/local/etc/drbd.d/</span><br><span class="line">rm drbd10.res           #删除resource文件</span><br></pre></td></tr></table></figure><h2 id="重启-DRBD-服务"><a href="#重启-DRBD-服务" class="headerlink" title="重启 DRBD 服务"></a>重启 <code>DRBD</code> 服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service drbd stop </span><br><span class="line">service drbd start</span><br></pre></td></tr></table></figure><h2 id="DRBD扩容"><a href="#DRBD扩容" class="headerlink" title="DRBD扩容"></a><code>DRBD</code>扩容</h2><p>当遇到我们的<code>drbd resource</code>设备容量不够的时候，而且我们的底层设备支持在线增大容量的时候（比如 lvm），我们可以先增大底层设备的大小，然后再通过<code>drbdadm resize resource_name</code>来实现对<code>resource</code>的扩容。<br>这里有需要注意的是：<br>只有在单主模式下可以这样做，而且需要先在两节点上都增大底层设备的容量，然后仅在主节点上执行<code>resize</code>命令。</p><p>在执行了<code>resize</code>命令后，将自动触发一次当前主节点到其他所有从节点的 re-synchronization；</p><p>如果我们在<code>drbd</code>非工作状态下对底层设备进行了扩容，然后再启动<code>drbd</code>，将不需要执行<code>resize</code>命令（当然前提是在配置文件中没有对 disk 参数项指定大小），<code>drbd</code>自己会知道已经增大了容量；</p><p>在进行底层设备的增容操作的时候千万不要修改到原设备上面的数据，尤其是<code>drbd</code>的<code>meta</code>信息，否则有可能毁掉所有数据。</p><h3 id="流程简单示例"><a href="#流程简单示例" class="headerlink" title="流程简单示例"></a>流程简单示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先在两端扩展Lun（需要相同大小）     </span></span><br><span class="line">lvextend -Ll(50G) lvpath</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> drbd从端：（双主模式切换为主从模式）</span></span><br><span class="line">drbdadm secondary drbd[Num]     </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> drbd主端：</span></span><br><span class="line">drbdadm resize drbd[Num]</span><br></pre></td></tr></table></figure><h2 id="global-common-conf-配置（示例）"><a href="#global-common-conf-配置（示例）" class="headerlink" title="global_common.conf 配置（示例）"></a>global_common.conf 配置（示例）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">global &#123;</span><br><span class="line">    usage-count no;     # 是否向官方发送统计报告（影响性能）</span><br><span class="line">&#125;</span><br><span class="line">common &#123;            # 定义drbd设备共享的属性信息</span><br><span class="line">    handlers &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    startup &#123;       # 启动时候的相关设置</span><br><span class="line">        wfc-timeout 50;</span><br><span class="line">        become-primary-on both;     # 允许双主</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    disk &#123;</span><br><span class="line">        on-io-error detach;     # 配置I/O错误处理策略为分离</span><br><span class="line">        no-disk-flushes ;</span><br><span class="line">        no-disk-barrier;</span><br><span class="line">        c-plan-ahead 0;</span><br><span class="line">        c-fill-target 24M;</span><br><span class="line">        c-min-rate 80M;</span><br><span class="line">        c-max-rate 720M;</span><br><span class="line">    &#125; </span><br><span class="line">    net &#123;               # 网络配置相关</span><br><span class="line">        protocol C;     # 同步异步控制（见下方介绍）</span><br><span class="line">        after-sb-0pri discard-younger-primary;  # 脑裂修复</span><br><span class="line">        after-sb-1pri discard-secondary;</span><br><span class="line">        after-sb-2pri call-pri-lost-after-sb;</span><br><span class="line">        allow-two-primaries yes;        # 允许双主</span><br><span class="line">        max-buffers        36k;</span><br><span class="line">        sndbuf-size         1024k ;</span><br><span class="line">        rcvbuf-size      2048k;</span><br><span class="line">    &#125;</span><br><span class="line">    syncer &#123;    # 同步相关的设置</span><br><span class="line">            rate                   4194304k;    # bytes/second</span><br><span class="line">            al-extents              6433;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Read_More:http://tech.sina.com.cn/smb/2008-12-22/1050926302.shtml</span></span><br></pre></td></tr></table></figure><h3 id="数据同步协议"><a href="#数据同步协议" class="headerlink" title="数据同步协议"></a>数据同步协议</h3><p><code>DRBD</code>有三种数据同步模式:同步，异步，半同步</p><ol><li>异步：指的是当数据写到磁盘上，并且复制的数据已经被放到我们的<code>tcp</code>缓冲区并等待发送以后，就认为写入完成；</li><li>半同步：指的是数据已经写到磁盘上，并且这些数据已经发送到对方内存缓冲区，对方的<code>tcp</code>已经收到数据，并宣布写入；</li><li>同步：指的是主节点已写入，从节点磁盘也写入；</li></ol><p><code>DRBD</code>的复制模型是靠<code>protocol</code>关键字来定义的：<code>protocol A</code>表示异步；<code>protocol B</code>表示半同步；<code>protocol C</code>表示同步，默认为<code>protocol C</code>。</p><p>在同步模式下只有主、从节点上两块磁盘同时损害才会导致数据丢失。在半同步模式下只有主节点宕机，同时从节点异常停电才会导致数据丢失。</p><p><strong>注意:</strong></p><ol><li>主从所在的磁盘分区最好大小相等,<code>DRBD</code>磁盘镜像相当于网络<code>RAID1</code>；（本人使用时强制相等，但网上没有关于分区大小是否一定要相同的确切说法）</li><li>网络同步时需要一定的时间，在同步完成之前最好不要重启，否则会重新同步；</li><li><code>DRBD</code>的主节点不会监控从节点的状态，所以有可能会造成数据重传；</li><li>格式化只需要在<code>primary</code>节点上进行,且只能在主节点上挂载；若主节点下线,从节点上线,则从节点可以直接挂载,不需要再次格式化。集群中只有 primary 服务器可以挂载设备，secondary 挂载会报错。只有在进行故障迁移升级为主时才需要挂载。</li><li>如果<code>DRBD</code>状态下关机双控恢复不过来，尝试删除<code>DRBD</code>配置信息，然后停掉<code>DRBD</code>端 ODSP 和<code>mysql</code>重启之后即可；(此条仅针对公司项目)</li></ol><h2 id="单个drbd配置文件（以-drbd10-res-为例）"><a href="#单个drbd配置文件（以-drbd10-res-为例）" class="headerlink" title="单个drbd配置文件（以 drbd10.res 为例）"></a>单个<code>drbd</code>配置文件（以 drbd10.res 为例）</h2><h3 id="项目中的配置方案"><a href="#项目中的配置方案" class="headerlink" title="项目中的配置方案"></a>项目中的配置方案</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resource drbd11 &#123;</span><br><span class="line">    on controller-1 &#123;</span><br><span class="line">        device /dev/drbd11;</span><br><span class="line">        disk /dev/StorPool11/SANLun11;</span><br><span class="line">        address 192.168.2.10:57811;</span><br><span class="line">        meta-disk internal;</span><br><span class="line">    &#125;</span><br><span class="line">    on controller-2 &#123;</span><br><span class="line">        device /dev/drbd11;</span><br><span class="line">        disk /dev/StorPool11/SANLun11;</span><br><span class="line">        address 192.168.2.18:57811;</span><br><span class="line">        meta-disk internal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="另外一种配置方案"><a href="#另外一种配置方案" class="headerlink" title="另外一种配置方案"></a>另外一种配置方案</h3><p>来自<a href="https://www.suse.com/documentation/sle_ha/book_sleha/data/sec_ha_drbd_configure.html" target="_blank" rel="noopener">这里</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resource r0 &#123;   # ①</span><br><span class="line">  device /dev/drbd0; # ②</span><br><span class="line">  disk /dev/sda1;   # ③</span><br><span class="line">  meta-disk internal;   # ④</span><br><span class="line">  on alice &#123;    # ⑤</span><br><span class="line">    address  192.168.1.10:7788;     # ⑥</span><br><span class="line">  &#125;</span><br><span class="line">  on bob &#123; </span><br><span class="line">    address 192.168.1.11:7788; </span><br><span class="line">  &#125;</span><br><span class="line">  syncer &#123;</span><br><span class="line">    rate  7M;   # ⑦</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译以看懂为目的：</p><p>1.允许某些系统服务项关联的名称，如：nfs, http, mysql_0, postgres_wal 等；<br>Name that allows some association to the service that needs them. For example, nfs, http, mysql_0, postgres_wal, etc.</p><p>2.<code>DRBD</code>设备名称及编号；<br>The device name for DRBD and its minor number.</p><p>在上面的例子中，<code>drbd</code>的编号是<code>0</code>。udev 集成脚本提供符号链接<code>/dev/drbd/by-res/nfs/0</code>。或者，也可以省略配置中的设备节点名称，然后使用下面这种形式代替：<br><code>drbd0 minor 0</code>（/dev/可选）或<code>/dev/drbd0</code>；</p><p>In the example above, the minor number 0 is used for DRBD. The udev integration scripts will give you a symbolic link /dev/drbd/by-res/nfs/0. Alternatively, omit the device node name in the configuration and use the following line instead:<br>drbd0 minor 0 (/dev/ is optional) or /dev/drbd0</p><p>3.节点之间进行复制的原始设备。注意：在本例中，两个节点上面的设备是相同的。若使用不同设备，请将磁盘参数移动到主机上。（？）</p><p>The raw device that is replicated between nodes. Note, in this example the devices are the same on both nodes. If you need different devices, move the disk parameter into the on host.</p><p>4.<code>meta-disk</code>参数通常包含隐式值，但是你也可以指定一个显式设备保存元数据。详情参见：<a href="http://www.drbd.org/users-guide-emb/ch-internals.html#s-metadata" target="_blank" rel="noopener">这里&gt;&gt;&gt;</a></p><p>The meta-disk parameter usually contains the value internal, but it is possible to specify an explicit device to hold the meta data. See <a href="http://www.drbd.org/users-guide-emb/ch-internals.html#s-metadata" target="_blank" rel="noopener">http://www.drbd.org/users-guide-emb/ch-internals.html#s-metadata</a> for more information.</p><p>5.<code>on</code>节配置指明改配置应用于具体哪个<code>host</code>。</p><p>The on section states which host this configuration statement applies to.</p><p>6.各节点的<code>IP</code>地址和端口号。每个资源需要一个单独的端口，通常以<code>7788</code>开始。</p><p>The IP address and port number of the respective node. Each resource needs an individual port, usually starting with 7788.</p><p>7.同步率。将其设置为磁盘读写和网络带宽的三分之一。仅限制重新同步，而不是复制。</p><p>The synchronization rate. Set it to one third of the lower of the disk- and network bandwidth. It only limits the resynchronization, not the replication.</p><h2 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h2><p>主备节点切换有两种方式，分别是停止<code>DRBD</code>服务切换和正常切换。</p><h3 id="正常切换"><a href="#正常切换" class="headerlink" title="正常切换"></a>正常切换</h3><p>主切换成从，需要先卸载文件系统，再执行降级为从的命令</p><h4 id="主端"><a href="#主端" class="headerlink" title="主端"></a>主端</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umount /data/</span><br><span class="line">drbdadm secondary all</span><br></pre></td></tr></table></figure><h4 id="从端"><a href="#从端" class="headerlink" title="从端"></a>从端</h4><p>从切换成主，要先执行升主的命令，然后挂载文件系统</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm  primary all</span><br><span class="line">mount /dev/drbd0 /data/</span><br></pre></td></tr></table></figure><h3 id="停止-drbd-服务切换"><a href="#停止-drbd-服务切换" class="headerlink" title="停止 drbd 服务切换"></a>停止 drbd 服务切换</h3><p>基本思路：关闭主节点服务，此时挂载的<code>DRBD</code>分区就自动在主节点卸载了，然后在备用节点执行切换命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@drbd2 ~]#drbdadm primary all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时报错：</span></span><br><span class="line">2: State change failed: (-7) Refusing to be Primary while peer is not outdated</span><br><span class="line">Command 'drbdsetup 2 primary' terminated with exit code 11</span><br><span class="line"><span class="meta">#</span><span class="bash"> 因此，必须在备用节点执行如下命令：</span></span><br><span class="line">[root@drbd2 ~]#drbdsetup /dev/drbd0 primary –o</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">[root@drbd2~]#drbdadm -- --overwrite-data-of-peer primary all</span><br></pre></td></tr></table></figure><p>当在备用节点执行切换到主节点命令后，原来的主用节点自动变为备用节点。无需在主用节点再次执行切换到备用节点的命令。</p><h2 id="脑裂修复"><a href="#脑裂修复" class="headerlink" title="脑裂修复"></a>脑裂修复</h2><p>当<code>DRBD</code>出现脑裂后，会导致<code>DRBD</code>两边的磁盘数据不一致，在确定要作为从的节点上切换成<code>secondary</code>，并放弃该资源的数据:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm secondary r0</span><br><span class="line">drbdadm -- --discard-my-data connect r0</span><br></pre></td></tr></table></figure><p>然后作为<code>primary</code>的节点重新连接<code>secondary</code>（如果这个节点当前的连接状态为<code>WFConnection</code>的话，可以省略），使用如下命令连接：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm connect r0</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="双控配置互信（假定在控-1-执行）"><a href="#双控配置互信（假定在控-1-执行）" class="headerlink" title="双控配置互信（假定在控 1 执行）"></a>双控配置互信（假定在控 1 执行）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo y|ssh-keygen -t dsa -f ~/.ssh/id_dsa -N ""</span><br><span class="line">cp ~/.ssh/id_dsa.pub ~/.ssh/authorized_keys</span><br><span class="line">scp -r ~/.ssh controller-2:         #双控对端hostname</span><br></pre></td></tr></table></figure><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><ul><li><p><a href="https://docs.linbit.com/docs/users-guide-8.4/" target="_blank" rel="noopener">官方手册</a></p></li><li><p><a href="https://www.suse.com/documentation/sle_ha/book_sleha/data/cha_ha_drbd.html" target="_blank" rel="noopener">SUSE 高可用配置</a></p></li><li><p><a href="http://clusterlabs.org/doc/en-US/Pacemaker/1.1/html/Clusters_from_Scratch/ch07.html" target="_blank" rel="noopener">使用 DRBD 实现复制存储</a></p></li><li><p><a href="http://www.cnblogs.com/wxl-dede/p/5114696.html" target="_blank" rel="noopener">drbd 配置 - Rikewang - 博客园</a></p></li><li><p><a href="http://www.3mu.me/centos%E4%B8%8B%E5%AE%9E%E7%8E%B0heartbeatdrbdmysql%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87%E7%A1%AC%E4%BB%B6%E6%95%85%E9%9A%9C%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E9%AB%98%E5%8F%AF%E7%94%A8ha/#respond" target="_blank" rel="noopener">CentOS 下实现 Heartbeat+DRBD+MySQL 双机热备硬件故障自动切换高可用(HA)方案 | 三木的人生——3mu.me</a></p></li><li><p><a href="https://www.ibm.com/developerworks/library/l-drbd/index.html" target="_blank" rel="noopener">High availability with the Distributed Replicated Block Device</a></p></li><li><p><a href="https://yq.aliyun.com/articles/52043" target="_blank" rel="noopener">记一次 DRBD Unknown 故障处理过程</a></p></li><li><p><a href="https://www.linuxidc.com/wap.aspx?nid=93422&amp;cid=9&amp;sp=654" target="_blank" rel="noopener">DRBD 管理、故障处理部分</a>(<a href="https://www.linuxidc.com/Linux/2013-12/93422.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2013-12/93422.htm</a>)</p></li><li><p><a href="http://blog.csdn.net/t1anyuan/article/details/52143789" target="_blank" rel="noopener">DRBD 编译安装中出现的问题及解决小结 - CSDN 博客</a></p></li><li><p><a href="https://www.linuxidc.com/Linux/2012-01/51661.htm" target="_blank" rel="noopener">DRBD 配置参数</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DRBD </tag>
            
            <tag> 存储 </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRBD 状态指标记录</title>
      <link href="/blog/2018-08-29/state-of-drbd/"/>
      <url>/blog/2018-08-29/state-of-drbd/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>在管理<code>DRBD</code>的时候，需要关注<code>drbd</code>相关的各种状态指标，本文主要记录相关的指令及显示含义。<br><a id="more"></a></p><h2 id="DRBD状态概览"><a href="#DRBD状态概览" class="headerlink" title="DRBD状态概览"></a><code>DRBD</code>状态概览</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbd-overview</span><br><span class="line">drbd status</span><br><span class="line">cat /proc/drbd      # 9.0废止在drbd9中，更多的是使用drbdadm或drbdsetup来获取节点的状态信息。</span><br></pre></td></tr></table></figure><p>以上命令略有不同，可自行对照</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Storage drbd]# pwd</span><br><span class="line">/usr/lib/drbd</span><br><span class="line">[root@Storage drbd]# ./drbd status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出示例</span></span><br><span class="line">drbd driver loaded OK; device status:</span><br><span class="line">version: 8.4.3 (api:1/proto:86-101)</span><br><span class="line">GIT-hash: 89a2942***221f964d3ee515 build by root@third, 2017-07-20 10:58:42</span><br><span class="line">m:res          cs            ro                 ds                 p       mounted       fstype</span><br><span class="line">0:drbd0        Connected     Primary/Secondary  UpToDate/UpToDate  C</span><br><span class="line">1:drbd1^^0     StandAlone    Primary/Unknown    UpToDate/DUnknown  r----s</span><br><span class="line">……</span><br><span class="line">6:drbd6        Connected     Primary/Secondary  UpToDate/UpToDate  C       /xxx  ext4</span><br></pre></td></tr></table></figure><p>缩写解释</p><ul><li>res：资源名称</li><li>cs：connect state,资源连接状态</li><li>ro：role，表示节点角色信息<br>第一次启动 drbd 时，两个 drbd 节点默认都处于 Secondary 状态，<br>Primary/Secondary（代表这个是主节点）<br>Secondary/Primary（代表这个是副节点）</li><li>ds：disk state,磁盘状态信息<br>Inconsistent/Inconsisten，即为“不一致/不一致”状态，表示两个节点的磁盘数据处于不一致状态。<br>UpToDate/Inconsistent（正在同步，数据还没有一致）<br>UpToDate/UpToDate （同步完成，数据一致）</li><li>C drbd 的复制协议，即 A、B、C 协议。</li><li>r—–是 IO 标记，反映的是该资源的 IO 状态信息。共有 6 种 IO 状态标记符号。</li></ul><h2 id="连接状态"><a href="#连接状态" class="headerlink" title="连接状态"></a>连接状态</h2><p>节点间通过 TCP 连接进行通信，在建立连接、断开连接、特殊情况下有很多种连接状态。</p><p>DRBD 连接建立完成，表示元数据区、数据区等一切都已准备好，可以进行任何数据同步的操作。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# drbdadm cstate drbd20</span><br><span class="line">Connected</span><br></pre></td></tr></table></figure></p><p>一个资源可能有以下连接状态中的一种</p><ul><li>Unconfigured：设备在等待配置</li><li><strong>WFConnection</strong>：当前节点正在等待对端节点出现。例如对方节点<code>drbdadm down</code>后，本节点将处于本状态。</li><li><strong>StandAlone</strong>：无连接。出现这种状态可能是因为：未连接过、使用<code>drbdadm disconnect</code>断开连接、节点由于身份验证的原因未成功加入 drbd 集群使得连接被删除、脑裂后断开连接。</li><li>Disconnecting：断开连接的一个临时过渡状态。它很快就会切入下一状态就是<code>StandAlone</code>。</li><li>Unconnected：尝试再次发起<code>TCP</code>连接时的一个临时连接状态(是连接超时后再次发送连接请求产生的状态)，它的下一个状态可能是<code>WFConnection</code>，也可能是<code>WFReportParams</code>。</li><li>Timeout：和对端通信超时时的临时状态。下一个状态就是<code>Unconnection</code>。</li><li>BrokenPipe：和对端连接丢失时的临时状态。下一个状态是<code>Unconnection</code>。</li><li>NetworkFailure：和对端连接丢失时的临时状态。下一个状态是<code>Unconnection</code>。(没错，和上面的一样)</li><li>ProtocolError：和对端连接丢失时的临时状态。下一个状态是<code>Unconnection</code>。(没错，还是和上面的一样)</li><li>TearDown：对端关闭 TCP 连接时的临时状态。下一个状态是<code>Unconnection</code>。</li><li><strong>Connected</strong>：DRBD 连接已经建立完成，数据镜像已经激活成功。这个状态是<code>drbd</code>正常运行时的状态。</li><li>WFReportParams：TCP 连接已经建立完成，该节点正在等待对端的第一个数据包。</li><li>StartingSyncS：全盘数据同步中。只有在初始化时才应该全盘同步。下一个状态是：<code>SyncSource</code>或<code>PauseSyncS</code>。</li><li>StartingSyncT：全盘数据同步中。只有在初始化时才应该全盘同步。下一个状态是：<code>WFSyncUUID</code>。</li><li>WFBitMapS：部分数据正在同步。下一个状态是：<code>SyncSource</code>或<code>PauseSyncS</code>。</li><li>WFBitMapT：部分数据正在同步。下一个状态是：<code>WFSyncUUID</code>。</li><li>WFSyncUUID：同步马上就要开始了。下一个状态：<code>SyncTarget</code>或<code>PauseSyncT</code>。</li><li><strong>SyncSource</strong>：正在同步，且本节点是数据同步的源端。</li><li><strong>SyncTartget</strong>：正在同步，且本节点是数据同步的目标端。</li><li>PauseSyncS：本节点是同步的源端节点，但同步过程当前被暂停。出现这种状态的原因可能是当前同步进程依赖于另一个同步进程完成，或者使用<code>drbdadm pause-sync</code>手动中断了同步操作。</li><li>PauseSyncT：本节点是同步的目标端，但同步过程当前被暂停。出现这种状态的原因可能是当前同步进程依赖于另一个同步进程完成，或者使用<code>drbdadm pause-sync</code>手动中断了同步操作。</li><li>VerifyS：正在进行在线设备验证，且本节点将成为验证的源端。</li><li>VerifyT：正在进行在线设备验证，且本节点将成为验证的目标端。</li></ul><p>在 drbd9 中，<code>WFConnection</code>状态改为<code>connecting</code>状态。删除了<code>WFReportParams</code>状态。添加了以下几个同步相关的状态：</p><ul><li>Off：该卷组还未同步，因为连接未建立。</li><li><strong>Established</strong>：所有对该卷组的写操作已经在线完成同步。这是<code>drbd</code>正常运行时的状态。</li><li>Ahead：数据同步操作被挂起，因为网络套接字中达到了一定的堵塞程度，无法应付更多的负载。该状态需要配置<code>on-congestion</code>选项来启用。</li><li>Behind：对端将数据同步操作挂起，因为网络套接字中达到了一定的堵塞程度，无法应付更多的负载。该状态需要在对端节点上配置<code>on-congestion</code>选项来启用。</li></ul><h2 id="角色状态"><a href="#角色状态" class="headerlink" title="角色状态"></a>角色状态</h2><p>资源的角色状态既可以从/proc/drbd 文件中获取，也可以使用下面的命令来获取。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@drbd1 ~]# drbdadm role data1</span><br><span class="line">Primary/Unknown</span><br></pre></td></tr></table></figure></p><p>在角色状态信息中，本地节点总是标记在第一位，远程节点标记在结尾。</p><p>可能的节点角色状态有：</p><ul><li>Primary：资源的 primary 角色，该角色状态下的 drbd 设备可以进行挂载、读、写等。在没有启用多主复制模型(dual-primary mode)，只能有一个 primary 节点。</li><li>Secondary：资源的 secondary 角色。该角色状态下的 drbd 设备会接收来自 primary 端的数据更新(除非和对端不是 primary)。且该角色的 drbd 设备不可挂载、不可读、不可写。</li><li>Unknown：资源的角色未知。本地节点的角色状态绝对不可能会是这种状态。只有对端节点断开连接时对端节点才处于 Unknown 状态。</li></ul><h2 id="硬盘状态"><a href="#硬盘状态" class="headerlink" title="硬盘状态"></a>硬盘状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# drbdadm dstate drbd20</span><br><span class="line">UpToDate/UpToDate</span><br></pre></td></tr></table></figure><p>在磁盘状态信息中，本地节点的磁盘状态总是标记在第一位，远程节点标记在结尾。本地和对等节点的硬盘有可能为下列状态之一：</p><ul><li>Diskless 无盘：本地没有块设备分配给<code>DRBD</code>使用，这意味着资源可能从没有和它的底层块设备进行关联绑定(attach)，也可能是手动 detach 解除了关联，还可能是出现了底层 I/O 错误时自动分离（detach）。</li><li>Attaching：读取无数据时候的瞬间状态</li><li>Failed：失败，本地块设备报告<code>I/O</code>错误的下一个状态，其下一个状态为<code>Diskless</code>无盘</li><li>Negotiating：在已经连接的 DRBD 设置进行<code>Attach</code>读取无数据前的瞬间状态</li><li>Inconsistent：数据不一致，在两个节点上（初始的完全同步前）这种状态出现后立即创建一个新的资源。此外，在同步期间（同步目标端）正接收同步数据时，也会进入不一致状态。</li><li>Outdated：数据资源是一致的，但是已经过时。(例如，已经同步后 secondary 下线了，之后又上线了，在还没开始重新同步的时候就是 Outdated 状态)</li><li>DUnknown：当对等节点网络连接不可用时出现这种状态</li><li>Consistent：连接断开时的数据处于一致性状态，当连接建立后，将决定数据是<code>UpToDate</code>还是<code>Outdated</code>状态</li><li>UpToDate：一致的、最新的数据状态，这个状态为正常状态</li></ul><h2 id="IO-状态标记"><a href="#IO-状态标记" class="headerlink" title="IO 状态标记"></a>IO 状态标记</h2><p>IO 状态标记表示的是当前资源的 IO 操作状态。共有 6 种状态：</p><ul><li>IO 挂起：r 或 s 都可能表示 IO 挂起，一般是 r。r=running，s=suspended。</li><li>串行重新同步：资源正在等待进行重新同步，但被 resync-after 选项延迟了同步进度。该状态标记为”a”，通常该状态栏应该处于”-“。</li><li>对端初始化同步挂起：资源正在等待进行重新同步，但对端节点因为某些原因而 IO 挂起。该状态标记为”p”，通常该状态栏应该处于”-“。</li><li>本地初始化同步挂起：资源正在等待进行重新同步，但本节点因为某些原因而 IO 挂起。该状态标记为”u”，通常该状态栏应该处于”-“。</li><li>本地 IO 阻塞：通常该状态栏应该处于”-“。可能有以下几种标记：<ul><li>d：因为 DRBD 内部原因导致的 IO 阻塞。</li><li>b：后端设备正处于 IO 阻塞。</li><li>n：网络套接字阻塞。</li><li>a：网络套接字和后端块设备同时处于阻塞状态。</li></ul></li><li>Activity Log 更新挂起：当 al 更新被挂起时，处于该状态，标记为”s”，通常该状态栏应该处于”-“。(如果不知道什么是 Active Log，请无视本标记)</li></ul><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p>习惯上，我们使用<code>cat /proc/drbd</code>获取<code>drbd</code>状态信息。主要是一些计数器和计量器的值。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Storage ~]# cat /proc/drbd </span><br><span class="line">version: 8.4.3 (api:1/proto:86-101)</span><br><span class="line">srcversion: 9D811F04CD6DC2C9A9A608F </span><br><span class="line"></span><br><span class="line"> 3: cs:Connected ro:Secondary/Secondary ds:UpToDate/UpToDate C r-----</span><br><span class="line">    ns:0 nr:0 dw:0 dr:0 al:0 bm:0 lo:0 pe:0 ua:0 ap:0 ep:1 wo:f oos:0</span><br><span class="line"></span><br><span class="line">301: cs:Connected ro:Secondary/Secondary ds:UpToDate/UpToDate C r-----</span><br><span class="line">    ns:0 nr:0 dw:0 dr:0 al:0 bm:0 lo:0 pe:0 ua:0 ap:0 ep:1 wo:f oos:0</span><br></pre></td></tr></table></figure></p><p>drbd84 中使用缩写符号来标记性能指标，而 drbd9 中使用全称来表示。例如 drbd84 中的 ns 和 drbd9 中的 send 是同一个意思。</p><ul><li>ns/send (network send)：通过网络连接发送给对端的数据量，单位为 Kb。</li><li>nr/receive (network receive)：通过网络连接接收到对端发送来的数据量，单位为 Kb。</li><li>dw/written (disk write)：该卷(volume)写入本地磁盘的数据量，单位为 Kb。</li><li>dr/read (disk read)：该卷(volume)从本地磁盘读取的数据量，单位为 Kb。</li><li>al/al-writes (activity log)：元数据区中 al 更新的次数。</li><li>bm/bm-writes (bit map)：元数据区中 bitmap 更新的次数。</li><li>lo/lower-pending (local count)：DRBD 发起的打开本地 IO 子系统的请求次数。</li><li>pe/pending (pending)：本地发送给对端但却没有回复的次数。</li><li>ua/unacked (unacknowledged)：接收到对端发送的请求但却没有给予回复的请求数量。</li><li>ap/upper-pending (application pending)：转发给 DRBD 的 IO 块的请求，但 DRBD 还没给予回复的请求数量。</li><li>ep (epochs):epoch 对象的数量。通常为 1。drbd9 中没有该指标。</li><li>wo/write-ordering (write order):当前正在使用的 write order 方法：b(barrier), f(flush), d(drain)或 n(none)。</li><li>oos/out-of-sync (out of sync):当前不同步的数据量，单位为 Kb。</li></ul><p>上面所有”未给予回复”的指标数量都表示动作还未完成，需要回复后才表示操作完成。这些未回复数值不能太大。</p><p>此外，drbd9 中添加了以下几个指标：</p><ul><li>resync-suspended：重新同步操作当前是否被挂起。可能的值为 no/user/peer/dependency。</li><li>blocked：本地 IO 的拥挤情况。<ul><li>no：本地 IO 不拥挤。</li><li>upper：DRBD 层之上的 IO 被阻塞。例如到文件系统上的 IO 阻塞。可能有以下几种原因：<ul><li>管理员使用 drbdadm suspend-io 命令挂起了 I/O 操作。</li><li>短暂的 IO 阻塞，例如 attach/detach 导致的。</li><li>删除了缓冲区。</li><li>bitmap 的 IO 等待。</li></ul></li><li>lower：底层设备处于拥挤状态。</li></ul></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cnblogs.com/f-ck-need-u/p/8684648.html" target="_blank" rel="noopener">drbd(三)：drbd 的状态说明 - 骏马金龙 - 博客园</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DRBD </tag>
            
            <tag> Linux </tag>
            
            <tag> 高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 DRBD 使用外部元数据</title>
      <link href="/blog/2018-08-28/drbd-with-external-disk/"/>
      <url>/blog/2018-08-28/drbd-with-external-disk/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>裂脑一旦发生，需要及时排查问题所在，最大限度保护数据完整性。mathjax<br><a id="more"></a></p><h2 id="meta-data存放位置优缺点比较"><a href="#meta-data存放位置优缺点比较" class="headerlink" title="meta data存放位置优缺点比较"></a><code>meta data</code>存放位置优缺点比较</h2><h3 id="internal-meta-data"><a href="#internal-meta-data" class="headerlink" title="internal meta-data"></a>internal meta-data</h3><p>meta-data 和数据存放在同一个底层设备之上，它通过在设备末端预留一个区域以存储元数据做到这一点。</p><ul><li>优点：</li></ul><p>一旦 meta-data 创建之后，就和实际数据绑在了一起，在维护上会更简单方便，不用担心 meta-data 会因为某些操作而丢失。另外在硬盘损坏丢失数据的同时，meta-data 也跟着一起丢失，当更换硬盘之后，只需要执行重建 meta-data 的命令即可，丢失的数据会很容易的从其他节点同步过来。</p><ul><li>缺点：</li></ul><p>如果底层设备是单一的磁盘，没有做 raid，也不是 lvm 等，那么可能会对写入吞吐量产生负面影响。因为每一次写 io 都需要更新 meta-data 里面的信息，那么每次写 io 都会有两次，而且肯定会有磁头的较大寻道移动，因为 meta-data 都是记录在设备的最末端的，这样就会造成写 io 的性能降低。</p><h3 id="external-meta-data"><a href="#external-meta-data" class="headerlink" title="external meta data"></a>external meta data</h3><p><code>meta-data</code>存放在独立的，与存放数据的设备分开的设备之上。</p><ul><li>优点：</li></ul><p>与 internal meta-data 的缺点完全相对。对于某些写操作, 使用外部元数据会稍微改进延迟行为。</p><ul><li>缺点：</li></ul><p>由于 meta-data 存放在与数据设备分开的地方，就意味着如果磁盘故障且仅破坏生产数据 (而不是 DRBD 元数据), 则可以通过手动干预, 以使发起从幸存的节点到后续更换的磁盘上的完整数据同步。也就是管理维护会稍微麻烦一点，很小的一点点。</p><p><strong>注意：</strong> 如果我们希望在已经存在数据的设备上面建立 drbd 的资源，并且不希望丢失该设备上面的数据，又没办法增大底层设备的容量，而且上层文件系统不支持收缩，我们就只能将 meta data 创建成 external 方式。</p><h2 id="估算元数据大小"><a href="#估算元数据大小" class="headerlink" title="估算元数据大小"></a>估算元数据大小</h2><p>注意：如果公式渲染出错，可以去<a href="https://zohooo.github.io/jaxedit/" target="_blank" rel="noopener">这里</a>预览</p><p>你可以使用以下公式计算 DRBD 元数据的精确空间要求:</p><p><img src="https://docs.linbit.com/ug-src/users-guide-8.4/images/metadata-size-exact.png" alt="精确计算元数据大小"></p><p>$$M_{S}= \lceil\frac{C_{s}}{2^{18}} \rceil \ast 8 \ast N + 72$$</p><p>Cs 是存储设备扇区大小。N 是对端的数量，一般情况下 drbd 实现的是双节点，因此 N=1，可以不用考虑。</p><p>您可以通过发出 blockdev –getsz <device>来检索设备大小。</device></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Storage ~]# blockdev --getsz /dev/StorPool1/SANLun2</span><br><span class="line">2097152</span><br></pre></td></tr></table></figure><p>结果中的 Ms 的大小也是用扇区表示的,要转换为 MB, 请除以 2048。(对于 512 字节的扇区大小, 这是除 s390 之外的所有 Linux 平台上的默认值)。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: (math.ceil(<span class="number">2097152</span>/<span class="number">2</span>**<span class="number">18</span>)*<span class="number">8</span>+<span class="number">72</span>)/float(<span class="number">2048</span>)</span><br><span class="line">Out[<span class="number">23</span>]: <span class="number">0.06640625</span></span><br></pre></td></tr></table></figure></p><p>在实践中, 你可以使用一个合理的好的近似, 下面给出。请注意, 在此公式中, 单位为兆字节(megabytes), 而非扇区:</p><p><img src="https://docs.linbit.com/ug-src/users-guide-8.4/images/metadata-size-approx.png" alt="预估计算元数据大小"></p><p>$$M_{MB} \lt \frac{C_{MB}}{32768} \ast N + 1$$</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取块设备大小</span></span><br><span class="line">[root@Storage ~]# lsblk /dev/StorPool1/SANLun2</span><br><span class="line">NAME              MAJ:MIN RM SIZE RO TYPE MOUNTPOINT</span><br><span class="line">StorPool1-SANLun2 253:3    0   1G  0 lvm</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预估元数据设备大小</span></span><br><span class="line">In [<span class="number">30</span>]: <span class="number">1024</span>/float(<span class="number">32768</span>)+<span class="number">1</span></span><br><span class="line">Out[<span class="number">30</span>]: <span class="number">1.03125</span></span><br></pre></td></tr></table></figure><p>此处插播一个小的知识点,来源参考<a href="https://blog.csdn.net/starshine/article/details/8226320" target="_blank" rel="noopener">这里</a>（解释）和<a href="http://www.maixj.net/ict/kbkib-mbmib-gbgib-15095" target="_blank" rel="noopener">这里</a>（区别）。</p><table><thead><tr><th style="text-align:left">名字</th><th style="text-align:left">缩写</th><th style="text-align:left">次方</th><th style="text-align:left">名字</th><th style="text-align:left">缩写</th><th style="text-align:left">次方</th></tr></thead><tbody><tr><td style="text-align:left">kilobyte</td><td style="text-align:left">KB</td><td style="text-align:left">10^3</td><td style="text-align:left">kibibyte</td><td style="text-align:left">KiB</td><td style="text-align:left">2^10</td></tr><tr><td style="text-align:left">megabyte</td><td style="text-align:left">MB</td><td style="text-align:left">10^6</td><td style="text-align:left">mebibyte</td><td style="text-align:left">MiB</td><td style="text-align:left">2^20</td></tr><tr><td style="text-align:left">gigabyte</td><td style="text-align:left">GB</td><td style="text-align:left">10^9</td><td style="text-align:left">gibibyte</td><td style="text-align:left">GiB</td><td style="text-align:left">2^30</td></tr><tr><td style="text-align:left">terabyte</td><td style="text-align:left">TB</td><td style="text-align:left">10^12</td><td style="text-align:left">tebibyte</td><td style="text-align:left">TiB</td><td style="text-align:left">2^40</td></tr><tr><td style="text-align:left">petabyte</td><td style="text-align:left">PB</td><td style="text-align:left">10^15</td><td style="text-align:left">pebibyte</td><td style="text-align:left">PiB</td><td style="text-align:left">2^50</td></tr><tr><td style="text-align:left">exabyte</td><td style="text-align:left">EB</td><td style="text-align:left">10^18</td><td style="text-align:left">exbibyte</td><td style="text-align:left">EiB</td><td style="text-align:left">2^60</td></tr><tr><td style="text-align:left">zettabyte</td><td style="text-align:left">ZB</td><td style="text-align:left">10^21</td><td style="text-align:left">zebibyte</td><td style="text-align:left">ZiB</td><td style="text-align:left">2^70</td></tr><tr><td style="text-align:left">yottabyte</td><td style="text-align:left">YB</td><td style="text-align:left">10^24</td><td style="text-align:left">yobibyte</td><td style="text-align:left">YiB</td><td style="text-align:left">2^80</td></tr></tbody></table><h2 id="重置资源的大小"><a href="#重置资源的大小" class="headerlink" title="重置资源的大小"></a>重置资源的大小</h2><h3 id="在线增加"><a href="#在线增加" class="headerlink" title="在线增加"></a>在线增加</h3><p>需要满足两个条件：</p><ol><li><p>支持设备必须是逻辑卷</p></li><li><p>当前的资源必须处于<code>connected</code>的连接状态。</p></li></ol><p>在两个节点给设备增加大小后，再确认只有一个节点处于<code>primary</code>状态。然后输入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm resize &lt;resource&gt;</span><br></pre></td></tr></table></figure><p>此命令会触发新扇区的同步，完成主节点到备用节点间的同步。</p><p>如果你添加的空间是干净没有数据的，你可以使用<code>--assume-clean</code>选项：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm -- --assume-clean resize &lt;resource&gt;</span><br></pre></td></tr></table></figure><p>来跳过额外的空间同步。</p><h3 id="离线增加"><a href="#离线增加" class="headerlink" title="离线增加"></a>离线增加</h3><p>（此为高级功能，请自审之后使用。）</p><ol><li>资源被配置为 external meta data 时</li></ol><p>当 DRBD 在处于非活动情况下，在两个节点的支持设备被扩展时，且 DRBD 资源使用的是 external meta data，那么新的大小会自动被识别，不需要管理员干预。DRBD 设备将在下次两个节点活动并且成功建立网络连接之后，显示增加后的新容量。</p><ol start="2"><li>资源被配置为 internal meta data 时</li></ol><p>当 DRBD 资源被配置为使用 internal meta data 时，在新大小变为可用之前, 则必须将此元数据移动到已扩容设备的末尾。为此, 请完成以下步骤:</p><ul><li>down 掉 DRBD 资源:</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm down &lt;resource&gt;</span><br></pre></td></tr></table></figure><ul><li>在收缩之前将元数据保存在文本文件中</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm dump-md &lt;resource&gt; &gt; /tmp/metadata</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 以上步骤必须在两个节点上分别运行。不能在一个节点上保存了元数据然后在拷贝到另外一个节点上。否则就无法正常工作。</p><ul><li><p>在两个节点上给支持的块设备增加容量</p></li><li><p>分别在两个节点上调整/tmp/metadata 文件中<code>la-size-sect</code>的大小信息。注：这里 la-size-sect 指定的是扇区数量</p></li><li><p>重新初始化元数据区域</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm create-md &lt;resource&gt;</span><br></pre></td></tr></table></figure><ul><li>分别在两个节点上重新导入修正的元数据</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 此处使用bash脚本，需要确认可用性</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> drbdmeta_cmd=$(drbdadm -d dump-md &lt;resource&gt;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$&#123;drbdmeta_cmd/dump-md/restore-md&#125;</span> /tmp/metadata</span></span><br><span class="line">Valid meta-data in place, overwrite? [need to type 'yes' to confirm]</span><br><span class="line">yes</span><br><span class="line">Successfully restored meta data</span><br></pre></td></tr></table></figure><ul><li>重新启用 DRBD 资源</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm up &lt;resource&gt;</span><br></pre></td></tr></table></figure><ul><li>在一个节点上，设置 DRBD 为 primary</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm primary &lt;resource&gt;</span><br></pre></td></tr></table></figure><p>至此，已完成 DRBD 设备大小的扩容。</p><h3 id="在线缩小容量"><a href="#在线缩小容量" class="headerlink" title="在线缩小容量"></a>在线缩小容量</h3><p>注：在线缩小容量，仅支持<code>external metadata</code></p><p>在缩小 DRBD 设备时必须首先缩小 DRBD 的上层块设备。例如文件系统。由于 DRBD 无法获知文件系统到底使用了多少空间，所以在缩小文件系统时需要格外小心防止数据丢失！文件系统是否可以被缩小取决于所使用的文件系统。大多数文件系统不支持在线缩减。XFS 也不支持在线缩减。</p><p>因此，在缩小文件系统后，可以使用以下命令在线缩小 DRBD 设备容量。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm resize --size=&lt;new-size&gt;  &lt;resource&gt;</span><br></pre></td></tr></table></figure><h3 id="离线收缩容量"><a href="#离线收缩容量" class="headerlink" title="离线收缩容量"></a>离线收缩容量</h3><p>（此为高级功能，请自审之后使用。）</p><p>如果在 DRBD 处于非活动状态时收缩后备块设备, DRBD 将拒绝在下次尝试<code>attach</code>期间<code>attach</code>到此块设备, 因为它现在太小 (external meta-data), 或者它将无法找到其元数据 (internal meta-data)。要变通解决这些问题, 请使用此过程 (如果不能使用上面的在线收缩):</p><ul><li><p>在 DRBD 还处于配置运行状态时，在一个节点上缩小文件系统</p></li><li><p>down 掉 DRBD 资源</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm down &lt;resource&gt;</span><br></pre></td></tr></table></figure><ul><li>在缩小前保存元数据到一个文件中：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm dump-md &lt;resource&gt; &gt; /tmp/metadata</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 以上步骤必须在两个节点上分别运行。不能在一个节点上保存了元数据然后在拷贝到另外一个节点上。否则就无法正常工作。</p><ul><li><p>在两个节点上给支持的块设备缩小容量</p></li><li><p>分别在两个节点上调整/tmp/metadata 文件中<code>la-size-sect</code>的大小信息。注：这里 la-size-sect 指定的是扇区数量</p></li><li><p>重新初始化元数据区域</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm create-md &lt;resource&gt;</span><br></pre></td></tr></table></figure><ul><li>分别在两个节点上重新导入修正的元数据</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 此处使用bash脚本，需要确认可用性</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> drbdmeta_cmd=$(drbdadm -d dump-md &lt;resource&gt;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$&#123;drbdmeta_cmd/dump-md/restore-md&#125;</span> /tmp/metadata</span></span><br><span class="line">Valid meta-data in place, overwrite? [need to type 'yes' to confirm]</span><br><span class="line">yes</span><br><span class="line">Successfully restored meta data</span><br></pre></td></tr></table></figure><ul><li>重新启用 DRBD 资源</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm up &lt;resource&gt;</span><br></pre></td></tr></table></figure><h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><h3 id="查看元数据"><a href="#查看元数据" class="headerlink" title="查看元数据"></a>查看元数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> down 掉drbd</span></span><br><span class="line">[root@Storage ~]# drbdadm down drbds2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看元数据出错</span></span><br><span class="line">[root@Storage ~]# drbdadm dump-md drbds2</span><br><span class="line">Found meta data is "unclean", please apply-al first</span><br><span class="line">Command 'drbdmeta 2 v08 /dev/StorPool1/SANLun2 internal dump-md' terminated with exit code 255</span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂时不明白这句操作的含义，待查</span></span><br><span class="line">[root@Storage ~]# drbdadm apply-al drbds2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看meata-data</span></span><br><span class="line">[root@Storage ~]# drbdadm dump-md drbds2</span><br><span class="line"><span class="meta">#</span><span class="bash"> DRBD meta data dump</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2018-08-29 01:48:20 +0800 [1535478500]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Storage&gt; drbdmeta 2 v08 /dev/StorPool1/SANLun2 internal dump-md</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"></span><br><span class="line">version "v08";</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> md_size_sect 136</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> md_offset 1073737728</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> al_offset 1073704960</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bm_offset 1073672192</span></span><br><span class="line"></span><br><span class="line">uuid &#123;</span><br><span class="line">    0xDDB03F0DAF07DEDC; 0x0000000000000000; 0xE4689A94FBB0E78B; 0xE4679A94FBB0E78B;</span><br><span class="line">    flags 0x00000000;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> al-extents 1237;</span></span><br><span class="line">la-size-sect 2097016;</span><br><span class="line">bm-byte-per-bit 4096;</span><br><span class="line">device-uuid 0x625F486D2CB120D1;</span><br><span class="line">la-peer-max-bio-size 1048576;</span><br><span class="line">al-stripes 1;</span><br><span class="line">al-stripe-size-4k 8;</span><br><span class="line"><span class="meta">#</span><span class="bash"> bm-bytes 32768;</span></span><br><span class="line">bm &#123;</span><br><span class="line"><span class="meta">   #</span><span class="bash"> at 0kB</span></span><br><span class="line">    4096 times 0x0000000000000000;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> bits-set 0;</span></span><br></pre></td></tr></table></figure><p>从此命令中可以获知不同标记代数的 uuid 值，以及 metadata 的元数据信息，例如 md_size_sect=1951744 表示元数据所在分区占用了 1951744 个扇区。注意，该命令不要在 drbd 设备已启动的情况下执行。</p><p>知道这两个命令可以获取一些信息后，现在我们要做的是计算 metadata 部分的数据大小。这个大小在”修改 drbd 设备空间大小”时有用。</p><p>首先获取元数据所在分区的扇区数。即上面结果中的”md_size_sect”。不过也可以使用块设备工具 blockdev 来获取。</p><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><ul><li><a href="https://docs.linbit.com/docs/users-guide-8.4/#s-metadata" target="_blank" rel="noopener">16.1. DRBD meta data</a></li><li><a href="https://www.wenzizone.cn/2009/10/29/drbd%E4%B8%ADmetadata%E7%9A%84%E7%90%86%E8%A7%A3%E5%8E%9F%E5%88%9B.html" target="_blank" rel="noopener">原创 | drbd 中 metadata 的理解</a></li><li><a href="https://blog.csdn.net/yuanhangq220/article/details/46634249" target="_blank" rel="noopener">drbd 配置简述</a></li><li><a href="http://www.cnblogs.com/f-ck-need-u/p/8678883.html" target="_blank" rel="noopener">drbd(二)：配置和使用 - 骏马金龙 - 博客园</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DRBD </tag>
            
            <tag> 存储 </tag>
            
            <tag> meta-data </tag>
            
            <tag> 元数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRBD 用户手册之命令篇</title>
      <link href="/blog/2018-06-22/commonds-of-drbd/"/>
      <url>/blog/2018-06-22/commonds-of-drbd/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文基于<code>DRBD-8.4</code>版编写。<br><a id="more"></a></p><h1 id="drbd-conf-配置文件"><a href="#drbd-conf-配置文件" class="headerlink" title="drbd.conf-配置文件"></a>drbd.conf-配置文件</h1><p>TODO</p><h1 id="drbdmeata-元数据"><a href="#drbdmeata-元数据" class="headerlink" title="drbdmeata-元数据"></a>drbdmeata-元数据</h1><p>TODO</p><h1 id="drbd"><a href="#drbd" class="headerlink" title="drbd"></a>drbd</h1><p>TODO</p><h1 id="drbdadm-管理工具"><a href="#drbdadm-管理工具" class="headerlink" title="drbdadm-管理工具"></a>drbdadm-管理工具</h1><h2 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h2><p>drbdadm - <code>DRBD</code>管理工具</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drbdadm [-d] [-c &#123; file&#125;] [-t &#123;file&#125;] [-s &#123;cmd&#125;] [-m &#123; cmd&#125;] [-S] [-h &#123;host&#125;] [-- &#123; backend-options&#125;] &#123;command&#125; [&#123;all&#125; | &#123; resource[/volume&gt;]...&#125;]</span><br></pre></td></tr></table></figure><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>Drbdadm</code>是<code>DRBD</code>程序套件的高级工具。 <code>Drbdadm</code>与<code>drbdsetup</code>和<code>drbdmeta</code>的关系可类比于 <code>ifup / ifdown</code>与<code>ifconfig</code> 。 <code>Drbdadm</code>通过调用<code>drbdsetup</code>和（或）<code>drbdmeta</code>程序读取相关配置文件并执行指定的命令。<br><code>Drbdadm</code>可以运行整个资源或资源中的单个卷。 子命令： <code>attach</code> ， <code>detach</code> ， <code>primary</code> ， <code>secondary</code>， <code>invalidate</code> ， <code>invalidate-remote</code> ， <code>outdate</code> ， <code>resize</code> ， <code>verify</code> ， <code>pause-sync</code> ， <code>resume-sync</code> ， <code>role</code> ， <code>cstate</code> ， <code>dstate</code> ， <code>create-md</code> ， <code>show-gi</code> ， <code>get-gi</code> ， <code>dump-md</code> ， <code>wipe-md</code>可以作用于整个资源和单个卷上。<br>仅限资源级别的命令有：<code>connect</code>, <code>disconnect</code>, <code>up</code>, <code>down</code>, <code>wait-connect</code> 和 <code>dump</code> 。</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul><li>-d ，– dry-run</li></ul><p>仅将<code>drbdsetup</code>的调用打印到<code>stdout</code>，但不会运行这些命令。</p><ul><li>-c ，– config-file 文件</li></ul><p>指定<code>drbdadm</code>将使用的配置文件。 如果未指定此参数，则<code>drbdadm</code>将查找<code>/etc/drbd-84.conf</code>、<code>/etc/drbd-83.conf</code>、<code>/etc/drbd-08.conf</code>和<code>/etc/drbd.conf</code> 。</p><ul><li>-t ，– config-to-test 文件</li></ul><p>指定一个额外的<code>drbdadm</code>检查文件。 该选项仅适用于<code>dump</code>和<code>sh-nop</code>命令。</p><ul><li>-s ，– drbdsetup 文件</li></ul><p>指定<code>drbdsetup</code>程序的完整路径。 如果省略此选项，<code>drbdadm</code>将首先内部查找它，然后在<code>PATH</code>环境变量中查找它。</p><ul><li>-m ，– drbdmeta 文件</li></ul><p>指定<code>drbdmeta</code>程序的完整路径。 如果省略此选项，<code>drbdadm</code>将首先内部查找它，然后在<code>PATH</code>中查找它。</p><ul><li>-S ， –stacked</li></ul><p>指定应该在堆叠资源上执行此命令。</p><ul><li>-P ， –peer</li></ul><p>指定要连接的对等节点。 只有当您正在使用的资源中有两个以上的主机时才需要此选项。</p><ul><li>后端配置选项</li></ul><p>双连字符（–）后面的所有选项都被视为后端选项。这些选项会传递给后端命令。 即<code>drbdsetup</code>、<code>drbdmeta</code>或<code>drbd-proxy-ctl</code> 。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul><li>attach</li></ul><p>将本地支持块设备连接到 DRBD 资源的设备。</p><ul><li>detach</li></ul><p>从 DRBD 资源的设备中删除备份存储设备。</p><ul><li>connect</li></ul><p>建立资源设备的网络配置。 如果对等设备已配置，则两个<code>DRBD</code>设备将连接。 如果资源中有两个以上的主机部分，则需要使用<code>--peer</code>选项来选择要连接的对等端。</p><ul><li>disconnect</li></ul><p>从资源中删除网络配置。 设备将进入<code>StandAlone</code>状态。</p><ul><li>syncer（注：<code>drbdadm --help</code> 未发现该命令）</li></ul><p>将重新同步参数加载到设备中。</p><ul><li>up</li></ul><p>是<code>attach</code>、<code>syncer</code>和 <code>connect</code>的快捷方式。</p><p>实际上，可以将<code>drbdadm up</code>拆分为以下几个动作：</p><ol><li><p>将 drbd 的资源关联到底层设备(metadata 和 data 区)上，使之能通过底层设备存、取数据。该过程调用的是 drbdsetup 程序。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drbdadm attach drbd1</span><br></pre></td></tr></table></figure></li><li><p>加载 drbd 资源的同步参数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drbdadm syncer drbd1</span><br></pre></td></tr></table></figure></li><li><p>连接对端。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drbdadm connect drbd1</span><br></pre></td></tr></table></figure></li></ol><p>这些命令在<code>drbdadm</code>中部分已弃用，放在这里只是为了说明<code>up</code>时所执行的几个步骤。</p><ul><li>down</li></ul><p>是<code>disconnect</code> 和 <code>detach</code>的捷径。</p><ul><li>primary</li></ul><p>将资源设备转化为主要角色。 您需要在访问设备之前执行此操作，如创建或挂载文件系统。</p><ul><li>secondary</li></ul><p>将设备转回次要角色。 这是必需的，因为在连接状态的 DRBD 设备对中，两个节点中只能有一个节点是主端（除非在配置文件中明确设置了<strong>allow-two-primaries</strong> ）。</p><ul><li>invalidate</li></ul><p>强制 DRBD 将本地存储设备上的数据视为不同步（out-of-sync）。 因此，DRBD 将复制其对等体中的每个块，以使本地存储设备重新同步。 为避免竞争，你需要建立了的复制链接，或断开连接的次端。</p><ul><li>invalidate-remote</li></ul><p>该命令类似于<code>invalidate</code>命令，但是是对等端的备份存储被视为无效，因此对端被本地节点的数据重写。 为避免竞争，您需要已建立的复制链接，或断开连接的主端。</p><ul><li>resize</li></ul><p><code>DRBD</code>重新检查所有大小限制，并相应调整资源的设备大小。 例如，如果您增加了备份存储设备的大小（当然是在两个节点上均进行次操作），那么在您的某个节点上调用此命令后，DRBD 将采用新的大小。 由于必须同步新的存储空间，因此只有存在至少一个主节点时，此命令才可用。<br><code>--size</code>选项可用于联机缩小<code>drbd</code>设备的可用大小。 用户必须负责确保设备上的文件系统不被该操作截断。<br><code>--assume-peer-have-space</code>允许你调整当前未连接到对等设备的设备。 使用时需要小心，因为如果您不重新调整对等磁盘的大小，则两者的进一步连接尝试将失败。<br><code>--assume-clean</code>允许您调整现有设备的大小并避免同步新的空间。 将附加空白存储添加到设备时，这样操作非常有用。 例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># drbdadm -- --assume-clean resize r0</span><br></pre></td></tr></table></figure></p><p>选项<code>-al-stripes</code>和<code>--al-stripe-size-kB</code>可用于在线更改 <code>activity log</code>的布局。 在使用内部元数据的情况下，这可能会同时缩小用户可见大小（使用<code>--size</code> ）或增加后备设备上的可用空间。</p><ul><li>check-resize</li></ul><p>调用<code>drbdmeta</code>达到移动内部元数据的目的。 如果后台设备的大小已调整，而<code>DRBD</code>未运行，则必须将元数据移至设备的末尾，以便接下来的 <code>attach</code> 命令可以成功。</p><ul><li>create-md</li></ul><p>初始化元数据存储。 这需要在<code>DRBD</code>资源首次上线之前完成。 如果有关于该命令的问题请看<a href="https://docs.linbit.com/man/v84/drbdmeta-8/" target="_blank" rel="noopener">drbdmeta</a></p><ul><li>get-gi</li></ul><p>显示数据生成标识符(<code>GI元祖</code>)的简短文字表示。</p><ul><li>show-gi</li></ul><p>打印包含说明信息的数据生成标识符的文本表示。</p><ul><li>dump-md</li></ul><p>以文本形式转储元数据存储的全部内容，包括存储的位图和活动日志。</p><ul><li>outdate</li></ul><p>设置元数据中的过期标志。</p><ul><li>adjust</li></ul><p>将设备的配置与你的配置文件同步。 在实际执行此命令之前，应始终检查<code>dry-run</code>模式的输出。</p><ul><li>wait-connect</li></ul><p>等待设备连接到对等设备。</p><ul><li>role</li></ul><p>显示设备的当前角色（local/peer）。 例如：<code>Primary/Secondary</code></p><ul><li>state</li></ul><p>不赞成使用（废止），“角色”的别名，参见上文。</p><ul><li>cstate</li></ul><p>显示设备的当前连接状态。如：Connected、StandAlone 等</p><ul><li>dump</li></ul><p>解析配置文件并将其转储到<code>stdout</code>。 可用于检查配置文件的语法正确性。</p><ul><li>outdate</li></ul><p>用于将节点的数据标记为过时。 通常由对等方的 fence-peer 处理程序使用。</p><ul><li>verify</li></ul><p>开始在线验证。 在线验证期间，比较两个节点上的数据是否相等。 请参阅<code>/proc/drbd</code>进行在线验证。 如果发现不同步块，则它们不会自动重新同步。因此，请在验证完成后使用<code>disconnect</code> 和<code>connect</code>断开并连接资源。<br>另请参阅<code>drbd.conf</code>联机帮助页上有关数据完整性的注意事项。</p><ul><li>pause-sync</li></ul><p>通过设置本地暂停标志暂时中止正在进行的重新同步。 如果本地和远程暂停标志均未设置，则同步进行。 可能需要推迟<code>DRBD</code>的重新同步到支持存储的<code>RAID</code>设置重新同步之后进行。</p><ul><li>resume-sync</li></ul><p>取消设置本地同步暂停标志。</p><ul><li>new-current-uuid</li></ul><p>生成新的<code>当前 UUID</code>并旋转所有其他 UUID 值。<br>这可以用来缩短集群的初始再同步。 有关更多详细信息，请参阅<code>drbdsetup</code>联机帮助页。</p><ul><li>dstate</li></ul><p>以<code>local/peer</code>形式显示后备存储设备的当前状态。 如：UpToDate/UpToDate</p><ul><li>hidden-commands</li></ul><p>显示所有命令没有记录的命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[root@imoyao ~]# drbdadm hidden-commands</span><br><span class="line"></span><br><span class="line">These additional commands might be useful for writing   # 写脚本或许有用</span><br><span class="line">nifty shell scripts around drbdadm:</span><br><span class="line"></span><br><span class="line"> sh-nop                             sh-resources                       </span><br><span class="line"> sh-resource                        sh-mod-parms                       </span><br><span class="line"> sh-dev                             sh-udev                            </span><br><span class="line"> sh-minor                           sh-ll-dev                          </span><br><span class="line"> sh-md-dev                          sh-md-idx                          </span><br><span class="line"> sh-ip                              sh-lr-of                           </span><br><span class="line"> sh-b-pri                           sh-status                          </span><br><span class="line"> proxy-up                           proxy-down                         </span><br><span class="line"> new-resource                       </span><br><span class="line"></span><br><span class="line">These commands are used by the kernel part of DRBD to   # drbd内核</span><br><span class="line">invoke user mode helper programs:</span><br><span class="line"></span><br><span class="line"> before-resync-target               after-resync-target                </span><br><span class="line"> before-resync-source               pri-on-incon-degr                  </span><br><span class="line"> pri-lost-after-sb                  fence-peer                         </span><br><span class="line"> local-io-error                     pri-lost                           </span><br><span class="line"> initial-split-brain                split-brain                        </span><br><span class="line"> out-of-sync                        </span><br><span class="line"></span><br><span class="line">These commands ought to be used by experts and developers:  # 开发人员</span><br><span class="line"></span><br><span class="line"> sh-new-minor                       new-minor                          </span><br><span class="line"> suspend-io                         resume-io                          </span><br><span class="line"> set-gi                             new-current-uuid                   </span><br><span class="line"> check-resize</span><br></pre></td></tr></table></figure><h1 id="drbddisk-8"><a href="#drbddisk-8" class="headerlink" title="drbddisk.8"></a>drbddisk.8</h1><p>TODO</p><h1 id="drbdsetup-8-配置内核模块"><a href="#drbdsetup-8-配置内核模块" class="headerlink" title="drbdsetup.8-配置内核模块"></a>drbdsetup.8-配置内核模块</h1><p>TODO</p><h1 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h1><p>本文档针对 DRBD 发行版本 8.4.0 进行了修订。</p><h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>由 Philipp Reisner <a href="mailto:&#x70;&#x68;&#x69;&#x6c;&#105;&#112;&#112;&#46;&#114;&#101;&#105;&#115;&#110;&#x65;&#114;&#x40;&#x6c;&#105;&#110;&#x62;&#105;&#x74;&#46;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#x70;&#x68;&#x69;&#x6c;&#105;&#112;&#112;&#46;&#114;&#101;&#105;&#115;&#110;&#x65;&#114;&#x40;&#x6c;&#105;&#110;&#x62;&#105;&#x74;&#46;&#x63;&#111;&#109;</a>和 Lars Ellenberg 撰写<a href="mailto:&#108;&#x61;&#x72;&#115;&#46;&#101;&#108;&#x6c;&#101;&#x6e;&#x62;&#101;&#x72;&#103;&#64;&#x6c;&#105;&#x6e;&#x62;&#105;&#x74;&#x2e;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#108;&#x61;&#x72;&#115;&#46;&#101;&#108;&#x6c;&#101;&#x6e;&#x62;&#101;&#x72;&#103;&#64;&#x6c;&#105;&#x6e;&#x62;&#105;&#x74;&#x2e;&#x63;&#111;&#109;</a>。中译版由<code>imoyao</code>首发于别院牧志（<code>idealyard</code>）</p><h1 id="报告错误"><a href="#报告错误" class="headerlink" title="报告错误"></a>报告错误</h1><p>将错误报告给<a href="mailto:&#x64;&#x72;&#98;&#x64;&#45;&#117;&#x73;&#x65;&#114;&#x40;&#x6c;&#105;&#x73;&#x74;&#x73;&#46;&#x6c;&#105;&#110;&#98;&#105;&#116;&#46;&#99;&#111;&#109;" target="_blank" rel="noopener">&#x64;&#x72;&#98;&#x64;&#45;&#117;&#x73;&#x65;&#114;&#x40;&#x6c;&#105;&#x73;&#x74;&#x73;&#46;&#x6c;&#105;&#110;&#98;&#105;&#116;&#46;&#99;&#111;&#109;</a>。</p><h1 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h1><p>版权所有 2001-2011 LINBIT 信息技术公司，Philipp Reisner，Lars Ellenberg。 这是免费软件; 请参阅复制条件的来源。 没有保修; 甚至不适用于适销性或针对特定用途的适用性。</p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p>drbd.conf （5）， drbd （8）， drbddisk （8）， drbdsetup （8）， drbdmeta （8）和 DRBD 项目网站 [1]</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://docs.linbit.com/man/v84/" target="_blank" rel="noopener">DRBD 8.4 Manual Pages</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DRBD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 DRBD 裂脑问题的总结</title>
      <link href="/blog/2018-05-27/Split-Brain-Of-DRBD/"/>
      <url>/blog/2018-05-27/Split-Brain-Of-DRBD/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>裂脑一旦发生，需要及时排查问题所在，最大限度保护数据完整性。<br><a id="more"></a></p><h2 id="什么是DRBD裂脑"><a href="#什么是DRBD裂脑" class="headerlink" title="什么是DRBD裂脑"></a>什么是<code>DRBD</code>裂脑</h2><p>裂脑(<code>split brain</code>)实际上是指在某种情况下，由集群节点间的网络连接临时故障、集群软件管理干预或者是人为错误，导致两个节点都切换为主节点（<code>primary</code>）而断开连接。这种状态是一个潜在的有害状态，因为它意味着不能复制数据到对等节点，这样就可能导致两个节点的数据产生分歧，产生不可合并的分裂。</p><h2 id="怎么判定裂脑"><a href="#怎么判定裂脑" class="headerlink" title="怎么判定裂脑"></a>怎么判定裂脑</h2><h3 id="查看日志信息"><a href="#查看日志信息" class="headerlink" title="查看日志信息"></a>查看日志信息</h3><p>如果<code>DRBD</code>出现裂脑，会在 <code>/var/log/message</code> 出现一条日志：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Split-Brain detected but unresolved, dropping connection!</span><br></pre></td></tr></table></figure><p>当发生<code>split brain</code>之后，如果查看连接状态，其中至少会有一个是<code>StandAlone</code>状态，另外一个可能也是<code>StandAlone</code>（如果是同时发现<code>split brain</code>状态），也有可能是 <code>WFConnection</code> 状态。</p><h3 id="裂脑自动通知"><a href="#裂脑自动通知" class="headerlink" title="裂脑自动通知"></a>裂脑自动通知</h3><p>如果进行配置，DRBD 会调用裂脑处理程序，当裂脑发生时就会被探测到。要配置这个程序，需要对资源<code>/etc/drbd.d/global_common.conf</code>添加如下配置：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resource &lt;resource&gt;</span><br><span class="line"></span><br><span class="line">  handlers &#123;</span><br><span class="line"></span><br><span class="line">    split-brain &lt;handler&gt;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>&lt;handler&gt;</code>可能是目前系统中一个可执行的文件。</p><p><code>Drbd</code>自带一个裂脑处理程序脚本<code>/usr/lib/drbd/notify-split-brain.sh</code>。它可以通过电子邮件的方式发送到指定的地址。要配合程序发送信息到 root@localhost（这假设是设置的系统管理员的邮件地址），配置如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resource &lt;resource&gt;</span><br><span class="line"></span><br><span class="line">  handlers &#123;</span><br><span class="line"></span><br><span class="line">    split-brain "/usr/lib/drbd/notify-split-brain.sh root";</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当配置已经在资源上进行修改（同步到两个节点上），就不需要添加其他的处理就可以启动处理程序。<code>DRBD</code>会在下一次检测到裂脑时直接调用该处理程序。</p><p>如果要配置真实可用的报警邮箱地址，则除了将上面的通知地址改为真实邮件地址:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">split-brain "/usr/lib/drbd/notify-split-brain.sh foo@bar.com</span><br></pre></td></tr></table></figure></p><p>还需要修改一下<code>ssmtp</code>配置文件：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/ssmtp/ssmtp.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 填写真实收件服务器信息</span></span><br><span class="line">mailhub=mail.masantu.com:25</span><br></pre></td></tr></table></figure></p><p>更多配置参见 <a href="http://iqjar.com/jar/sending-emails-from-the-raspberry-pi/" target="_blank" rel="noopener">这里</a></p><h3 id="世代标识符元组（GI）"><a href="#世代标识符元组（GI）" class="headerlink" title="世代标识符元组（GI）"></a>世代标识符元组（GI）</h3><p>参见<a href="https://docs.linbit.com/docs/users-guide-8.4/#s-gi" target="_blank" rel="noopener">16.2. Generation Identifiers</a></p><p>DRBD 将其备份的数据的更新变化过程比拟成人类世代繁衍的过程。每个时点同一个双机的 DRBD 的两个节点上的数据都来自于同一份原始数据，我们可认为这个时点上两份数据源于同一祖先。主备节点的 DRBD 都会用一个叫作 GI(Generation ID)的标识符来标识当前的数据是哪个世代的，同样也会记录最近两个数据祖先的 GI 用于追朔当前数据的历史来源。DRBD 可以据此来判断两个节点是否是属于同一个双机,因为同一个双机的两份数据应该是从同一个祖先而来。<br>GI 作为 DRBD 的内部机制主要被用来：</p><ol><li>确定这两个节点是否是事实上的同一个集群的成员（而不是意外连接的两个节点）；</li><li>确定触发全盘同步（<code>full re-synchronization</code>）还是只触发部分同步（<code>partial re-synchronization</code>）。</li><li>确定后台重新同步的方向（如果需要全盘同步）；</li><li>确定裂脑。</li></ol><h4 id="数据迭代"><a href="#数据迭代" class="headerlink" title="数据迭代"></a>数据迭代</h4><p>当出现下列情形里<code>DRBD</code>会生成一个新的<code>GI</code>，用来标识新一代的数据：</p><ol><li>第一次全盘同步时；</li><li>一个<code>Disconnected</code>的资源转换为<code>Primary</code>时；</li><li>一个<code>Primary</code>的资源转换为<code>Disconnected</code>时。</li></ol><p>因此,我们可以总结出：只要一个<code>DRBD</code>资源处于<code>Connected</code>的状态，并且两边磁盘的状态为<code>UpToDate</code>，那么此<code>DRBD</code>资源在两个节点上的<code>GI</code>一定是一样的。此结论反过来也同样成立。请注意，<strong>当前实现使用最低位来编码节点的角色(<code>Primary/Secondary</code>)。 因此，即使它们被认为具有相同的数据生成，最低位在不同节点上也可能不同。</strong></p><p>每个新的数据生成都由一个<code>8</code>字节的通用唯一标识符（<code>UUID</code>）来标识。</p><h4 id="GI元祖"><a href="#GI元祖" class="headerlink" title="GI元祖"></a><code>GI</code>元祖</h4><p><code>DRBD</code>在本地资源元数据中保存有关当前和历史数据生成的四条信息：</p><ul><li><p>当前<code>UUID(C-UUID)</code><br>从本地节点的角度来看，这是当前数据生成的生成标识符。 当资源被连接并完全同步时，当前<code>UUID</code>在节点之间是相同的。</p></li><li><p>位图<code>UUID(B-UUID)</code><br>这是磁盘上同步位图跟踪的生成的<code>UUID</code>更改。 作为磁盘上的同步位图本身，此标识符仅在断开模式下才有用。 如果资源已连接，则此<code>UUID</code>始终为空（零）。</p></li><li><p>两个<code>历史UUID</code></p></li></ul><p>这些是当前之前两个数据世代的标识符。</p><ol><li>上一代数据的<code>UUID(H1-UUID)</code>；</li><li>最近第二代数据的<code>UUID(H2-UUID)</code>，即上一代数据的上一代数据的<code>UUID</code>。</li></ol><p>总的来说，这四个项目被称为代码标识符元组，或简称为<code>GI元组</code>。</p><h4 id="GI如何变化"><a href="#GI如何变化" class="headerlink" title="GI如何变化"></a><code>GI</code>如何变化</h4><ul><li>开始新的数据生成代</li></ul><p>当节点与其对等方失去连接时（网络故障或人工干预都有可能），DRBD 将按照以下方式修改其本地生成标识符：</p><p><img src="https://docs.linbit.com/ug-src/users-guide-8.4/images/gi-changes-newgen.png" alt="图1 GI元祖在生成新的数据代时改变"></p><ol><li>为新的数据代生成新的<code>UUID</code>，变为主节点的<code>C-UUID</code>；</li><li>之前的 UUID 现在指向位图（<code>B-UUID</code>）以跟踪数据变化，因此它成为主节点的新位图<code>UUID</code>；</li><li>备节点 GI 元祖保持不变。</li></ol><ul><li>开始重新同步</li></ul><p>在开始重新同步时，<code>DRBD</code>在本地代标识符上执行如下修改：</p><p><img src="https://docs.linbit.com/ug-src/users-guide-8.4/images/gi-changes-syncstart.png" alt="图2 GI元祖在重新开始同步是改变"></p><ol><li>在同步源端的<code>当前UUID</code>（C-UUID）保持不变；</li><li>同步源端的<code>位图UUID</code>轮转为<code>第一历史UUID</code>（H1-UUID）；</li><li>同步源端生成新的<code>位图UUID</code>（B-UUID）;</li><li>该 UUID（<em>应指同步源端生成的<code>B-UUID</code></em>）变为同步目标端的新的<code>当前UUID</code>（C-UUID）；</li><li>同步目标端的<code>位图UUID</code>（B-UUID）和<code>历史UUID</code>（H1-UUID,H2-UUID）保持不变。</li></ol><ul><li>重新同步结束</li></ul><p>当重新同步结束后，将执行以下更改：</p><p><img src="https://docs.linbit.com/ug-src/users-guide-8.4/images/gi-changes-synccomplete.png" alt="图3 当重新同步结束后，GI元祖发生改变"></p><ol><li>同步源端<code>当前UUID</code>(C-UUID)保持不变；</li><li>同步源端的<code>位图UUID</code>(B-UUID)轮转为<code>第一历史UUID</code>（H1-UUID），同时该 UUID(指<code>H1-UUID</code>)轮转为<code>第二历史UUID</code>(现有的第二历史 uuid 被丢弃)；</li><li>同步源端的<code>位图UUID</code>(B-UUID)清空（置零）；</li><li>同步目标端采用同步源端整个<code>GI元祖</code>。</li></ol><p>当节点之间建立连接之后，两个节点之间会交换当前可用的代标识符,然后根据比对的结果采取相应的操作。以下是可能的几种结果：</p><ul><li>两个节点上的当前<code>UUID(C-UUID)</code>都为空</li></ul><p>本地节点检测到它的当前<code>UUID</code>和对方的当前<code>UUID</code>都是空的。这通常是发生于尚未启动初始完全同步的新配置资源的正常情况。此时没有同步发生;须手动人为触发启动。</p><ul><li>单一节点上的当前<code>UUID(C-UUID)</code>为空</li></ul><p>本地节点检测到对方的当前<code>UUID</code>为空，而其本身非空。这是新配置资源的正常情况，此时初始全盘同步刚刚触发，本地节点被选为初始同步源（<code>sync source</code>）。 <code>DRBD</code>将磁盘上的同步位图(<code>sync bitmap</code>)中的所有位全部置位（意味着它认为整个设备不同步），并开始将其作为同步源同步。相反，（即本地当前<code>UUID</code>为空，对等节点非空），除了本地节点成为同步目标（<code>sync target</code>）之外，<code>DRBD</code>执行相同的步骤。</p><ul><li>当前<code>UUID(C-UUID)</code>相等</li></ul><p>本地节点检测到它的当前<code>UUID</code>和对等节点的当前<code>UUID</code>非空且相等时。这是资源在<code>secondary</code>状态进入断开连接（<code>disconnected</code>）模式时的正常情况，并且在断开连接时并未在任一节点上升为 <code>primary</code> 状态。此时不会触发同步，因为两边的数据一致，没有必要。</p><ul><li>位图<code>UUID（B-UUID）</code>匹配对等节点的当前<code>UUID（`C-UUID`）</code></li></ul><p>本地节点检测到其位图<code>UUID</code>匹配对等节点的当前<code>UUID</code>，且对等节点的位图<code>UUID</code>为空。这是本地节点处于 <code>primary</code> 状态，次要节点故障后正常且预期的情况。这意味着对端在此期间永远不会变为<code>primary</code>状态，并始终以相同的数据生成为前提运行。 <code>DRBD</code>此时以本地节点作为同步源（<code>sync source</code>）启动正常的后台重新同步（<code>re-sync</code>）。相反，如果本地节点检测到其位图<code>UUID</code>为空，且对等节点的位图与本地节点的当前<code>UUID</code>匹配，那么这是本地节点失败后的正常和预期情况。同样地，<code>DRBD</code>此时启动正常的后台重新同步，只不过本地节点成为同步目标（<code>sync target</code>）。</p><ul><li>当前<code>UUID(C-UUID)</code>匹配对等节点的历史<code>UUID（h-UUID）</code></li></ul><p>本地节点检测到其当前<code>UUID</code>与对等节点的历史<code>UUID</code>之一(<code>h1/h2</code>)匹配。这意味着尽管两个数据集共享一个共同的祖先且对等节点具有最新的数据，但保存在对等节点的位图中的信息已过时并且不可用。因此，简单的正常同步不够的。 <code>DRBD</code>此时将整个设备标记为未同步（<code>out-of-sync</code>）并启动以本地节点作为同步目标（<code>sync target</code>）的全盘后台重新同步。在相反的情况下（本地节点的某个历史<code>UUID</code>与对等节点的当前<code>UUID</code>相匹配），除了本地节点成为同步源（<code>sync source</code>）之外，<code>DRBD</code>执行相同的步骤。</p><ul><li>位图<code>UUID（B-UUID）</code>匹配，当前 <code>UUID(C-UUID)</code>不匹配</li></ul><p>本地节点检测到其当前<code>UUID</code>与对等节点的当前<code>UUID</code>不同且位图<code>UUID</code>匹配。这是裂脑（<code>split brain</code>）的一种情况，两份数据有相同的父代。这意味着<code>DRBD</code>可以调用裂脑自动恢复策略进行数据恢复（如果已配置）。否则，<code>DRBD</code>断开连接并等待手动恢复。</p><ul><li>当前<code>UUID（C-UUID）</code>和位图<code>UUID(B-UUID)</code>都不匹配</li></ul><p>本地节点检测到它的当前<code>UUID</code>与对等节点的当前<code>UUID</code>不同，并且位图<code>UUID</code>不匹配。这是两份数据与无关父代产生的一种裂脑，因此即使配置了自动恢复策略也没有意义。 <code>DRBD</code>处于断开连接并等待手动恢复状态。</p><ul><li>没有<code>UUID</code>匹配</li></ul><p>最后，如果<code>DRBD</code>未能检测到两个节点之间的<code>GI</code>元组中的单个元素匹配，则会记录关于无关数据（<code>unrelated data</code>）的警告并断开连接。这是<code>DRBD</code>的防范措施，可防止之前无关联的两个集群节点的意外连接导致数据破坏。</p><p>以上逻辑使用代码表示如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">empty_uuid = <span class="string">'0000000000000000'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slice_seq</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    对GI元祖内元素进行切片操作</span></span><br><span class="line"><span class="string">    :param seq: GI元祖</span></span><br><span class="line"><span class="string">    :return:type:list</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">global</span> empty_uuid</span><br><span class="line">    sliced_seq = [item[:<span class="number">-1</span>] <span class="keyword">if</span> item != empty_uuid <span class="keyword">else</span> item <span class="keyword">for</span> item <span class="keyword">in</span> seq]</span><br><span class="line">    <span class="keyword">return</span> sliced_seq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmp_both</span><span class="params">(seqa,seqb)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> seqa:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seqb:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_gi_action</span><span class="params">(drbdname)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    调用'drbdadm get-gi DRBDNAME'命令获取drbd的 GI(Generation ID) 信息</span></span><br><span class="line"><span class="string">    :param drbdname:type:str,drbd名称 like:'drbds1/drbdn301'</span></span><br><span class="line"><span class="string">    :return:获取正常返回元祖(c_uuid, b_uuid, h1_uuid, h2_uuid)，获取失败返回None</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    get_gi_cmd = <span class="string">"drbdadm get-gi %s |awk -F: '&#123;print $1,$2,$3,$4&#125;'"</span>%(drbdname)</span><br><span class="line">    retcode,proc = utils.cust_popen(get_gi_cmd)</span><br><span class="line">    message = proc.stderr.read(), proc.stdout.read()</span><br><span class="line">    retstr = message[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> retstr:</span><br><span class="line">        c_uuid,b_uuid,h1_uuid,h2_uuid = tuple(retstr.split())</span><br><span class="line">        <span class="keyword">return</span> c_uuid,b_uuid,h1_uuid,h2_uuid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        debug.write_debug(debug.LINE(), <span class="string">"peradrbd"</span>, message)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">  </span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_remote_gi</span><span class="params">(params)</span>:</span></span><br><span class="line">    rtndata = &#123;&#125;</span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    drbdname = <span class="string">'drbdname'</span> <span class="keyword">in</span> params <span class="keyword">and</span> params[<span class="string">'drbdname'</span>] <span class="keyword">or</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> drbdname:</span><br><span class="line">        <span class="keyword">if</span> hasthedrbd(drbdname):</span><br><span class="line">            gi_uuids = get_gi_action(drbdname)</span><br><span class="line">            <span class="keyword">if</span> gi_uuids <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                rtndata[<span class="string">'state'</span>] = <span class="string">'0'</span></span><br><span class="line">                result[<span class="string">'message'</span>] = <span class="string">''</span></span><br><span class="line">                result[<span class="string">'gi_id'</span>] = gi_uuids</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rtndata[<span class="string">'state'</span>] = <span class="string">'1'</span></span><br><span class="line">                result[<span class="string">'message'</span>] = <span class="string">'11069'</span>     <span class="comment"># 获取 gi_id 出错</span></span><br><span class="line">                result[<span class="string">'gi_id'</span>] = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rtndata[<span class="string">'state'</span>] = <span class="string">'1'</span></span><br><span class="line">            result[<span class="string">'message'</span>] = <span class="string">'11060'</span>  <span class="comment"># the drbd not found</span></span><br><span class="line"></span><br><span class="line">        rtndata[<span class="string">'result'</span>] = result</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rtndata = &#123;<span class="string">'state'</span>: <span class="string">'1'</span>, <span class="string">'result'</span>: &#123;<span class="string">'message'</span>: <span class="string">'11059'</span>&#125;&#125;  <span class="comment"># drbdname error</span></span><br><span class="line">    <span class="keyword">return</span> rtndata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange_gi_process</span><span class="params">(drbdname)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    see:https://docs.linbit.com/docs/users-guide-8.4/#s-gi (16.2.4. How DRBD uses generation identifiers)</span></span><br><span class="line"><span class="string">    :param drbdname:</span></span><br><span class="line"><span class="string">    :return:type:str</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    local_gis = get_gi_action(drbdname)</span><br><span class="line">    remote_gis = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">global</span> remoteip</span><br><span class="line">    retresult = hautils.socketclient(ip=remoteip,</span><br><span class="line">                                     **&#123;<span class="string">'target'</span>: <span class="string">'drbd'</span>, <span class="string">'op'</span>: <span class="string">'getremotegi'</span>, <span class="string">'params'</span>: &#123;<span class="string">'drbdname'</span>:drbdname&#125;&#125;)</span><br><span class="line">    <span class="keyword">if</span> retresult:</span><br><span class="line">        <span class="keyword">if</span> retresult[<span class="string">'state'</span>] == <span class="string">'0'</span>:</span><br><span class="line">            remote_gis = retresult[<span class="string">'result'</span>][<span class="string">'gi_id'</span>]</span><br><span class="line">        drbd_next = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> local_gis <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> remote_gis <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            local_gis_sliced = slice_seq(local_gis)</span><br><span class="line">            remote_gis_sliced = slice_seq(remote_gis)</span><br><span class="line">            <span class="keyword">global</span> empty_uuid</span><br><span class="line">            print(<span class="string">'sliced'</span>, local_gis_sliced, remote_gis_sliced)</span><br><span class="line">            <span class="keyword">if</span> local_gis_sliced[<span class="number">0</span>] == empty_uuid <span class="keyword">and</span> remote_gis_sliced[<span class="number">0</span>] == empty_uuid:</span><br><span class="line">                drbd_next = <span class="string">'no_sync:(manual_sync)'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> local_gis_sliced[<span class="number">0</span>] == empty_uuid <span class="keyword">or</span> remote_gis_sliced[<span class="number">0</span>] == empty_uuid:</span><br><span class="line">                <span class="keyword">if</span> remote_gis_sliced[<span class="number">0</span>] == empty_uuid <span class="keyword">and</span> local_gis_sliced[<span class="number">0</span>] != empty_uuid:</span><br><span class="line">                    drbd_next = <span class="string">'full_re_sync:(local_source)'</span></span><br><span class="line">                <span class="keyword">elif</span> local_gis_sliced[<span class="number">0</span>] == empty_uuid <span class="keyword">and</span> remote_gis_sliced[<span class="number">0</span>] != empty_uuid:</span><br><span class="line">                    drbd_next = <span class="string">'full_re_sync:(local_target)'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> local_gis_sliced[<span class="number">0</span>] != empty_uuid <span class="keyword">and</span> remote_gis_sliced[<span class="number">0</span>] != empty_uuid <span class="keyword">and</span> local_gis_sliced[<span class="number">0</span>] == remote_gis_sliced[<span class="number">0</span>]:</span><br><span class="line">                drbd_next = <span class="string">'consistent:(both_secondary)'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> local_gis_sliced[<span class="number">1</span>] == remote_gis_sliced[<span class="number">0</span>] <span class="keyword">and</span> remote_gis_sliced[<span class="number">1</span>] == empty_uuid:</span><br><span class="line">                drbd_next = <span class="string">'partial_re_sync:(local_source)'</span></span><br><span class="line">            <span class="keyword">elif</span> local_gis_sliced[<span class="number">1</span>] == empty_uuid <span class="keyword">and</span> remote_gis_sliced[<span class="number">1</span>] == local_gis_sliced[<span class="number">0</span>]:</span><br><span class="line">                drbd_next = <span class="string">'partial_re_sync:(local_target)'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> local_gis_sliced[<span class="number">0</span>] <span class="keyword">in</span> [remote_gis_sliced[<span class="number">2</span>], remote_gis_sliced[<span class="number">3</span>]]:</span><br><span class="line">                drbd_next = <span class="string">'full_re_sync:(local_target)'</span></span><br><span class="line">            <span class="keyword">elif</span> remote_gis_sliced[<span class="number">0</span>] <span class="keyword">in</span> [local_gis_sliced[<span class="number">2</span>], local_gis_sliced[<span class="number">3</span>]]:</span><br><span class="line">                drbd_next = <span class="string">'full_re_sync:(local_source)'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> local_gis_sliced[<span class="number">0</span>] != remote_gis_sliced[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> local_gis_sliced[<span class="number">1</span>] == remote_gis_sliced[<span class="number">1</span>]:</span><br><span class="line">                    drbd_next = <span class="string">'split_brain:(auto_recover_able)'</span></span><br><span class="line">                <span class="keyword">elif</span> local_gis_sliced[<span class="number">1</span>] != remote_gis_sliced[<span class="number">1</span>]:</span><br><span class="line">                    drbd_next = <span class="string">'split_brain:(wait_for_manual_recover)'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> cmp_both(local_gis_sliced,remote_gis_sliced):</span><br><span class="line">                drbd_next = <span class="string">'unrelated_data:(wait_for_manual_recover)'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                debug.write_debug(debug.LINE(), <span class="string">"peradrbd"</span>, (local_gis_sliced, remote_gis_sliced))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            debug.write_debug(debug.LINE(), <span class="string">"peradrbd"</span>, (local_gis,remote_gis))</span><br><span class="line">        <span class="keyword">return</span> drbd_next</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">**注意**：</span><br><span class="line"></span><br><span class="line">经分析官方文档中的<span class="string">'matches'</span>并不是完全相等，而 <span class="string">'UUID is always empty (zero)'</span> 是指 <span class="string">"'0'*16"</span> 的字符串</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如何模拟一个 `Split-Brain`状态</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 往主节点写入大文件，在未写入完前停止备节点的`DRBD`；</span><br><span class="line">```plain</span><br><span class="line"><span class="comment"># on secondary</span></span><br><span class="line">drbdadm down drbdxx</span><br></pre></td></tr></table></figure><ol start="2"><li><p>停止主节点的<code>DRBD</code>；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># on primary</span><br><span class="line">drbdadm down drbdxx</span><br></pre></td></tr></table></figure></li><li><p>启动备节点的<code>DRBD</code>，设置为主节点；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># on secondary</span><br><span class="line">drbdadm up drbdxx</span><br><span class="line">drbdadm primary drbdxx</span><br></pre></td></tr></table></figure></li><li><p>启动原主节点的<code>DRBD</code>，这时发现它的状态就是<code>StandAlone Secondary/Unknown UpToDate/DUnknown</code>，<code>Split-Brain</code> 情况出现。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># on primary</span><br><span class="line">drbdadm up drbdxx</span><br></pre></td></tr></table></figure></li></ol><h2 id="解决-DRBD-裂脑状态"><a href="#解决-DRBD-裂脑状态" class="headerlink" title="解决 DRBD 裂脑状态"></a>解决 DRBD 裂脑状态</h2><h3 id="设置自动修复"><a href="#设置自动修复" class="headerlink" title="设置自动修复"></a>设置自动修复</h3><p><a href="https://docs.linbit.com/docs/users-guide-8.4/#s-configure-split-brain-behavior" target="_blank" rel="noopener">5.17.2. Automatic split brain recovery policies</a></p><p><strong>警告</strong>：配置<code>DRBD</code>自动修复裂脑（或其他状况）导致的数据分歧情况可能使正在配置的数据丢失，如果你不知道你在干什么，那最好别干。（NO ZUO NO DIE）</p><p>_提示_ ：您更应该查看系统防护策略，集群管理集成和冗余集群管理器通信连接状态，以避免出现数据分歧。（防患于未然而不是亡羊补牢）<br>在启用和配置<code>DRBD</code>的自动裂脑恢复策略之前，您必须了解<code>DRBD</code>为此提供了多种配置选项。 <code>DRBD</code> 根据检测到裂脑时主节点（<code>Primary role</code>）的数量应用其裂脑恢复程序。为此，<code>DRBD</code> 检查以下关键字，这些关键字均可在资源的网络配置部分中找到：</p><h4 id="after-sb-0pri"><a href="#after-sb-0pri" class="headerlink" title="after-sb-0pri"></a>after-sb-0pri</h4><p>裂脑被检测到的同时该资源在任一节点不是主节点。对于这种状况，<code>DRBD</code>可以理解以下关键字：</p><ul><li>disconnect: 不自动恢复，只调用裂脑通知程序（如果已配置），断开连接并保持断开；</li><li>discard-younger-primary: 丢弃并回滚最后升主节点的改动；</li><li>discard-least-changes: 丢弃并回滚修改更少节点的修改；</li><li>discard-zero-changes: 如果有某一节点一点未改动，只需应用对另一主机所做的修改并继续；</li></ul><h4 id="after-sb-1pri"><a href="#after-sb-1pri" class="headerlink" title="after-sb-1pri"></a>after-sb-1pri</h4><p>裂脑刚被检测到的同时该资源在一个节点上是主节点。对于这种状况，<code>DRBD</code>理解以下关键字：</p><ul><li>disconnect:同上</li><li>consensus：应用上一步的策略之后，如果裂脑受害者可以选择拆分则会自动解决。否则，与<code>disconnect</code>指令相同。</li><li>call-pri-lost-after-sb：应用上一步的策略之后，如果裂脑受害者节点可以选择拆分则调用<code>pri-lost-after-sb</code>处理程序，该处理程序必须在处理程序中进行配置，并且需要强制从集群中删除该节点。</li><li>discard-secondary：将从端（<code>Secondary role</code>）节点视为裂脑受害者。</li></ul><h4 id="after-sb-2pri"><a href="#after-sb-2pri" class="headerlink" title="after-sb-2pri"></a>after-sb-2pri</h4><p>裂脑刚被检测到时该资源在两个节点都处于主端。该选项接受与除<code>discard-secondary</code> 和 <code>consensus</code> 之外与 <code>after-sb-1pri</code> 相同的关键字。</p><p>_提示_：<code>DRBD</code>还可以理解这三个选项下额外的关键字，这些关键字在这里被省略，因为它们很少被使用。请参阅<code>drbd.conf</code>的手册页以获取有关裂脑恢复关键字的详细信息，此处不再讨论。<br>例如，用作双主模式下<code>GFS</code>或<code>OCFS2</code>文件系统的块设备的资源可能会将其恢复策略定义如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resource &lt;resource&gt; &#123;</span><br><span class="line">  handlers &#123;</span><br><span class="line">    split-brain "/usr/lib/drbd/notify-split-brain.sh root"      # 脚本通知root用户，此处可以使用邮件提醒</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  net &#123;</span><br><span class="line">    after-sb-0pri discard-zero-changes;</span><br><span class="line">    after-sb-1pri discard-secondary;</span><br><span class="line">    after-sb-2pri disconnect;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手动恢复"><a href="#手动恢复" class="headerlink" title="手动恢复"></a>手动恢复</h3><p><a href="https://docs.linbit.com/docs/users-guide-8.4/#s-resolve-split-brain" target="_blank" rel="noopener">6.3. Manual split brain recovery</a></p><p>在检测到裂脑后，一个节点将始终使资源处于<code>StandAlone</code>连接状态。另一个可能也处于<code>StandAlone</code>状态（如果两个节点同时检测到裂脑）或<code>WFConnection</code>（如果某方节点在另一节点检测到裂脑之前断开连接）。</p><p>此时，除非已将<code>DRBD</code>配置为自动从裂脑状态中恢复，否则必须通过选择一个节点进行手动干预，该节点的修改将被丢弃（此节点称为裂脑受害者）。这个干预使用下面步骤完成：</p><p>裂脑受害者需要处于<code>StandAlone</code>的连接状态，否则以下命令将返回错误。您可以通过发出以下内容确保它是<code>StandAlone</code>的：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm disconnect &lt;resource&gt;</span><br><span class="line">drbdadm secondary &lt;resource&gt;</span><br><span class="line">drbdadm connect --discard-my-data &lt;resource&gt;    # 8.4+  if 8.3,use 'drbdadm -- --discard-my-data connect &lt;resource&gt;' instead</span><br></pre></td></tr></table></figure></p><p>在另一个节点（裂脑幸存者）上，如果它的连接状态也是<code>StandAlone</code>，你可以输入：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm connect &lt;resource&gt;</span><br></pre></td></tr></table></figure></p><p>如果节点已处于<code>WFConnection</code>状态，则可以省略此步骤;它会自动重新连接。</p><p>如果受裂脑影响的资源是<strong>堆叠</strong>资源，请使用<code>drbdadm --stacked</code>而不是<code>drbdadm</code>。</p><p>连接后，裂脑受害者立即将其连接状态更改为<code>SyncTarget</code>，并将其导致裂脑的修改由其余主节点的数据覆盖。</p><p>裂脑受害者不会引发全盘同步。相反，它的局部修改已经被回滚，对裂脑幸存者的任何修改都会传递给受害者。<br>重新同步完成后，裂脑被视为已解决（<code>resolved</code>），两个节点再次形成完全一致的冗余复制存储系统（<code>DRBD</code>）。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.linbit.com/docs/users-guide-8.4/" target="_blank" rel="noopener">User’s Guide 8.4.x</a></li><li><a href="http://blog.sina.com.cn/s/blog_a30f2be401016d04.html" target="_blank" rel="noopener">关于 DRBD v8.3 的同步机制</a></li><li><a href="http://myhat.blog.51cto.com/391263/606318/" target="_blank" rel="noopener">一次 DRBD 裂脑行为的模拟</a></li><li><a href="http://itindex.net/detail/50197-drbd" target="_blank" rel="noopener">drbd 裂脑处理 | IT 瘾</a></li><li><a href="http://www.3mu.me/%E4%BB%80%E4%B9%88%E6%98%AFdrbd%E8%84%91%E8%A3%82%E5%8F%8A%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9Fdrbd%E8%84%91%E8%A3%82/" target="_blank" rel="noopener">什么是 DRBD 脑裂及如何模拟 DRBD 脑裂</a></li><li><a href="http://www.wenzizone.cn/2009/10/29/drbd%e4%b8%admetadata%e7%9a%84%e7%90%86%e8%a7%a3%e5%8e%9f%e5%88%9b.html" target="_blank" rel="noopener">drbd 中 metadata 的理解(原创) – 蚊子世界</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DRBD </tag>
            
            <tag> 存储 </tag>
            
            <tag> 裂脑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于在 Python 中 MySQL 的 WHERE 子句中执行 IN 操作（list，tuple）的问题</title>
      <link href="/blog/2018-05-10/executing-select-where-in-using-mysqldb/"/>
      <url>/blog/2018-05-10/executing-select-where-in-using-mysqldb/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天在写代码的时候，有一处查询语句需要执行 <code>IN</code> 操作，结果直接<code>join</code>操作会出错。<br><a id="more"></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_of_datas = [<span class="string">u'sde'</span>, <span class="string">u'sdf'</span>, <span class="string">u'sdb'</span>, <span class="string">u'sdc'</span>]</span><br><span class="line">sql = <span class="string">"SELECT DiskId,Name,Sg,PhyId,ExpanderId,EProduct FROM Disk WHERE Used='2' AND Name IN (%s)"</span> % <span class="string">','</span>.join(list_of_datas)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DiskId, <span class="keyword">Name</span>, Sg, PhyId, ExpanderId</span><br><span class="line">, EProduct</span><br><span class="line"><span class="keyword">FROM</span> Disk</span><br><span class="line"><span class="keyword">WHERE</span> Used = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">Name</span> <span class="keyword">IN</span> (sde, sdf, sdb, sdc)</span><br></pre></td></tr></table></figure><p>很明显与预期的结果是不一样的。因为 <code>IN</code> 操作中的选取字段应该是带引号的字符串，而不是直接显示的字符串。也就是说我们期望的<code>WHERE</code>子句中是<code>WHERE Used = &#39;2&#39; AND Name IN (&#39;sde&#39;, &#39;sdf&#39;, &#39;sdb&#39;, &#39;sdc&#39;)</code>形式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql1 = <span class="string">"SELECT DiskId,Name,Sg,PhyId,ExpanderId,EProduct FROM Disk WHERE Used='2' AND Name IN (%s)"</span> % <span class="string">','</span>.join([<span class="string">"'%s'"</span> % item <span class="keyword">for</span> item <span class="keyword">in</span> list_of_datas])</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DiskId, <span class="keyword">Name</span>, Sg, PhyId, ExpanderId</span><br><span class="line">, EProduct</span><br><span class="line"><span class="keyword">FROM</span> Disk</span><br><span class="line"><span class="keyword">WHERE</span> Used = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">Name</span> <span class="keyword">IN</span> (<span class="string">'sde'</span>, <span class="string">'sdf'</span>, <span class="string">'sdb'</span>, <span class="string">'sdc'</span>)</span><br></pre></td></tr></table></figure><p>至此，可以满足我们的要求。不过，由于上面字符化操作感觉有点暴力，我们可以稍微改进一下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">format_strings= <span class="string">','</span>.join([repr(item) <span class="keyword">for</span> item <span class="keyword">in</span> list_of_datas])</span><br><span class="line">print(format_strings)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">u'sde'</span>,<span class="string">u'sdf'</span>,<span class="string">u'sdb'</span>,<span class="string">u'sdc'</span></span><br></pre></td></tr></table></figure><p>此时 <code>SQL</code> 语句变成:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DiskId,<span class="keyword">Name</span>,Sg,PhyId,ExpanderId,EProduct <span class="keyword">FROM</span> Disk <span class="keyword">WHERE</span> Used=<span class="string">'2'</span> <span class="keyword">AND</span> <span class="keyword">Name</span> <span class="keyword">IN</span> (u<span class="string">'sde'</span>,u<span class="string">'sdf'</span>,u<span class="string">'sdb'</span>,u<span class="string">'sdc'</span>)</span><br></pre></td></tr></table></figure><p>这个是没办法正常查询出结果的，因为查询字段是 <code>unicode</code> 编码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">format_unicode_strings = <span class="string">','</span>.join([repr(item.encode(<span class="string">'utf-8'</span>)) <span class="keyword">if</span> isinstance(item,unicode) <span class="keyword">else</span> repr(item) <span class="keyword">for</span> item <span class="keyword">in</span> list_of_datas])</span><br></pre></td></tr></table></figure><p>此时结果满足我们的要求：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DiskId, <span class="keyword">Name</span>, Sg, PhyId, ExpanderId</span><br><span class="line">, EProduct</span><br><span class="line"><span class="keyword">FROM</span> Disk</span><br><span class="line"><span class="keyword">WHERE</span> Used = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">Name</span> <span class="keyword">IN</span> (<span class="string">'sde'</span>, <span class="string">'sdf'</span>, <span class="string">'sdb'</span>, <span class="string">'sdc'</span>)</span><br></pre></td></tr></table></figure><p>至此，收工。</p><p>因为公司的代码封装函数是只能执行真正的 <code>SQL</code> 语句的，所以只能用上面的方法，查询网络上别人的解决方案发现下面的写法，以备参考。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>alist = [<span class="string">'1.1.1.1'</span>,<span class="string">'2.2.2.2'</span>,<span class="string">'3.3.3.3'</span>]                                                    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>select_str = <span class="string">'select * from server where ip in (%s)'</span> % <span class="string">','</span>.join([<span class="string">'%s'</span>] * len(alist))       </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>select_str  </span><br><span class="line"><span class="string">'select * from server where ip in (%s,%s,%s)'</span> </span><br><span class="line"> <span class="comment"># 执行sql查询</span></span><br><span class="line">cursor.execute(select_str,a)</span><br></pre></td></tr></table></figure><p>后面的写法有很多种，比如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">in_p = <span class="string">', '</span>.join((map(<span class="keyword">lambda</span> x: <span class="string">'%s'</span>, args)))</span><br><span class="line">realsql = sql % in_p</span><br><span class="line">cursor.execute(realsql, args)</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">in_p = <span class="string">', '</span>.join(itertools.repeat(<span class="string">'%s'</span>, len(args)))</span><br><span class="line">cursor.execute(sql % in_p, args)</span><br></pre></td></tr></table></figure><p>完整示例代码:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Created by imoyao at 2018/5/18 17:17</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">excute_sql</span><span class="params">(sql)</span>:</span></span><br><span class="line">    db = MySQLdb.connect(host=<span class="string">"localhost"</span>, user=<span class="string">"imoyao"</span>, passwd=<span class="string">"111111"</span>, db=<span class="string">"ODSP"</span>, charset=<span class="string">"utf8"</span>)</span><br><span class="line">    cr = db.cursor()</span><br><span class="line">    cr.execute(sql)</span><br><span class="line">    data = cr.fetchall()</span><br><span class="line">    cr.close()</span><br><span class="line">    db.close()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">excute_sql_datas</span><span class="params">(sqlstr, tupledata)</span>:</span></span><br><span class="line">    db = MySQLdb.connect(host=<span class="string">"localhost"</span>, user=<span class="string">"imoyao"</span>, passwd=<span class="string">"111111"</span>, db=<span class="string">"ODSP"</span>, charset=<span class="string">"utf8"</span>)</span><br><span class="line">    cr = db.cursor()</span><br><span class="line">    cr.execute(sqlstr,tupledata)</span><br><span class="line">    data = cr.fetchall()</span><br><span class="line">    cr.close()</span><br><span class="line">    db.close()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    list_of_datas = [<span class="string">u'sde'</span>, <span class="string">u'sdf'</span>, <span class="string">u'sdb'</span>, <span class="string">u'sdc'</span>]</span><br><span class="line">    format_strings = <span class="string">','</span>.join(</span><br><span class="line">        [repr(item.encode(<span class="string">'utf-8'</span>)) <span class="keyword">if</span> isinstance(item, unicode) <span class="keyword">else</span> repr(item) <span class="keyword">for</span> item <span class="keyword">in</span> list_of_datas])</span><br><span class="line">    sql = <span class="string">"SELECT DiskId,Name,Sg,PhyId,ExpanderId,EProduct FROM Disk WHERE Used='2' AND Name IN (%s)"</span> % format_strings</span><br><span class="line">    print(excute_sql(sql))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'*'</span>*<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    sql2 = <span class="string">"SELECT DiskId,Name,Sg,PhyId,ExpanderId,EProduct FROM Disk WHERE Used='2' AND Name IN (%s)"</span></span><br><span class="line">    <span class="comment"># format_strings2 = ', '.join(map(lambda x: '%s', list_of_datas))</span></span><br><span class="line">    <span class="comment"># format_strings2 = ', '.join(['%s'] * len(list_of_datas))</span></span><br><span class="line">    format_strings2 = <span class="string">', '</span>.join(itertools.repeat(<span class="string">'%s'</span>, len(list_of_datas)))</span><br><span class="line">    sqlstr = sql2 % format_strings2</span><br><span class="line">    print(excute_sql_datas(sqlstr, list_of_datas))</span><br></pre></td></tr></table></figure><p>参考链接：</p><ol><li><p><a href="https://blog.csdn.net/u011085172/article/details/79044490" target="_blank" rel="noopener">python mysql where in 对列表（list,,array）问题 - CSDN 博客</a></p></li><li><p><a href="https://stackoverflow.com/questions/4574609/executing-select-where-in-using-mysqldb" target="_blank" rel="noopener">python - Executing “SELECT … WHERE … IN …” using MySQLdb - Stack Overflow</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Python 中的下划线用法的记录</title>
      <link href="/blog/2018-04-28/the-underline-of-Python/"/>
      <url>/blog/2018-04-28/the-underline-of-Python/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="Py-乙己"><a href="#Py-乙己" class="headerlink" title="Py 乙己"></a>Py 乙己</h2><p>孔乙己自己知道不能和架构师谈天，便只好向实习生说话。</p><p>有一回对我说道，“你写过<code>Python</code>么？”我略略点一点头。</p><p>他说，“写过代码，……我便考你一考。<code>Python</code>中的下划线，怎样用的？”</p><p>我想，搬砖一样的人，也配考我么？便回过脸去，不再理会。</p><p>孔乙己等了许久，很恳切的说道，“不能写罢？……我教给你，记着！这些用法应该记着。将来做面试官的时候要用。”</p><p>我暗想我和面试官的等级还很远呢，而且我们面试官也从不将这些问题拿来考应聘者；又好笑，又不耐烦，懒懒的答他道，“谁要你教，不就是命名变量，增加代码的可读性吗？”</p><p>孔乙己显出极高兴的样子，将两个指头的长指甲敲着键盘，点头说，“对呀对呀！……下划线有四种写法，你知道么？”</p><p>我愈不耐烦了，努着嘴走远。孔乙己刚用纸巾擦了擦键盘上的咖啡渍，想在<code>IDE</code>里写代码，见我毫不热心，便又叹一口气，显出极惋惜的样子。<br><a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul><li>在交互式解释器中获取上一个语句执行的结果；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>+<span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_ * <span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>用来在函数、模块、包、变量名中分隔单词，增加可读性；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var_foo_bar = <span class="string">'hello,world!'</span></span><br></pre></td></tr></table></figure><ul><li>内部使用的变量、属性、方法、函数、类或模块，（约定）又称为内部实现；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假定存在foo.py中定义变量：</span></span><br><span class="line">_var = <span class="number">9527</span></span><br><span class="line"><span class="comment"># 在bar.py中导入</span></span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> *   <span class="comment"># 不会导入以下划线开头的对象</span></span><br><span class="line">print(_var)</span><br><span class="line"><span class="comment"># 返回：</span></span><br><span class="line">NameError: name <span class="string">'_var'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="comment"># 当然也可以强制导入（不推荐）</span></span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> _var        <span class="comment"># Access to a protected member _var of a module</span></span><br><span class="line">print(_var)</span><br><span class="line"><span class="comment"># 返回：</span></span><br><span class="line"><span class="number">9527</span></span><br></pre></td></tr></table></figure><ul><li>避免与 <code>Python</code> 保留的关键字冲突（约定）；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Tkinter.Toplevel(master, class_=<span class="string">'ClassName'</span>)        <span class="comment"># 注意class为Python內建名称</span></span><br></pre></td></tr></table></figure><ul><li>在类内的私有变量（<code>private</code>），类外部无法直接使用原名称访问，需要通过<code>instance._ClassName__var</code>的形式访问（<code>name mangling</code>）；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    __say_hello = <span class="string">'Hello,world'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pi = Person(<span class="string">'Peter'</span>, <span class="number">26</span>)</span><br><span class="line">    <span class="comment"># print(pi.__say_hello)       # AttributeError: 'Person' object has no attribute '__say_hello'</span></span><br><span class="line">    print(pi._Person__say_hello)</span><br><span class="line">    print(pi.get_age())</span><br></pre></td></tr></table></figure><p>我们可以使用<code>dir(pi)</code>看一下对象中的中的属性和方法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">['_Person__say_hello', '__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'get_age', 'get_name', 'name']</span><br></pre></td></tr></table></figure><p>这里 <code>Python</code> 解释器触发名称修饰，它这样做是为了防止变量在子类中被重写。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个集成Person的AI类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AI</span><span class="params">(Person)</span>:</span></span><br><span class="line"></span><br><span class="line">    __say_hello = <span class="string">'ALL in AI'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    ai_attr = [<span class="string">'ALL in AI'</span>]*<span class="number">3</span></span><br><span class="line">    ai = AI(*ai_attr)</span><br><span class="line">    print(dir(ai))</span><br></pre></td></tr></table></figure><p>我们可以看到继承关系：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回</span></span><br><span class="line">[<span class="string">'_AI__say_hello'</span>, <span class="string">'_Person__gender'</span>, <span class="string">'_Person__say_hello'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__format__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'_age'</span>, <span class="string">'name'</span>]</span><br></pre></td></tr></table></figure><p>这点在 <code>《Python Cookbook》- 8.5 在类中封装属性名</code> 中对于单下划线和双下划线的使用场景也有提及和解释：</p><blockquote><p>通常而言，你应该让你的非公共名称以单下划线开头。但是，如果你清楚你的代码会涉及到子类，并且有些内部属性应该在子类中隐藏起来，那么才考虑使用双下划线方案。</p></blockquote><ul><li>在类内的保护变量（这一条存疑）；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_var_</span><br></pre></td></tr></table></figure><ul><li><code>Python</code> 内置的“魔法”方法或属性，你也可以自己定义，但强烈 <strong>不推荐</strong>。比如：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__init__, __file__, __main__</span><br></pre></td></tr></table></figure><ul><li>作为内部使用的一次性变量；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通常在循环里使用,比如：</span></span><br><span class="line">foo_list = [_ <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="comment"># 或是用作占位，不实际使用的变量,比如：</span></span><br><span class="line"><span class="keyword">for</span> _, a <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>)]:</span><br><span class="line">    <span class="keyword">print</span> a</span><br></pre></td></tr></table></figure><ul><li><code>i18n</code> 里作为 <code>gettext()</code> 的缩写；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_()</span><br></pre></td></tr></table></figure><ul><li>用来分隔数值以增加可读性（<code>Python 3.6</code> 新增）；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; num = 1_000_000 </span><br><span class="line">&gt;&gt;&gt; num</span><br><span class="line">1000000</span><br><span class="line">1_000_000</span><br></pre></td></tr></table></figure><h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><ol><li><p><a href="http://pep8.org/#descriptive-naming-styles" target="_blank" rel="noopener">PEP 8 – Style Guide for Python Code</a></p></li><li><p><a href="https://www.pythonsheets.com/notes/python-basic.html#python-naming-rule" target="_blank" rel="noopener">Python basic cheatsheet</a></p></li><li><p><a href="https://dbader.org/blog/meaning-of-underscores-in-python" target="_blank" rel="noopener">The Meaning of Underscores in Python – dbader.org</a></p></li><li><p><a href="https://www.zhihu.com/question/268940585/answer/344852737" target="_blank" rel="noopener">Python 中的下划线_有多少个意思？- 知乎</a></p></li></ol><h2 id="派森多一点"><a href="#派森多一点" class="headerlink" title="派森多一点"></a>派森多一点</h2><p><code>Python</code>中的<code>dunder</code></p><p>参见<a href="https://nedbatchelder.com/blog/200605/dunder.html" target="_blank" rel="noopener">这里</a></p><blockquote><p>关于<code>Python</code> 编程的一个尴尬的事情是：有很多种双下划线。 例如，语法糖下面的标准方法名称具有 <code>__getattr__</code> 这样的名称，构造函数是 <code>__init__</code> ，内置运算符可以用 <code>__add__</code> 重载，等等。 在 <code>Django</code> 框架中（至少在他们整合了 <code>magic-removal</code> 分支之前），对象关系映射器使用了名为 <code>user__id__exact</code> 的关键字参数。</p></blockquote><blockquote><p>双下划线的问题是很难向别人描述。 你怎么读 <code>__init__</code> ？ “下划线下划线 <code>init</code> 下划线下划线”？ “双下划线 <code>init</code> 双下划线”？ 简单的 “<code>init</code>” 似乎漏掉了一些重要的东西。</p></blockquote><blockquote><p>我有一个解决方案：双下划线应该发音为 “<code>dunder</code>” 。 所以 <code>__init__</code> 念成“<code>dunder init dunder</code>”，或者也可以简读为 “<code>dunder init</code>” 。</p></blockquote><blockquote><p>现在我期待某个人定义一下 “<code>dunderhead</code>” 是什么意思，haha……</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析 Python 中的延迟绑定问题</title>
      <link href="/blog/2018-04-10/late-binding-of-Python/"/>
      <url>/blog/2018-04-10/late-binding-of-Python/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="延迟绑定-late-binding-闭包"><a href="#延迟绑定-late-binding-闭包" class="headerlink" title="延迟绑定(late binding)闭包"></a>延迟绑定(<code>late binding</code>)闭包</h1><p><code>Python</code> 使用中一个常见的困惑是 <code>Python</code> 在闭包(或在周围全局作用域（<code>surrounding global scope</code>）)中绑定变量的方式。<br><a id="more"></a><br>你所写的函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_expression</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">lambda</span> n: n*i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure></p><p>你所期望的：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print([mult(<span class="number">10</span>) <span class="keyword">for</span> mult <span class="keyword">in</span> multi_expression()])</span><br></pre></td></tr></table></figure></p><p>一个包含五个函数返回值的列表，每个函数有它们自己的封闭变量 <code>i</code> 乘以它们的参数，得到:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br></pre></td></tr></table></figure></p><p>而实际结果是：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>]</span><br></pre></td></tr></table></figure></p><p>创建了五个函数，它们全都是 <code>4</code> 乘以 <code>n</code> 。<br><code>Python</code> 的闭包是<em>迟绑定</em> 。这意味着闭包中用到的变量的值是在内部函数被调用时查询得到的。<br>在这里, 每当调用<em>任何</em>函数返回时, <code>i</code> 的值是调用时在周围作用域（ <code>surrounding scope</code>）中查询到的。到那个时候，循环已经完成， <code>i</code> 的值最终变成 <code>4</code> 。<br>关于这个陷阱有一个普遍严重的误解，它很容易被甩锅给 <code>Python</code> 的 <a href="http://docs.python.org/reference/expressions.html#lambda" target="_blank" rel="noopener">lambda</a>表达式。实际上， <code>lambda</code> 表达式是被冤枉滴。我们尝试把它改写成普通函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_func</span><span class="params">()</span>:</span></span><br><span class="line">    foo = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> n * i</span><br><span class="line">        foo.append(func)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> foo</span><br></pre></td></tr></table></figure></p><h2 id="为了实现目标，你应该这样"><a href="#为了实现目标，你应该这样" class="headerlink" title="为了实现目标，你应该这样"></a>为了实现目标，你应该这样</h2><ol><li>最一般的解决方案可以说是有点取巧（ <code>hack</code> ）。由于 <code>Python</code> 拥有在前文提到的为函数默认参数赋值的行为（参见 <a href="http://docs.python-guide.org/en/latest/writing/gotchas/#default-args" target="_blank" rel="noopener">可变默认参数</a> ）,你可以像下面这样创建一个立即绑定参数的闭包：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_expression_hack</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">lambda</span> n, i=i: n * i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]     <span class="comment"># 此处用法参见《Python Cookbook》7.7 匿名函数捕获变量值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print([func(<span class="number">10</span>) <span class="keyword">for</span> func <span class="keyword">in</span> multi_expression_hack()])</span><br></pre></td></tr></table></figure><ol start="2"><li>或者，你可以使用 <code>functools.partial</code> 函数（偏函数）：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [partial(mul, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print([func(<span class="number">10</span>) <span class="keyword">for</span> func <span class="keyword">in</span> partial_func()])</span><br></pre></td></tr></table></figure><ol start="3"><li>优雅的写法，直接用生成器推导式：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_expression</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">lambda</span> n: n * i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print([gen(<span class="number">10</span>) <span class="keyword">for</span> gen <span class="keyword">in</span> gen_expression()])</span><br></pre></td></tr></table></figure><ol start="4"><li>利用 <code>yield</code> 的惰性求值思想编写生成器函数：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">lambda</span> n: i * n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print([gen(<span class="number">10</span>) <span class="keyword">for</span> gen <span class="keyword">in</span> gen_func()])</span><br></pre></td></tr></table></figure><h2 id="当陷阱不是一个陷阱"><a href="#当陷阱不是一个陷阱" class="headerlink" title="当陷阱不是一个陷阱"></a>当陷阱不是一个陷阱</h2><p>有时, 你预期闭包是这样的（迟绑定的表现形式）。延迟绑定在多数情况下是正常的。不幸的是, 循环创建独特的函数可能会导致未知的小问题。</p><h2 id="派森多一点"><a href="#派森多一点" class="headerlink" title="派森多一点"></a>派森多一点</h2><p>关于生成器的惰性求值，我们可以看点简单的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(m_num, m_gen_num)</span>:</span></span><br><span class="line">    base = gen(m_gen_num)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(m_num):</span><br><span class="line">        base = (add(i, n) <span class="keyword">for</span> i <span class="keyword">in</span> base)</span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num = <span class="number">5</span></span><br><span class="line">    gen_num = <span class="number">10</span></span><br><span class="line">    print(list(main(num, gen_num)))</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>]</span><br></pre></td></tr></table></figure><p>如果我们对之前改写的<code>multi_func()</code>函数再稍微改写一下，让内部函数传值<code>*args</code>会怎么样？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_func_starred</span><span class="params">()</span>:</span></span><br><span class="line">    foo = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*n)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> n * i</span><br><span class="line">        foo.append(func)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print([func(<span class="number">10</span>) <span class="keyword">for</span> func <span class="keyword">in</span> multi_func_starred()])</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>), (<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>), (<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>), (<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>), (<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p>实际上，<code>*args</code>相当于一个生成器推导式，这点很容易验证：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_expression_starred</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># print(type(lambda *n: n*i for i in range(5)))     # 去掉注释 &gt;&gt;&gt;: &lt;class 'generator'&gt;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">lambda</span> *n: n * i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print([func(<span class="number">10</span>) <span class="keyword">for</span> func <span class="keyword">in</span> multi_expression_starred()])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 延迟绑定 </tag>
            
            <tag> 生成器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 环境管理介绍</title>
      <link href="/blog/2018-01-18/python-env-introduce/"/>
      <url>/blog/2018-01-18/python-env-introduce/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv 等工具的区别与介绍。<br>项目开发中可能需要用到不同版本的<code>Python</code>及相关的开发环境。比如<code>Python2</code>及<code>Python3</code>，或者有的项目需要 <code>Django1.5</code> ，有的需要<code>2.0</code>，这个时候借助一些工具，往往可以达到事半功倍的效果。</p><a id="more"></a><p><img src="https://farm5.staticflickr.com/4290/35294660055_42c02b2316_k_d.jpg" alt="Python"></p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><h3 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h3><p><code>virtualenv</code>是一个非常流行的工具，为<code>Python</code>库创建独立的<code>Python</code>环境。如果你不熟悉这个工具，我强烈建议你学习它，因为它是一个非常有用的工具，我将在这个答案的其余部分对此进行比较。</p><p>它通过在一个目录（例如：<code>env/</code>）中安装一堆文件，然后修改<code>PATH</code>环境变量来为自定义<code>bin</code>目录（例如：<code>env/bin/</code>）添加前缀。 <code>python</code>或<code>python3</code>二进制文件的精确拷贝会被放置在这个目录中，但<code>Python</code>被编程为首先在环境目录中查找相对于其路径的库。它不是<code>Python</code>标准库的一部分，但是获得<code>PyPA</code>（Python Packaging Authority）正式称赞。激活之后，你就可以使用<code>pip</code>在虚拟环境中安装软件包。</p><h4 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h4><p><code>virtualenvwrapper</code>是<code>virtualenv</code>的一组扩展（参见<a href="http://virtualenvwrapper.readthedocs.io/en/latest/" target="_blank" rel="noopener">文档</a>）。它提供例如<code>mkvirtualenv</code>、<code>lssitepackages</code>这样的命令，特别是<code>workon</code>命令，它可以在不同的<code>virtualenv</code>目录之间切换。如果你想要多个<code>virtualenv</code>目录，这个工具特别有用。</p><h3 id="pyenv"><a href="#pyenv" class="headerlink" title="pyenv"></a>pyenv</h3><p><code>pyenv</code>是<code>Python</code>的<strong>版本</strong>管理器,用于隔离<code>Python</code>版本。例如，你可能想要针对<code>Python 2.6</code>,<code>2.7</code>,<code>3.3</code>,<code>3.4</code>和<code>3.5</code>测试你的代码，因此你需要在不同<code>Python</code>版本之间进行切换。一旦激活，它就会在<code>PATH</code>环境变量前加上<code>~/.pyenv/shims</code>，其中有一些与<code>Python</code>命令（<code>python</code>，<code>pip</code>）匹配的特殊文件。这些不是<code>Python</code>提供的命令的副本;它们是根据<code>PYENV_VERSION</code>环境变量或<code>.python-version</code>文件或<code>~/.pyenv/version</code>文件决定运行哪个版本的<code>Python</code>的特殊脚本。 <code>pyenv</code>也使下载和安装多个<code>Python</code>版本的过程变得更简单，使用命令<code>pyenv install</code>即可。</p><h4 id="pyenv-virtualenv"><a href="#pyenv-virtualenv" class="headerlink" title="pyenv-virtualenv"></a>pyenv-virtualenv</h4><p><code>pyenv-virtualenv</code>是<code>pyenv</code>的一个插件，和<code>pyenv</code>一样，允许你在同一时间方便地使用<code>pyenv</code>和<code>virtualenv</code>。但是，如果你使用<code>Python 3.3</code>或更高版本，则<code>pyenv-virtualenv</code>会尝试运行<code>python -m venv</code>（如果可用），而不是<code>virtualenv</code>。如果你不想使用便利功能，则可以搭配使用<code>virtualenv</code>和<code>pyenv</code>而不使用<code>pyenv-virtualenv</code>。</p><h4 id="pyenv-virtualenvwrapper"><a href="#pyenv-virtualenvwrapper" class="headerlink" title="pyenv-virtualenvwrapper"></a>pyenv-virtualenvwrapper</h4><p><code>pyenv-virtualenvwrapper</code>是<code>pyenv</code>的一个插件，可以很方便地将<code>virtualenvwrapper</code>集成到<code>pyenv</code>中。</p><h3 id="pipenv"><a href="#pipenv" class="headerlink" title="pipenv"></a>pipenv</h3><p><code>pipenv</code>是<code>Python</code>的<strong>包</strong>管理器。由<code>Kennetth Reitz</code>（<code>requests</code>的作者）编写维护，是我们上面提到的这些项目里面最新的。它的目标是在命令行中将<code>Pipfile</code>、<code>pip</code>和<code>virtualenv</code>合并为一个命令。</p><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="pyvenv"><a href="#pyvenv" class="headerlink" title="pyvenv"></a>pyvenv</h3><p><code>pyvenv</code>是一个<code>Python 3</code>附带的脚本，但在<strong>Python 3.6 中被弃用</strong>，（参见<a href="https://docs.python.org/dev/whatsnew/3.6.html#id8" target="_blank" rel="noopener">这里</a>）因为它有问题（暂且不说名字还容易造成混淆）。在<code>Python 3.6+</code>中，实际上等价于命令<code>python3 -m venv</code>。</p><h3 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h3><p><code>venv</code>是<code>Python 3</code>附带的一个包，你可以使用<code>python3 -m venv</code>运行（虽然由于某些原因，一些发行版把它分离成一个单独的发行包，比如<code>Ubuntu / Debian</code>上的<code>python3-venv</code>）。它的作用与<code>virtualen</code>v 相似，工作方式也非常相似，但不需要复制<code>Python</code>二进制文件（<code>Windows</code>下除外）。如果你的代码不需要支持<code>Python 2</code>，可以使用它。在撰写本文时，<code>Python</code>社区似乎对<code>virtualenv</code>感到满意，<code>venv</code>相对来说比较小众。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1.<a href="https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe" target="_blank" rel="noopener">Python - What is the difference between venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv, etc? - Stack Overflow</a></p><p>2.<a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/" target="_blank" rel="noopener">Pipenv &amp; Virtual Environments — The Hitchhiker’s Guide to Python</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 环境下配置 DRBD</title>
      <link href="/blog/2018-01-11/how-to-configure-drbd-on-CentOS7/"/>
      <url>/blog/2018-01-11/how-to-configure-drbd-on-CentOS7/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文主要记录<code>DRBD</code>的配置过程和功能验证。<br><a id="more"></a></p><p>本文使用<code>64</code>位<code>CentOS</code>，基本环境：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+-----------------------+              |               +----------------------+</span><br><span class="line">| [ DRBD_A (Server#1) ] | 10.10.17.18  |  10.10.17.19  | [DRBD_B (Server#2) ] |</span><br><span class="line">|       node01          +--------------+---------------+         node02       |</span><br><span class="line">|                       |                              |                      |</span><br><span class="line">+-----------------------+                              +----------------------+</span><br><span class="line"></span><br><span class="line">DRBD 服务器A ：ip:10.10.17.18，hostname：DRBD_A</span><br><span class="line">DRBD 服务器B ：ip:10.10.17.19，hostname：DRBD_B</span><br></pre></td></tr></table></figure><h2 id="建立磁盘分区"><a href="#建立磁盘分区" class="headerlink" title="建立磁盘分区"></a>建立磁盘分区</h2><ul><li>分区之前</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@DRBD_A ~]# lsblk      # 查询块设备信息</span><br><span class="line">NAME                  MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">fd0                     2:0    1    4K  0 disk</span><br><span class="line">sda                     8:0    0   16G  0 disk</span><br><span class="line">├─sda1                  8:1    0  500M  0 part /boot</span><br><span class="line">└─sda2                  8:2    0 15.5G  0 part</span><br><span class="line">  ├─centos_bogon-root 253:0    0 13.9G  0 lvm  /</span><br><span class="line">  └─centos_bogon-swap 253:1    0  1.6G  0 lvm  [SWAP]</span><br><span class="line">sdb                     8:16   0    5G  0 disk</span><br><span class="line">└─StorPool-SANLun10   253:2    0    2G  0 lvm</span><br><span class="line">sr0                    11:0    1 1024M  0 rom</span><br><span class="line">drbd0                 147:0    0    2G  1 disk</span><br></pre></td></tr></table></figure><ul><li>进行分区</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@DRBD_A ~]# fdisk /dev/sdb     # 在sdb上新建分区</span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">Building a new DOS disklabel with disk identifier 0xb25d5d26.</span><br><span class="line"></span><br><span class="line">Command (m for help): n         #  新建</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p):</span><br><span class="line">Using default response p</span><br><span class="line">Partition number (1-4, default 1):</span><br><span class="line">First sector (2048-10485759, default 2048):</span><br><span class="line">Using default value 2048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-10485759, default 10485759): +1G</span><br><span class="line">Partition 1 of type Linux and of size 1 GiB is set</span><br><span class="line"></span><br><span class="line">Command (m for help): w         #  写入</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure><ul><li>分区之后</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@DRBD_A ~]# lsblk</span><br><span class="line">NAME                  MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">fd0                     2:0    1    4K  0 disk</span><br><span class="line">sda                     8:0    0   16G  0 disk</span><br><span class="line">├─sda1                  8:1    0  500M  0 part /boot</span><br><span class="line">└─sda2                  8:2    0 15.5G  0 part</span><br><span class="line">  ├─centos_bogon-root 253:0    0 13.9G  0 lvm  /</span><br><span class="line">  └─centos_bogon-swap 253:1    0  1.6G  0 lvm  [SWAP]</span><br><span class="line">sdb                     8:16   0    5G  0 disk</span><br><span class="line">├─sdb1                  8:17   0    1G  0 part      # 新分区</span><br><span class="line">└─StorPool-SANLun10   253:2    0    2G  0 lvm</span><br><span class="line">sr0                    11:0    1 1024M  0 rom</span><br><span class="line">drbd0                 147:0    0    2G  0 disk /media</span><br></pre></td></tr></table></figure><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><h3 id="更改-DRBD-全局配置"><a href="#更改-DRBD-全局配置" class="headerlink" title="更改 DRBD 全局配置"></a>更改 DRBD 全局配置</h3><p>首先根据需求更改<code>DRBD</code>全局配置<code>/etc/drbd.d/global_common.conf</code>:</p><p>此处可参阅另一篇文章：<a href="https://imoyao.github.io/blog/2017-09-11/Record_of_drbd/#global-common-conf配置（示例）">DRBD 全局配置</a></p><h3 id="创建DRBD配置文件"><a href="#创建DRBD配置文件" class="headerlink" title="创建DRBD配置文件"></a>创建<code>DRBD</code>配置文件</h3><p>由于<code>DRBD</code>是基于块设备的存储复制解决方案，所以此处使用<code>Lun</code>作为演示。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi r0.res</span><br><span class="line">resource r0 &#123;</span><br><span class="line">    # DRBD device</span><br><span class="line">    device /dev/drbd0;</span><br><span class="line">    # block device</span><br><span class="line">    disk /dev/StorPool/SANLun10;    # 磁盘路径，若为disk则修改为/dev/sdb1</span><br><span class="line">    meta-disk internal;</span><br><span class="line">    on DRBD_A &#123;</span><br><span class="line">        # IP address:port</span><br><span class="line">        address 10.10.17.18:7788;</span><br><span class="line">    &#125;</span><br><span class="line">    on DRBD_B &#123;</span><br><span class="line">        address 10.10.17.19:7788;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意：</code>本机主机名(<code>hostname</code>)和地址(<code>ip</code>)必须严格按照真实情况配置，两边<code>.res</code>文件内容尽量保持一致。</p><p>配置文件创建完成之后，在两个服务器上分别执行如下命令，创建<code>DRBD</code>资源，当然你也可以通过<code>scp</code>把配置文件拷过去，然后执行相关命令。</p><p>其中上述配置文件的 meta-disk 有三种记录方式：internal/device/device[index_num]。其中不管是哪种方式，metadata 存放的分区不能格式化，哪怕使用 internal 时 metadata 和一般 data 在同一个分区也不能格式化该分区。</p><p>internal 是将元数据也写入到数据分区的尾部，即数据和元数据同分区。如果指定的 device 没有给定 index 时，则表示元数据存储到该设备中。如果某节点指定 device[index_num]，那么指定几次元数据分区索引就必须大于 128M 的几倍，例如上述文件中 drbd1.longshuai.com 节点指定了/dev/sdb1[0]，那么 sdb1 就必须大于 128M，如果此时其他资源的节点也指定了同一台服务器的/dev/sdb1[1]，则指定了两次就必须大于 256M。指定为 internal 和 device 时，元数据区的大小是 drbd 自行计算的。<br>上面 index 的说法来自<a href="http://www.cnblogs.com/f-ck-need-u/p/8678883.html#1-drbd-" target="_blank" rel="noopener">这里</a>，具体没有实际验证。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm create-md r0</span><br></pre></td></tr></table></figure><p>然后启动 DRBD：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm up r0</span><br></pre></td></tr></table></figure><p>我在测试时没有操作下一步操作，但是数据也可以完成同步。查询了一下，网上说<code>drbdadm up</code>这个命令相当于<code>attach</code>、<code>syncer</code>、<code>connect</code>的总集合。但是后台使用<code>systemctl status drbd</code>获取到的状态还是<code>inactive (dead)</code>，欢迎大家提出自己的看法。</p><hr><p>在两个服务器上分别启动<code>DRBD</code>服务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/drbd start</span><br></pre></td></tr></table></figure><hr><p>把<code>DRBD_A</code>做为主服务器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 无数据时</span></span><br><span class="line">drbdadm primary r0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 有数据时，把本端作为primary端，本地数据分发到其他节点。</span></span><br><span class="line">drbdadm -- --overwrite-data-of-peer primary r0</span><br></pre></td></tr></table></figure><p>使用如下命令查看<code>DRBD</code>服务的状态信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/drbd status</span><br><span class="line"><span class="meta">#</span><span class="bash">或者</span></span><br><span class="line">drbd-overview</span><br></pre></td></tr></table></figure><p>此时，写入<code>DRBD_A</code>端(<code>/dev/drbd1</code>)的数据都会同步到<code>DRBD_B</code>端。</p><h2 id="测试数据同步"><a href="#测试数据同步" class="headerlink" title="测试数据同步"></a>测试数据同步</h2><h3 id="Primary端"><a href="#Primary端" class="headerlink" title="Primary端"></a><code>Primary</code>端</h3><ul><li>格式化<code>drbd</code></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfs.xfs /dev/drbd0</span><br></pre></td></tr></table></figure><ul><li>挂载设备</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount /dev/drbd0 /media</span><br></pre></td></tr></table></figure><ul><li>写入数据</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /media/</span><br><span class="line">mkdir drbd_test</span><br><span class="line">cd drbd_test/</span><br><span class="line">echo "hello World" &gt; hello.txt</span><br></pre></td></tr></table></figure><ul><li>卸载设备</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">umount /media</span><br></pre></td></tr></table></figure><ul><li>本端降级</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm secondary r0</span><br></pre></td></tr></table></figure><h3 id="Secondary端"><a href="#Secondary端" class="headerlink" title="Secondary端"></a><code>Secondary</code>端</h3><ul><li>从端升主</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm primary r0</span><br></pre></td></tr></table></figure><ul><li>挂载设备</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount /dev/drbd0 /media</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 此时从端不需要再次格式化，否则数据丢失。</p><ul><li>验证数据</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /media</span><br><span class="line">ls</span><br><span class="line">cat ./drbd_test/hello.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回</span></span><br><span class="line">hello World</span><br></pre></td></tr></table></figure><p>参考来源</p><ul><li><a href="https://www.server-world.info/en/note?os=CentOS_7&amp;p=drbd&amp;f=2" target="_blank" rel="noopener">CentOS 7 : DRBD : Configure : Server World</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DRBD </tag>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 下源码安装 DRBD</title>
      <link href="/blog/2018-01-11/how-to-install-drbd-on-CentOS7/"/>
      <url>/blog/2018-01-11/how-to-install-drbd-on-CentOS7/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>最近开发中又要用到<code>DRBD</code>做远程复制的功能，网上搜到很多都是<code>yum</code>安装的办法，这里记录一下源码安装的办法。<br><a id="more"></a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><h3 id="关闭-SELinux"><a href="#关闭-SELinux" class="headerlink" title="关闭 SELinux"></a>关闭 SELinux</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i -e "s/=enforcing/=disabled/g" /etc/selinux/config</span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y update </span><br><span class="line">yum -y install gcc make automake autoconf libxslt libxslt-devel flex rpm-build wget</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 安装<code>kernel-devel</code>一定要和<code>uname -r</code>获取结果一致。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -q kernel-devel</span><br><span class="line">uname -r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.10.0-327.el7.x86_64</span></span><br></pre></td></tr></table></figure><p>返回的内核版本应当一致，否则建议用本地源安装<code>kernel-devel</code>。</p><h2 id="下载-解压源码"><a href="#下载-解压源码" class="headerlink" title="下载/解压源码"></a>下载/解压源码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">官方地址：https://www.linbit.com/en/drbd-community/drbd-download/</span><br><span class="line">旧版本：http://www.linbit.com/en/drbd-community/old-releases/</span><br><span class="line">MORE：http://www.linbit.com/www.linbit.com/downloads/drbd/</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 在<code>DRBD 8.4.3</code>(?)以上版本，对<code>drbd</code>和<code>utils</code>做了拆分，需要分别进行下载。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://xxx.tar.gz</span><br></pre></td></tr></table></figure><p>当然，如果需要你也可以通过我的分享下载编译好的<code>rpm</code>包（示例版本）：</p><blockquote><p>链接:  <a href="https://pan.baidu.com/s/1huncgDI" target="_blank" rel="noopener">https://pan.baidu.com/s/1huncgDI</a>       密码:  b41i</p></blockquote><h3 id="解压下载的两个tar包"><a href="#解压下载的两个tar包" class="headerlink" title="解压下载的两个tar包"></a>解压下载的两个<code>tar</code>包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf drbd-8.*.tar.gz</span><br><span class="line">tar -zxvf drbd-utils-*.tar.gz</span><br></pre></td></tr></table></figure><h2 id="编译rpm"><a href="#编译rpm" class="headerlink" title="编译rpm"></a>编译<code>rpm</code></h2><h3 id="创建构建DRBD需要的目录"><a href="#创建构建DRBD需要的目录" class="headerlink" title="创建构建DRBD需要的目录"></a>创建构建<code>DRBD</code>需要的目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p rpmbuild/&#123;BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS&#125;</span><br></pre></td></tr></table></figure><h3 id="编译DRBD"><a href="#编译DRBD" class="headerlink" title="编译DRBD"></a>编译<code>DRBD</code></h3><h4 id="制作-rpm-包"><a href="#制作-rpm-包" class="headerlink" title="制作 rpm 包"></a>制作 <code>rpm</code> 包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd drbd-8.4.5/</span><br><span class="line">make clean</span><br><span class="line">make km-rpm KDIR=/usr/src/kernels/`uname -r`/       # 启用内核模块 自动识别内核版本    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You have now:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /root/rpmbuild/RPMS/x86_64/drbd-km-3.10.0_693.11.6.el7.x86_64-8.4.5-1.x86_64.rpm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /root/rpmbuild/RPMS/x86_64/drbd-km-debuginfo-8.4.5-1.x86_64.rpmmakeinsta</span></span><br></pre></td></tr></table></figure><hr><h4 id="直接编译安装"><a href="#直接编译安装" class="headerlink" title="直接编译安装"></a>直接编译安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># drbd模块</span></span></span><br><span class="line"></span><br><span class="line">cd drbd</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">lsmod|grep drbd</span><br><span class="line">cp drbd.ko /lib/modules/`uname -r`/kernel/lib/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 安装模块</span></span></span><br><span class="line">modprobe drbd</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 验证drbd模块是否加载（部分系统默认有该模块）</span></span></span><br><span class="line">lsmod|grep drbd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> drbd                  364858  0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> libcrc32c              12644  4 xfs,drbd,nf_nat,nf_conntrack</span></span><br></pre></td></tr></table></figure><hr><h3 id="编译-drbd-utils-组件"><a href="#编译-drbd-utils-组件" class="headerlink" title="编译 drbd-utils 组件"></a>编译 drbd-utils 组件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ../../drbd-utils-8.9.0/   </span><br><span class="line">./configure</span><br><span class="line">make rpm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br><span class="line">+ exit 0</span><br><span class="line">You have now:</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-km-3.10.0_693.11.6.el7.x86_64-8.4.5-1.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-km-debuginfo-8.4.5-1.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-8.9.0-1.el7.centos.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-utils-8.9.0-1.el7.centos.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-xen-8.9.0-1.el7.centos.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-udev-8.9.0-1.el7.centos.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-pacemaker-8.9.0-1.el7.centos.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-bash-completion-8.9.0-1.el7.centos.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-debuginfo-8.9.0-1.el7.centos.x86_64.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br></pre></td></tr></table></figure><p>此时有可能提示错误如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/xsltproc \</span><br><span class="line">        --xinclude \</span><br><span class="line">        http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl drbdsetup.xml</span><br><span class="line">error : Operation in progress</span><br><span class="line">warning: failed to load external entity "http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl"</span><br><span class="line">cannot parse http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl</span><br><span class="line">make[1]: *** [drbdsetup.8] Error 4</span><br></pre></td></tr></table></figure><p>提示有一个地址文件没能找到，解决方法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install docbook-style-xsl</span><br></pre></td></tr></table></figure><p>TODO: 此处暂未找到别的解决方法，欢迎读者留言。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装编译生成的文件"><a href="#安装编译生成的文件" class="headerlink" title="安装编译生成的文件"></a>安装编译生成的文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root/rpmbuild/RPMS/x86_64/</span><br><span class="line">rpm -ivh drbd-* --force</span><br></pre></td></tr></table></figure><h3 id="加载模块（参见分割线部分）"><a href="#加载模块（参见分割线部分）" class="headerlink" title="加载模块（参见分割线部分）"></a>加载模块（参见分割线部分）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe drbd</span><br></pre></td></tr></table></figure><h2 id="验证安装结果"><a href="#验证安装结果" class="headerlink" title="验证安装结果"></a>验证安装结果</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsmod|grep drbd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回（`depends` 可能略有不同）：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> drbd                  373375  4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> libcrc32c              12644  2 xfs,drbd</span></span><br><span class="line"></span><br><span class="line">drbd-overview  </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下两者返回稍有不同    </span></span><br><span class="line">cat /proc/drbd</span><br><span class="line">drbdadm -V</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回</span></span><br><span class="line"></span><br><span class="line">DRBDADM_BUILDTAG=GIT-hash:\ 79677f4***7ca6b99929\ build\ by\ root@imoyao\,\ 2018-01-06\ 14:25:03</span><br><span class="line">DRBDADM_API_VERSION=1</span><br><span class="line">DRBD_KERNEL_VERSION_CODE=0x080405</span><br><span class="line">DRBDADM_VERSION_CODE=0x080900</span><br><span class="line">DRBDADM_VERSION=8.9.0</span><br></pre></td></tr></table></figure><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><ul><li><p><a href="https://www.server-world.info/en/note?os=CentOS_7&amp;p=drbd&amp;f=1" target="_blank" rel="noopener">CentOS 7 : DRBD : Install : Server World</a></p></li><li><p><a href="http://blog.topspeedsnail.com/archives/8381" target="_blank" rel="noopener">CentOS 安装配置 DRBD – WTF Daily Blog</a></p></li><li><p><a href="http://www.3mu.me/centos%E4%B8%8B%E5%AE%9E%E7%8E%B0heartbeatdrbdmysql%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87%E7%A1%AC%E4%BB%B6%E6%95%85%E9%9A%9C%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E9%AB%98%E5%8F%AF%E7%94%A8ha/#respond" target="_blank" rel="noopener">CentOS 下实现 Heartbeat+DRBD+MySQL 双机热备硬件故障自动切换高可用(HA)方案 | 三木的人生——3mu.me</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DRBD </tag>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🐍PyTricks | Python 字典排序</title>
      <link href="/blog/2018-01-02/how-to-sort-dict-use-python/"/>
      <url>/blog/2018-01-02/how-to-sort-dict-use-python/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>写出<code>Pythonic</code>的代码应该是每个<code>Pythonista</code>的基本追求，本文主要记录在开发中遇到的一些有关<code>Python</code>技巧。</p><a id="more"></a><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li><code>JSON</code>字典内按照某个键值排序</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: alist = [&#123;<span class="string">'create'</span>: <span class="string">'2017-12-28 11:05:48'</span>, <span class="string">'id'</span>: <span class="string">'0_1'</span>, <span class="string">'path'</span>: <span class="string">'foo.py'</span>, <span class="string">'size'</span>: <span class="number">0</span>&#125;,</span><br><span class="line">   ....:  &#123;<span class="string">'create'</span>: <span class="string">'2017-12-28 11:00:29'</span>, <span class="string">'id'</span>: <span class="string">'0_2'</span>, <span class="string">'path'</span>: <span class="string">'bar.py'</span>, <span class="string">'size'</span>: <span class="number">0</span>&#125;,</span><br><span class="line">   ....:  &#123;<span class="string">'create'</span>: <span class="string">'2017-12-28 11:05:55'</span>, <span class="string">'id'</span>: <span class="string">'0_3'</span>, <span class="string">'path'</span>: <span class="string">'baz.py'</span>, <span class="string">'size'</span>: <span class="number">0</span>&#125;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: alist.sort(key=<span class="keyword">lambda</span> x:x[<span class="string">'create'</span>])    <span class="comment"># 按照创建时间排序 </span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: alist</span><br><span class="line">Out[<span class="number">17</span>]:``</span><br><span class="line">[&#123;<span class="string">'create'</span>: <span class="string">'2017-12-28 11:00:29'</span>, <span class="string">'id'</span>: <span class="string">'0_2'</span>, <span class="string">'path'</span>: <span class="string">'bar.py'</span>, <span class="string">'size'</span>: <span class="number">0</span>&#125;,</span><br><span class="line"> &#123;<span class="string">'create'</span>: <span class="string">'2017-12-28 11:05:48'</span>, <span class="string">'id'</span>: <span class="string">'0_1'</span>, <span class="string">'path'</span>: <span class="string">'foo.py'</span>, <span class="string">'size'</span>: <span class="number">0</span>&#125;,</span><br><span class="line"> &#123;<span class="string">'create'</span>: <span class="string">'2017-12-28 11:05:55'</span>, <span class="string">'id'</span>: <span class="string">'0_3'</span>, <span class="string">'path'</span>: <span class="string">'baz.py'</span>, <span class="string">'size'</span>: <span class="number">0</span>&#125;]</span><br></pre></td></tr></table></figure><ul><li>字典排序</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: languages = &#123;<span class="string">'JAVA'</span>:<span class="number">15</span>,<span class="string">'Python'</span>:<span class="number">12</span>,<span class="string">'Go'</span>:<span class="number">13</span>,<span class="string">'PHP'</span>:<span class="number">14</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: sorted(languages.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])        <span class="comment"># 以key排序</span></span><br><span class="line">Out[<span class="number">35</span>]: [(<span class="string">'Go'</span>, <span class="number">13</span>), (<span class="string">'JAVA'</span>, <span class="number">15</span>), (<span class="string">'PHP'</span>, <span class="number">12</span>), (<span class="string">'Python'</span>, <span class="number">12</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: sorted(languages.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])        <span class="comment"># 以value排序</span></span><br><span class="line">Out[<span class="number">36</span>]: [(<span class="string">'Python'</span>, <span class="number">12</span>), (<span class="string">'PHP'</span>, <span class="number">12</span>), (<span class="string">'Go'</span>, <span class="number">13</span>), (<span class="string">'JAVA'</span>, <span class="number">15</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: sorted(languages.items(),key=<span class="keyword">lambda</span> x:-x[<span class="number">1</span>])       <span class="comment"># 以value倒序</span></span><br><span class="line">Out[<span class="number">37</span>]: [(<span class="string">'JAVA'</span>, <span class="number">15</span>), (<span class="string">'Go'</span>, <span class="number">13</span>), (<span class="string">'Python'</span>, <span class="number">12</span>), (<span class="string">'PHP'</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>sort()</code>与<code>sorted()</code>的区别，前者返回值为<code>None</code>，后者可重新赋值；</p><p>参考阅读</p><ul><li><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP 8 – Style Guide for Python Code | Python.org</a></li><li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/" target="_blank" rel="noopener">Python 风格指南 — Google 开源项目风格指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 🐍PyTricks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Storcli 常用管理命令汇总</title>
      <link href="/blog/2017-12-27/storcli-command-share/"/>
      <url>/blog/2017-12-27/storcli-command-share/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>目前<code>LSI RAID</code>卡使用的配置工具主要有：<code>Megaraid Storage Manager</code>（MSM，图形环境）、<code>MegaCLI</code>（字符界面）、<code>StorCLI</code>（字符界面）。其中<code>StorCLI</code>作为<code>MegaCLI</code>后继者整合了<code>LSI</code>和原来<code>3ware</code>的产品支持，兼容<code>MegaCLI</code>命令的同时更加简洁。<a href="https://imoyao.github.io/blog/2017-11-20/megacli_command_share/">前面的文章</a>记录了<code>MegaCli</code>常用管理命令，本篇主要记录<code>StorCLI</code>的使用。</p><a id="more"></a><h2 id="安装Storcli"><a href="#安装Storcli" class="headerlink" title="安装Storcli"></a>安装<code>Storcli</code></h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip ul_avago_storcli_1.18.11_anyos.zip</span><br><span class="line">dpkg -i storcli_all_os/Ubuntu/storcli_1.18.11_all.deb</span><br><span class="line">dpkg -l | grep -i storcli</span><br></pre></td></tr></table></figure><h3 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip ul_avago_storcli_1.18.11_anyos.zip</span><br><span class="line">rpm -ivh storcli_all_os/Linux/storcli-1.18.11-1.noarch.rpm</span><br><span class="line">rpm -qi storcli</span><br><span class="line">ln -s /opt/MegaRAID/storcli/storcli64 /usr/local/bin/storcli</span><br></pre></td></tr></table></figure><h3 id="ESXi-5-5-amp-ESXi-6-0"><a href="#ESXi-5-5-amp-ESXi-6-0" class="headerlink" title="ESXi 5.5 &amp; ESXi 6.0"></a>ESXi 5.5 &amp; ESXi 6.0</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip ul_avago_storcli_1.18.11_anyos.zip</span><br><span class="line">esxcli software vib install -v=vmware-esx-storcli-1.21.06.vib --no-sig-check</span><br><span class="line">ln -s /opt/lsi/storcli/storcli /sbin/storcli</span><br><span class="line">storcli -V</span><br></pre></td></tr></table></figure><h2 id="storcli使用"><a href="#storcli使用" class="headerlink" title="storcli使用"></a><code>storcli</code>使用</h2><p>专有名词解释：</p><p><code>/cx, /vx</code> 表示 <code>Controller/Virtual Drive Number</code>.</p><p><code>/ex, /sx</code>表示 <code>Enclosure/Slot ID</code>.</p><p><code>VD</code>表示 <code>Virtual Drive</code>.</p><p>要输出<code>json</code>格式的返回,在命令行最后添加<code>J</code>.</p><ul><li>固件升级</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx download file=/path/to/firmware.rom</span><br></pre></td></tr></table></figure><ul><li>查看控制器和配置信息</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx show all</span><br></pre></td></tr></table></figure><ul><li>使用激活码激活特性(如 CacheCade, FastPath,…)</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx set aso key=AAAAAAAABBBBBBBBCCCCCCCC</span><br></pre></td></tr></table></figure><ul><li>查看现有硬盘及其状态的信息 (IDs,…)</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx /eall /sall show (all)</span><br></pre></td></tr></table></figure><p>返回结果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Controller = 0</span><br><span class="line">Status = Success</span><br><span class="line">Description = Show Drive Information Succeeded.</span><br><span class="line"></span><br><span class="line">Drive Information :</span><br><span class="line">=================</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">EID:Slt DID State DG     Size Intf Med SED PI SeSz Model                  Sp</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">252:0     1 Onln   1 3.637 TB SATA HDD N   N  512B WDC WD4000FYYZ-03UL1B3 U</span><br><span class="line">252:1     3 Onln   1 3.637 TB SATA HDD N   N  512B WDC WD4000FYYZ-03UL1B3 U</span><br><span class="line">......</span><br><span class="line">252:6    85 Onln   0 3.637 TB SATA HDD N   N  512B WDC WD4000FYYZ-03UL1B3 U</span><br><span class="line">252:7     2 UGood  - 3.637 TB SATA HDD N   N  512B WDC WD4000FYYZ-03UL1B3 D</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EID-Enclosure Device ID|Slt-Slot No.|DID-Device ID|DG-DriveGroup</span><br><span class="line">DHS-Dedicated Hot Spare|UGood-Unconfigured Good|GHS-Global Hotspare</span><br><span class="line">UBad-Unconfigured Bad|Onln-Online|Offln-Offline|Intf-Interface</span><br><span class="line">Med-Media Type|SED-Self Encryptive Drive|PI-Protection Info</span><br><span class="line">SeSz-Sector Size|Sp-Spun|U-Up|D-Down|T-Transition|F-Foreign</span><br><span class="line">UGUnsp-Unsupported|UGShld-UnConfigured shielded|HSPShld-Hotspare shielded</span><br><span class="line">CFShld-Configured shielded|Cpybck-CopyBack|CBShld-Copyback Shielded</span><br></pre></td></tr></table></figure><ul><li>现有虚拟硬盘及其状态的信息</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx /vall show (all)</span><br></pre></td></tr></table></figure><ul><li>查看当前所有重建的状态</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx /eall /sall show rebuild</span><br></pre></td></tr></table></figure><h2 id="创建-初始化-raid"><a href="#创建-初始化-raid" class="headerlink" title="创建/初始化 raid"></a>创建/初始化 <code>raid</code></h2><ul><li><code>shell</code>创建<code>VD</code></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx add vd type=[RAID0(r0)|RAID1(r1)|...] drives=[EnclosureID:SlotID|:SlotID-SlotID|:SlotID,SlotID]</span><br><span class="line"><span class="meta">#</span><span class="bash">more</span></span><br><span class="line">storcli /cx add vd type=raid[0|1|5|6|00|10|50|60(r0|r1|...)] [Size=&lt;VD1_Sz&gt;,&lt;VD2_Sz&gt;,..|all] [name=&lt;VDNAME1&gt;,..] drives=e:s|e:s-x,y;e:s-x,y,z [PDperArray=x] [SED] [pdcache=on|off|default] [pi] [DimmerSwitch(ds)=default|automatic(auto)|none|maximum(max)|MaximumWithoutCaching(maxnocache)] [wt|wb] [nora|ra] [direct|cached] [CachedBadBBU|NoCachedBadBBU][cachevd] [Strip=&lt;8|16|32|64|128|256|1024&gt;] [AfterVd=X] [Spares = [e:]s|[e:]s-x|[e:]s-x,y] [force][ExclusiveAccess]</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用硬盘0-2创建raid1</span></span><br><span class="line">storcli /cx add vd type=r1 drives=252:0-2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 raid5,write-bakc,<span class="built_in">read</span>-ahead</span></span><br><span class="line">storcli /cx add vd type=raid5  size=all names=VD1 drives=32:2-7 wb ra</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 raid10/50/60,必须设定PDperArray参数,write-bakc,<span class="built_in">read</span>-ahead</span></span><br><span class="line">storcli /cx add vd type=raid10 size=all names=VD1 drives=32:2-7 PDperArray=2 wb ra</span><br></pre></td></tr></table></figure><ul><li><code>shell</code>之初始化<code>VD</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">storcli /cx/vx start init (force)</span><br></pre></td></tr></table></figure><ul><li>监视初始化进度</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx/vx show init</span><br></pre></td></tr></table></figure><ul><li><code>shell</code>之移除<code>VD</code></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx/vx del (force)</span><br></pre></td></tr></table></figure><h2 id="缓存加速"><a href="#缓存加速" class="headerlink" title="缓存加速"></a>缓存加速</h2><ul><li><code>shell</code>之创建<code>CacheCade</code>设备（SSD 缓存加速）</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx add vd cc type=r[0,1,10] drives=[EnclosureID:SlotID|:SlotID-SlotID|:SlotID,SlotID]  WT|WB (assignvds=0,1,2)</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /c0 add vd cc type=r1 drives=252:2-3 WB</span><br></pre></td></tr></table></figure><ul><li><code>shell</code>之<code>CacheCade</code>激活/停用</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx/[vx|vall] set ssdCaching=[on|off]</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /c0/v1 set ssdCaching=on</span><br></pre></td></tr></table></figure><ul><li><code>shell</code>之移除<code>CacheCade</code></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx/vx del cc</span><br></pre></td></tr></table></figure><h2 id="误插拔设备合并"><a href="#误插拔设备合并" class="headerlink" title="误插拔设备合并"></a>误插拔设备合并</h2><p>如果不正确地移除设备并重新连接到 RAID 控制器，它将被识别为 UBAD(Unconfigured Bad)。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /c0 /eall /sall show</span><br></pre></td></tr></table></figure><p>此时的返回结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Controller = 0</span><br><span class="line">Status = Success</span><br><span class="line">Description = Show Drive Information Succeeded.</span><br><span class="line"></span><br><span class="line">Drive Information :</span><br><span class="line">=================</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">EID:Slt DID State DG       Size Intf Med SED PI SeSz Model                  Sp </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">252:0     7 Onln   0  465.25 GB SATA HDD N   N  512B WDC WD5003ABYX-01WERA1 U  </span><br><span class="line">252:1     6 Onln   1  465.25 GB SATA HDD N   N  512B WDC WD5003ABYX-01WERA1 U  </span><br><span class="line">252:2     5 UGood  -  465.25 GB SATA HDD N   N  512B WDC WD5003ABYX-01WERA1 U  </span><br><span class="line">252:3     4 UBad   - 223.062 GB SATA SSD N   N  512B INTEL SSDSC2CW240A3    U  </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>此时<code>252:3</code>必需置为<code>UGOOD</code></p><ul><li><code>UBad</code>置为<code>UGOOD</code></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx /ex /sx set good</span><br></pre></td></tr></table></figure><p>返回结果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Controller = 0</span><br><span class="line">Status = Success</span><br><span class="line">Description = Show Drive Information Succeeded.</span><br><span class="line"></span><br><span class="line">Drive Information :</span><br><span class="line">=================</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">EID:Slt DID State DG       Size Intf Med SED PI SeSz Model                  Sp </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">252:0     7 Onln   0  465.25 GB SATA HDD N   N  512B WDC WD5003ABYX-01WERA1 U  </span><br><span class="line">252:1     6 Onln   1  465.25 GB SATA HDD N   N  512B WDC WD5003ABYX-01WERA1 U  </span><br><span class="line">252:2     5 UGood  -  465.25 GB SATA HDD N   N  512B WDC WD5003ABYX-01WERA1 U  </span><br><span class="line">252:3     4 UGood  F 223.062 GB SATA SSD N   N  512B INTEL SSDSC2CW240A3    U  </span><br><span class="line">-------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><ul><li><code>foreign</code>管理</li></ul><p>此时硬盘为<code>foreign</code>状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx /fall show</span><br></pre></td></tr></table></figure><p>返回结果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Controller = 0</span><br><span class="line">Status = Success</span><br><span class="line">Description = Operation on foreign configuration Succeeded</span><br><span class="line"></span><br><span class="line">FOREIGN CONFIGURATION :</span><br><span class="line">=====================</span><br><span class="line">----------------------------------------</span><br><span class="line">DG EID:Slot Type State       Size NoVDs </span><br><span class="line">----------------------------------------</span><br><span class="line"> 0 -        Cac0 Frgn  223.062 GB     1 </span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">NoVDs - Number of VDs in disk group|DG - Diskgroup</span><br><span class="line">Total foreign drive groups = 1</span><br></pre></td></tr></table></figure><p>现在它可以重新包含在配置中</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx /fall import</span><br></pre></td></tr></table></figure><p>如果设备是 RAID 的一部分，则会自动执行重建（请参阅概述中的状态：Rbld）。 可用以下命令监视进度：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx /ex /sx show rebuild</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看VD健康状态等,获取到坏盘的E:S编号,然后查看对应盘的SN</span></span><br><span class="line">storcli /c0 /vall show [all]</span><br><span class="line">storcli /c0 /eX /sY show all |grep SN</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看阵列卡</span></span><br><span class="line">storcli show ctrlcount</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 virtual disk 0 @controlor 0</span></span><br><span class="line">storcli /cx /v0 show</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 Controlor-0, Enclosure-7, Slot-7的磁盘信息</span></span><br><span class="line">storcli /cx/e252/s7 show all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看报警信息</span></span><br><span class="line">storcli /cx show alarm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭beep蜂鸣器报警</span></span><br><span class="line">storcli /cx set alarm=&lt;on|off|silence&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 定位磁盘仓位</span></span><br><span class="line">storcli /c0/e8/s2 start/stop locate</span><br></pre></td></tr></table></figure><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><ul><li><a href="https://www.broadcom.com/site-search?q=storcli" target="_blank" rel="noopener">官方相关资源下载-broadcom</a></li><li><a href="https://docs.broadcom.com/docs-and-downloads/raid-controllers/raid-controllers-common-files/StorCLI_RefMan_revf.pdf" target="_blank" rel="noopener">StorCLI 官方手册下载</a></li><li><a href="https://www.thomas-krenn.com/en/wiki/StorCLI" target="_blank" rel="noopener">StorCLI _Thomas-Krenn</a></li><li><a href="https://www.xargs.cn/doku.php/lsi:storcli%E6%89%8B%E5%86%8C" target="_blank" rel="noopener">STORCLI-wiki（个人博主维护）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 存储 </tag>
            
            <tag> RAID </tag>
            
            <tag> Storcli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 资源推荐--[书籍篇]</title>
      <link href="/blog/2017-12-03/recommend-books-for-Python-learner/"/>
      <url>/blog/2017-12-03/recommend-books-for-Python-learner/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>因为我目前做<code>Python</code>相关开发，很多想入门<code>Python</code>的朋友或者从事其他语言开发的同学私聊讨论书籍资料推荐的话题，其实网上有很多关于这个问题的话题总结，我个人的推荐并不见得比大神更好，希望真正想沉下心来学习的人能够早点明白“自己动手，丰衣足食”的道理。在这里做个简单整理也算是给大家一个交代，以不留下盛气凌人的傲慢印象为盼。</p><a id="more"></a><h2 id="红药丸还是蓝药丸"><a href="#红药丸还是蓝药丸" class="headerlink" title="红药丸还是蓝药丸"></a>红药丸还是蓝药丸</h2><p>刚开始学习编程的时候，很多人会有各种困惑：选择哪门语言？选择语言的哪个版本？用什么编辑器/开发平台……</p><p>相信看这篇文章的对第一个问题已然有了自己的选择，在此不多赘述。关于 Python 版本的问题，时至今日（2017 年），除非公司项目需要，不然请果断选择 Python3，毕竟大多数第三方库已经做出放弃 Python2 维护的相关说明。第三个问题倒是不用过分纠结，毕竟只要能够 run，哪怕是用记事本写的也没人会在意。个人目前使用 Sublime Text 3 搭配 IDE PyCharm。</p><h2 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h2><ul><li>《”笨办法”学 Python》    （《Learn Python the Hard Way》）</li></ul><p><a href="https://www.gitbook.com/book/flyouting/learn-python-the-hard-way-cn/details" target="_blank" rel="noopener">笨办法学 Python -Gitbook</a></p><p>学习一门语言的最好办法就是多敲多用，妄图靠眼睛<strong>看</strong>会一门技术的人，希望能够早点丢掉幻想，准备战斗！</p><blockquote><p>这本简单书的目的是让你起步编程。 虽然书名说是“笨办法”,但其实并非如此. 所谓的“笨办法”是指本书教授的方式。这本书的<br>教学方式就是按照我告诉你的方式去做一系列的练习，目的是通过重复练习掌握一种技能。这对于一些什么都不知道的初学者，在理解更复杂的科目之前获取基本能力是很有效的方法。这种方法适用于一切领域，从武术到音乐甚至基本的数学和阅读技巧。<br>这本书以习题的方式引导读者一步一步学习编程，从简单的打印一直讲到完整项目的实现。也许读完这本书并不<br>意味着你已经学会了编程，但至少你会对编程语言以及编程这个行业有一个初步的了解。</p></blockquote><ul><li>《简明 Python 教程》    （《A Byte of Python》）</li></ul><p><a href="https://www.gitbook.com/book/lenkimo/byte-of-python-chinese-edition/details" target="_blank" rel="noopener">简明 Python 教程-Gitbook</a></p><p>看一下激动人心的前言介绍：</p><blockquote><p>本书将以指南或教程的形式向你介绍<code>Python</code>这门编程语言。它以新手为主要目标。同时本书也对有经验的程序员有所帮助。<br>如果你对电脑的所有了解仅止步于如何保存文本文件的话，那本书的目标便是协助你通过本书学习<code>Python</code>。如果在此之前你已经有了编程经验，你同样可以通过本书来学习<code>Python</code>。<br>如果你已经有过编程经验，你或许会对<code>Python</code>与其它你所喜爱的编程语言间有何区别抱有兴趣——而我将会你展现许多这种区别。顺便提醒你一下，<code>Python</code>将会很快成为你最喜欢的编程语言！</p></blockquote><ul><li>《 Python 3.3 官方教程》</li></ul><p><a href="http://www.pythondoc.com/pythontutorial3/index.html" target="_blank" rel="noopener">Python 入门指南中文版</a><br><a href="https://docs.python.org/3/" target="_blank" rel="noopener">Python 官方教程（英文原版）</a></p><p>更新、权威、条理化的官方<code>tutorial</code> ，最原汁原味的<code>Python</code>指南。</p><ul><li>《零基础学 Python》/《跟老齐学 Python》</li></ul><p><a href="https://www.gitbook.com/book/looly/python-basic/details" target="_blank" rel="noopener">零基础学 Python</a></p><p>这本教程是我当初开始自学的时候看过的，由于是国内作者，语言习惯更适合我们，顺便也推荐给大家。</p><blockquote><p>在我看来，<code>Python</code>是非常适合作为学习高级语言编程的第一门语言的。有一本书，名字叫《与孩子一起学编程》，这本书的定位，是将 python 定位为学习者学习的第一门高级编程语言。然而，由于读者对象是孩子，很多“成年人”不屑一顾，当然，里面的讲法与“实战”有点距离，导致以“找工作”、“工作需要”为目标的学习者，认为这本书跟自己要学的方向相差甚远。<br>为了弥补那本书的缺憾，我在这里推出面向成年人——大学生、或者其他想学习程序但是没有任何编程基础的朋友——学习第一门编程高级语言的教程。</p></blockquote><p>读完上面的书，你已经掌握<code>Python</code>的语法特点，可以看懂语言逻辑，也可以按照自己的想法写一点小<code>demo</code>了。这个时候，如果打算从事相关工作，可以尝试迈出第一步啦。需要提醒大家的是：读书和做写代码应该是并驾齐驱的，不能一味地去读书，也不要一味敲代码。（当然，你可能也写不出来）只有相互有机结合，才能记得稳固，学得牢靠。</p><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><ul><li>《流畅的 Python》   (《Fluent Python-Clear, Concise, and Effective Programming》)</li></ul><p><a href="https://github.com/cundi/fluent-python" target="_blank" rel="noopener">流畅的 Python(未完成)</a></p><blockquote><p>这本书并不是一本完备的 <code>Python</code> 使用手册，而是会强调 <code>Python</code> 作为编程语言独有的特性，这些特性或者是只有 <code>Python</code> 才具备的，或者是在其他大众语言里很少见的。本书的目标读者是那些正在使用 <code>Python</code>，又想熟悉 <code>Python 3</code> 的程序员。本书的主要目的是为了充分地展现 <code>Python 3.4</code> 的魅力。</p></blockquote><ul><li>《《Python Cookbook》3rd Edition 》</li></ul><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">Python Cookbook</a></p><blockquote><p>这本书的目标读者是那些想深入理解<code>Python</code>语言机制和现代编程风格的有经验的<code>Python</code>程序员。本书大部分内容集中于在标准库，框架和应用程序中广泛使用的高级技术。<br>本书所有示例均假设读者具有一定的编程背景并且可以读懂相关主题 （比如基本的计算机科学知识，数据结构知识，算法复杂度，系统编程，并行，C 语言编程等）。 另外，每个示例都只是一个入门指导，如果读者想深入研究，需要自己去查阅更多资料。我们假定读者可以很熟练的使用搜索引擎以及知道怎样查询在线的<code>Python</code>文档。</p></blockquote><p>读完上面的书，你已经可以写出<code>Pythonic</code>的代码了，应该对<code>Python</code>有了自己的理解，并且也会有自己的方向，可以确定自己的发展方向：Web 应用开发、爬虫数据分析、网络安全、运维测试、<code>Linux</code>系统开发、人工智能/机器学习。相信这个时候你已经不再需要别人的推荐，那么是时候为<code>Python</code>的蓬勃发展贡献自己的力量啦！</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p><a href="https://foofish.net/python-free-ebook.html" target="_blank" rel="noopener">免费中文 Python 电子书（教程）</a><br><a href="https://github.com/Junnplus/awesome-python-books/blob/master/README-ZH_CN.md" target="_blank" rel="noopener">Awesome Python Books</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Python 进行计数统计</title>
      <link href="/blog/2017-11-21/how-to-count-sequense-with-python/"/>
      <url>/blog/2017-11-21/how-to-count-sequense-with-python/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>from collections import Counter</p><a id="more"></a><h2 id="使用常规for循环"><a href="#使用常规for循环" class="headerlink" title="使用常规for循环"></a>使用常规<code>for</code>循环</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: test_seq = <span class="string">'asfsdgfads'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: count_dict = dict()</span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: <span class="keyword">for</span> item <span class="keyword">in</span> test_seq:</span><br><span class="line">    ...:     <span class="keyword">if</span> item <span class="keyword">in</span> count_dict:</span><br><span class="line">    ...:         count_dict[item] += <span class="number">1</span></span><br><span class="line">    ...:     <span class="keyword">else</span>:</span><br><span class="line">    ...:         count_dict[item] = <span class="number">0</span></span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">56</span>]: count_dict</span><br><span class="line">Out[<span class="number">56</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">1</span>, <span class="string">'f'</span>: <span class="number">1</span>, <span class="string">'g'</span>: <span class="number">0</span>, <span class="string">'s'</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="使用collections库中的defaultdict"><a href="#使用collections库中的defaultdict" class="headerlink" title="使用collections库中的defaultdict"></a>使用<code>collections</code>库中的<code>defaultdict</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: cd_dict = defaultdict()</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: cd_dict = defaultdict(int)</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: <span class="keyword">for</span> item <span class="keyword">in</span> test_seq:</span><br><span class="line">    ...:     cd_dict[item] += <span class="number">1</span></span><br><span class="line">    ...:</span><br><span class="line">In [<span class="number">62</span>]: cd_dict</span><br><span class="line">Out[<span class="number">62</span>]: defaultdict(int, &#123;<span class="string">'a'</span>: <span class="number">2</span>, <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'f'</span>: <span class="number">2</span>, <span class="string">'g'</span>: <span class="number">1</span>, <span class="string">'s'</span>: <span class="number">3</span>&#125;)</span><br><span class="line">In [<span class="number">63</span>]: cd_dict.items()</span><br><span class="line">Out[<span class="number">63</span>]: [(<span class="string">'a'</span>, <span class="number">2</span>), (<span class="string">'s'</span>, <span class="number">3</span>), (<span class="string">'d'</span>, <span class="number">2</span>), (<span class="string">'g'</span>, <span class="number">1</span>), (<span class="string">'f'</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><h2 id="使用collections库中的Counter"><a href="#使用collections库中的Counter" class="headerlink" title="使用collections库中的Counter"></a>使用<code>collections</code>库中的<code>Counter</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: Counter(test_data)</span><br><span class="line">Out[<span class="number">65</span>]: Counter(&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">3</span>, <span class="string">'g'</span>: <span class="number">3</span>, <span class="string">'h'</span>: <span class="number">1</span>, <span class="string">'s'</span>: <span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: counter = Counter(test_seq)</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: counter.items()</span><br><span class="line">Out[<span class="number">85</span>]: [(<span class="string">'a'</span>, <span class="number">2</span>), (<span class="string">'s'</span>, <span class="number">3</span>), (<span class="string">'d'</span>, <span class="number">2</span>), (<span class="string">'g'</span>, <span class="number">1</span>), (<span class="string">'f'</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><ul><li>《编写高质量代码：改善 Python 程序的 91 个建议》迷你书-建议 39：使用 Counter 进行计数统计</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> HOWTO </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘阵列控制卡（RAID 卡）MegaCli 常用管理命令汇总</title>
      <link href="/blog/2017-11-20/megacli-command-share/"/>
      <url>/blog/2017-11-20/megacli-command-share/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>进行存储开发时需要创建磁盘阵列，本文主要记录 RAID 卡管理工具<code>MegaCli</code>的使用。需要注意的是，目前该管理工具因为商业收购已经被官方“弃坑”，<code>StorCLI</code>作为后继者整合了<code>LSI</code>和原来<code>3ware</code>的产品支持，兼容<code>MegaCLI</code>命令的同时更加简洁，参阅<a href="https://imoyao.github.io/blog/2017-12-27/storcli_command_share/">此篇</a>。<br><a id="more"></a></p><h2 id="巡读"><a href="#巡读" class="headerlink" title="巡读"></a>巡读</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">立即激活</span></span><br><span class="line">MegaCli -adppr -enblauto -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置成手动模式，需要用MegaCli -adppr -start –a0 来激活</span></span><br><span class="line">MegaCli -adppr -enblman -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看巡读的模式，本次巡读结束与下一次开始巡读的间隔，当前状态等信息</span></span><br><span class="line">MegaCli -adppr -info -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看巡读的进度</span></span><br><span class="line">MegaCli -fwtermlog -dsply -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">结束巡读，在巡读过程中，多次运用MegaCli -adppr -stop -a0或MegaCli -adppr -start -a0会使叠代数增加，此时可能不能开始或结束巡读，用MegaCli -adppr -dsbl -a0来禁止巡读，重新开始。</span></span><br><span class="line">MegaCli -adppr -stop -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置本次巡读结束与下一次巡读开始的时间间隔，默认是168小时，当val=0时, 本次巡读结束后，立即开始下一次巡读</span></span><br><span class="line">MegaCli -adppr -setdelay val -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">巡读时是否纠正媒介错误</span></span><br><span class="line">MegaCli -AdpSetProp -PrCorrectUncfgdAreas -val -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置定时巡读 yyyymmdd hh，具体含义如下：20120108 16表示2012年01月08日16点</span></span><br><span class="line">MegaCli -AdpPR -SetStartTime yyyymmdd hh -a0</span><br></pre></td></tr></table></figure><h2 id="cc-校验"><a href="#cc-校验" class="headerlink" title="cc 校验"></a>cc 校验</h2><ul><li>立即开始 cc 校验</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">L0表示Target ID 为0的raid组</span></span><br><span class="line">MegaCli -ldcc -start -L0 –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">如果没有完全初始化或后台初始化</span></span><br><span class="line"><span class="meta">#</span><span class="bash">The virtual disk has not been initialized、 Running a consistency check may result <span class="keyword">in</span> inconsistent messages <span class="keyword">in</span> the <span class="built_in">log</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">可以强行cc校验</span></span><br><span class="line">MegaCli -ldcc -start -force –L0 –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">显示当前cc校验的进度</span></span><br><span class="line">MegaCli -ldcc -progdsply -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">关掉当前的cc校验</span></span><br><span class="line">MegaCli -ldcc -abort -L0 -a0</span><br></pre></td></tr></table></figure><ul><li>计划 cc 校验<br>如果模式为 disable(MegaCli -adpccsched -info -a0 来查看)，则下一次开始时间为 07/28/2135, 02:00:00，状态为 Stopped，延期为 168 个小时;<br>只有模式为 Sequential 和 Concurrent 模式时，才可以设定定期时间，所以要首先设定模式;<br>如果模式为 Sequential 时，所有虚拟磁盘组顺序进行 cc 校验;<br>如果模式为 Concurrent 时，所有虚拟磁盘组同时进行 cc 校验;<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设定CC模式</span></span><br><span class="line">MegaCli -adpccsched -modeconc -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">或者</span></span><br><span class="line">MegaCli -adpccsched -modeseq -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">然后设定开始时间</span></span><br><span class="line">MegaCli -adpccsched setstarttime 20101122 18 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置本次cc校验结束和下次cc校验开始的时间间隔</span></span><br><span class="line">MegaCli -adpccsched -setdelay 2 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">禁止计划cc校验</span></span><br><span class="line">MegaCli -AdpCcSched -dsbl -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置错误发生时放弃cc校验</span></span><br><span class="line">MegaCli -adpsetprop -AbortCC -1 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看cc校验的事件日志</span></span><br><span class="line">MegaCli -AdpEventLog -GetCCIncon –f filename –L0 –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">如果设置延期时间为0，本次cc校验结束后，下一次cc校验会立即开始</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="快速初始化和完全初始化"><a href="#快速初始化和完全初始化" class="headerlink" title="快速初始化和完全初始化"></a>快速初始化和完全初始化</h2><p>快速初始化值是往 raid 组的前 8M 和后 8M 写 0<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">快速初始化</span></span><br><span class="line">MegaCli -LDInit -start –L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">完全初始化</span></span><br><span class="line">MegaCli -LDInit -start -full –L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">显示初始化的进度</span></span><br><span class="line">MegaCli -LDInit -progdsply -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">结束完全初始化</span></span><br><span class="line">MegaCli -LDInit -abort -L0 -a0</span><br></pre></td></tr></table></figure></p><h2 id="后台初始化"><a href="#后台初始化" class="headerlink" title="后台初始化"></a>后台初始化</h2><p>Raid5 需要 5 个数据盘才可以后台初始化(5 个盘中不包含热备盘)<br>后台初始化是创建 raid 后 5 分钟开始的(好像有时不是这样的)<br>后台初始化和 cc 校验不同的地方是，后台初始化可以自动开始<br>改变后台初始化率时，需要停止后台初始化，否则没有效果<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">禁止后台初始化</span></span><br><span class="line">MegaCli -LDBI -dsbl -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">结束正在进行的后台初始化</span></span><br><span class="line">MegaCli -LDBI -abort -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看后台初始化的设置</span></span><br><span class="line">MegaCli -LDBI -getsetting -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">显示后台初始化进度</span></span><br><span class="line">MegaCli -LDBI -progdsply -L0 -a0</span><br></pre></td></tr></table></figure></p><h2 id="copyback"><a href="#copyback" class="headerlink" title="copyback"></a>copyback</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">开启或禁用copyback</span></span><br><span class="line">MegaCli -AdpSetProp –CopyBackDsbl -0 -a0 (开启)</span><br><span class="line"><span class="meta">#</span><span class="bash">显示copyback设置情况</span></span><br><span class="line">MegaCli –AdpGetProp -CopyBackDsbl –a0</span><br></pre></td></tr></table></figure><p>当设置 copyback 为 enable 时，拔出坏盘，换上一个 UNCONF 的新盘，先用热备盘进行重建，然后进行 copyback 操作，如果 copyback 为 disable 时，不进行 copyback 操作，可以设定 copyback 为 enable，然后用 MegaCli -PDCpyBk -Start -PhysDrv[E0:S0,E1:S1] –a0 开始 copyback 操作，其中[E0：S0]是 raid 组中的磁盘(源盘)，而[E1：S1]不是 raid 组中的磁盘(目的盘)</p><p>当某个盘出现第一个 smart 错误时，可以在这个盘和热备盘之间进行 copyback 操作，热备盘作为目的盘，完成了 copyback 操作时，smart 错误盘才标记为 failed 状态。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果在copyback时，raid组删除，目的盘回到热备盘状态或Unconfigured Good</span></span><br><span class="line">MegaCli -AdpGetProp SMARTCpyBkEnbl -a0</span><br></pre></td></tr></table></figure></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看所有的information日志</span></span><br><span class="line">MegaCli -adpalilog -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看固件调试日志(固件终端日志)</span></span><br><span class="line">MegaCli -fwtermlog -dsply -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看raid卡日志</span></span><br><span class="line">MegaCli -adpeventlog -getevents -f filename -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">清除日志</span></span><br><span class="line">MegaCli -AdpEventLog -Clear –a0</span><br></pre></td></tr></table></figure><h2 id="raid5-扩容"><a href="#raid5-扩容" class="headerlink" title="raid5 扩容"></a>raid5 扩容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">raid5的扩容</span></span><br><span class="line">MegaCli -LDRecon -Start -r5 -Add -Physdrv[E0:S0] -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看扩容的进度</span></span><br><span class="line">MegaCli -LDRecon -progdsply -L0 –a0</span><br></pre></td></tr></table></figure><h2 id="级别迁移"><a href="#级别迁移" class="headerlink" title="级别迁移"></a>级别迁移</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在迁移过程中，转换前的raid的一个盘下线，转换前raid的所有盘都下线</span><br><span class="line">支持的类型 RAID 0 to RAID 1，RAID 0 to RAID 5，RAID 0 to RAID 6，RAID 1 to RAID 0，RAID 1 to RAID 5，RAID 1 to RAID 6，RAID 5 to RAID 0，RAID 5 to RAID 6，RAID 6 to RAID 0，RAID 6 to RAID 5</span><br><span class="line"><span class="meta">#</span><span class="bash">建立了三个盘的raid 0</span></span><br><span class="line">MegaCli -cfgldadd -r0[117:1,117:3,117:11] -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">增加一个盘[117:14],转换到raid5</span></span><br><span class="line">MegaCli -ldrecon -start -r5 -add -physdrv[117:14] -l0 -a0</span><br></pre></td></tr></table></figure><h2 id="升级-ROM"><a href="#升级-ROM" class="headerlink" title="升级 ROM"></a>升级 ROM</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">从低版本到高版本升级</span></span><br><span class="line">MegaCli -adpfwflash -f x.rom -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">从高版本到低版本降级</span></span><br><span class="line"><span class="meta">#</span><span class="bash">加上noverchk忽略版本的检查，升级以后需要重启才生效</span></span><br><span class="line">MegaCli -adpfwflash -f x.rom -noverchk -a0</span><br></pre></td></tr></table></figure><h2 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h2><p>Raid 对内有两个接口，即 connector0 和 connector1。得到连接器的状态;<br> MegaCli -adpgetconnectormode -connector0 -a0<br>如果连接器的模式为 internal 时，jbod 的磁盘全部看不到，如果连接器的模式为 external 时，主柜上的磁盘全部看不到;</p><h2 id="外来配置"><a href="#外来配置" class="headerlink" title="外来配置"></a>外来配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">扫描外来配置的个数</span></span><br><span class="line">MegaCli -cfgforeign -scan -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看当前的磁盘在normal时的位置</span></span><br><span class="line">MegaCli -cfgforeign -preview -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">来导入配置，恢复虚拟磁盘组</span></span><br><span class="line">MegaCli -cfgforeign -import -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">清除外来配置</span></span><br><span class="line">MegaCli -cfgforeign -clear -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">显示出现外来配置(磁盘插入的顺序)的过程</span></span><br><span class="line">MegaCli -cfgforeign -dsply -a0</span><br></pre></td></tr></table></figure><h2 id="物理磁盘的处理"><a href="#物理磁盘的处理" class="headerlink" title="物理磁盘的处理"></a>物理磁盘的处理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">磁盘的状态由FAULTY变成CONF</span></span><br><span class="line">MegaCli -PDMakeGood -PhysDrv[E0:S0] –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">磁盘上线</span></span><br><span class="line">MegaCli -PDOnline -PhysDrv[E0:S0,E1:S1,...] –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">磁盘下线</span></span><br><span class="line"><span class="meta">#</span><span class="bash">failed状态的盘可以下线，然后用MegaCli -pdmarkmissing -physdrv[E0:S0] -a0让磁盘踢盘，让其他的UNCONF状态的磁盘来替代这个盘MegaCli -PdReplaceMissing -physdrv[E0:S0] -arrayA, -rowB -a0</span></span><br><span class="line">MegaCli -PDOffline -PhysDrv[E0:S0,E1:S1,...] –a0 </span><br><span class="line"><span class="meta">#</span><span class="bash">此时磁盘处于Spun down状态，如果用此磁盘来建立raid，则磁盘的状态自动变成Spun Up</span></span><br><span class="line">MegaCli -PdPrpRmv -physdrv[E0:S0] –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">清除单个磁盘</span></span><br><span class="line">MegaCli -pdclear -start -physdrv[E:S] -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置热备盘的节电策略</span></span><br><span class="line">MegaCli -AdpSetProp –DsblSpinDownHSP -val –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置空闲盘的节电策略</span></span><br><span class="line">MegaCli -AdpSetProp –EnblSpinDownUnConfigDrvs -val –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">获取所有磁盘的详细信息</span></span><br><span class="line">MegaCli -PDList –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">获取单个盘的详细信息</span></span><br><span class="line">MegaCli -pdInfo -PhysDrv[E0:S0] –a0</span><br></pre></td></tr></table></figure><h2 id="Adpsetprop-设置属性"><a href="#Adpsetprop-设置属性" class="headerlink" title="Adpsetprop 设置属性"></a>Adpsetprop 设置属性</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RebuildRate ，PatrolReadRate，BgiRate，CCRate，ReconRate，表示进行重建，巡读，后台初始化，cc校验，扩容等所占有的系统资源率，提高速度</span><br><span class="line">CoercionMode(强制模式)，分成三种形式，None，128M，1G，当为1G时，每个磁盘比没有设置的时减少了1G的空间;</span><br><span class="line">PredFailPollInterval，轮询预测失败的时间间隔。Predictive Failure Count就是smart错误;</span><br><span class="line">MaintainPdFailHistoryEnbl 保存坏盘的历史记录。当为enable时，当一个盘掉线并重新上线。需要清除配置信息，添加为热备盘才可以重建当为disable时。当一个盘掉线并重新上线，自动重建;</span><br><span class="line"><span class="meta">#</span><span class="bash">设置Cluster模式，目前不支持，只能设置为disbale</span></span><br><span class="line">MegaCli -AdpSetProp ClusterEnable -0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置jbod模式，针对raid0有效，对单个盘读写，即先写第一个盘，写满了在写第二个盘。MegaCli -PDMakeJBOD -physdrv[E0:S0,E1:S1] -a0 可以设置jbod模式(目前不支持)</span></span><br><span class="line">MegaCli -AdpSetProp -EnableJBOD -1 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">让设备驱动暴露enclosure devices</span></span><br><span class="line">MegaCli -AdpSetProp ExposeEnclDevicesEnbl -1 -a0</span><br></pre></td></tr></table></figure><h2 id="NCQ"><a href="#NCQ" class="headerlink" title="NCQ"></a>NCQ</h2><p>Native Command Queuing (NCQ)对硬盘的读写命令的顺序进行优化。带 NCQ 技术的硬盘在接到读写指令后，会根据指令对访问地址进行重新排序。比如根据指令，硬盘需要访问 330 扇区、980 扇区、340 扇区，由于数据在磁盘上分布位置不同，普通硬盘只会按部就班地依次访问。而 NCQ 硬盘对指令进行优化排列之后，就可以先读取 330 扇区，接着读取 340 扇区，然后再读取 980 扇区。这样做的好处就是减少了磁头臂来回移动的时间，使数据读取更有效，同时有效地延长了硬盘的使用寿命。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">显示NCQ的设置情况</span></span><br><span class="line">MegaCli -adpgetprop -NCQdsply -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置开启NCQ</span></span><br><span class="line">MegaCli -adpsetprop -NCQenbl -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭NCQ</span></span><br><span class="line">MegaCli -adpsetprop -NCQdsbl -a0</span><br></pre></td></tr></table></figure></p><h2 id="添加和移除热备盘"><a href="#添加和移除热备盘" class="headerlink" title="添加和移除热备盘"></a>添加和移除热备盘</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">添加局部热备盘，其中array0表示第0个raid</span></span><br><span class="line">MegaCli -PDHSP -Set -Dedicated -Array0 -physdrv[E:S] -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">添加全局热备盘</span></span><br><span class="line">MegaCli -pdhsp -set -physdrv[E:S] -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">移除全局和热备局部热备</span></span><br><span class="line">MegaCli -pdhsp -rmv -physdrv[E:S] -a0</span><br></pre></td></tr></table></figure><h2 id="重建"><a href="#重建" class="headerlink" title="重建"></a>重建</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看重建的进度</span></span><br><span class="line">MegaCli -PDRbld -progdsply -physdrv[E:S] -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">调快重建的速度</span></span><br><span class="line">MegaCli -AdpSetProp RebuildRate -val -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置自动重建，当一个盘坏掉时，热备盘可以自动重建，代替坏的盘</span></span><br><span class="line">MegaCli -AdpAutoRbld -Enbl -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">手动开始重建，E0:S0表示坏的盘</span></span><br><span class="line">MegaCli -PDRbld -Start -PhysDrv [E0:S0] -a0</span><br></pre></td></tr></table></figure><h2 id="恢复出厂设置"><a href="#恢复出厂设置" class="headerlink" title="恢复出厂设置"></a>恢复出厂设置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">恢复出厂的默认配置</span></span><br><span class="line">MegaCli -AdpFacDefSet –a0</span><br></pre></td></tr></table></figure><h2 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">临时关闭，重启又变成开启</span></span><br><span class="line">MegaCli -AdpSetProp -AlarmSilence –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">永久关闭，重启后还是关闭</span></span><br><span class="line">MegaCli -AdpSetProp -AlarmDsbl –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">开启</span></span><br><span class="line">MegaCli -AdpSetProp -Alarmenbl –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看告警的状态</span></span><br><span class="line">MegaCli -AdpgetProp -Alarmdsply –a0</span><br></pre></td></tr></table></figure><h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">可以查看一组磁盘上的多个raid的配置</span></span><br><span class="line">MegaCli -CfgDsply -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">保存配置文件</span></span><br><span class="line">MegaCli -CfgSave -f filename -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">导入配置文件，Raid组的配置文件放在最后，放在每个磁盘的最后512M，主要包含数据从哪里开始写的配置和用来Migration 的swap文件</span></span><br><span class="line">MegaCli -CfgRestore -f filename -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">启动时恢复外来配置</span></span><br><span class="line">MegaCli -AdpSetProp -AutoEnhancedImportEnbl -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">验证配置文件和文件的内容</span></span><br><span class="line">MegaCli -AdpSetVerify -f fileName -a0</span><br></pre></td></tr></table></figure><h2 id="RAID-卡相关"><a href="#RAID-卡相关" class="headerlink" title="RAID 卡相关"></a>RAID 卡相关</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看raid的配置信息</span></span><br><span class="line">MegaCli -adpallinfo -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭raid卡</span></span><br><span class="line">MegaCli -adpShutDown -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">获取raid的时间</span></span><br><span class="line">MegaCli -adpGetTime -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">对raid进行诊断</span></span><br><span class="line">MegaCli -AdpDiag val -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置负载均衡，Raid卡对终端设备采用多路径访问，一半的设备通过一条路径，另一半的设备通过另一条路径，一条途径有盘插入和移除时，启动负载平衡，避免设备有重用</span></span><br><span class="line">MegaCli -AdpSetProp –LoadBalanceMode -val –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">获取raid卡的个数</span></span><br><span class="line">MegaCli –adpCount</span><br><span class="line"><span class="meta">#</span><span class="bash">获取pci信息</span></span><br><span class="line">MegaCli -AdpGetPciInfo -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">Raid卡的在线重置，fw重置raid卡控制器芯片</span></span><br><span class="line">MegaCli -AdpSetProp DisableOCR -val -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">显示raid卡，系统等的一些简单信息</span></span><br><span class="line">MegaCli -ShowSummary -f filename -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">显示每个phy的错误数</span></span><br><span class="line">MegaCli -PhyErrorCounters -a0</span><br></pre></td></tr></table></figure><h2 id="Enclosure-的信息"><a href="#Enclosure-的信息" class="headerlink" title="Enclosure 的信息"></a>Enclosure 的信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看机柜的相关信息</span></span><br><span class="line">MegaCli -encinfo -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看机柜的状态</span></span><br><span class="line">MegaCli -encstatus -a0</span><br></pre></td></tr></table></figure><h2 id="BIOS-相关"><a href="#BIOS-相关" class="headerlink" title="BIOS 相关"></a>BIOS 相关</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在启动时要按任意键才可以启动这种情况设置这个参数。但是首先要确保 bios 处于 <span class="built_in">enable</span> 状态。通过 MegaCli -AdpBIOS -dsply -a0可以查看。如果不是，先用MegaCli -AdpBIOS -enbl -a0来设置</span></span><br><span class="line">MegaCli –AdpBIOS –BE –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">把当前的Raid组作为启动</span></span><br><span class="line">MegaCli –AdpBootDrive -set -L0 -a0</span><br></pre></td></tr></table></figure><h2 id="背板相关"><a href="#背板相关" class="headerlink" title="背板相关"></a>背板相关</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果背板 <span class="built_in">disable</span> 时，会自动的去检测背板</span></span><br><span class="line">MegaCli -AdpSetProp -AutoDetectBackPlaneDsbl -val –a0</span><br></pre></td></tr></table></figure><h2 id="启动时上电"><a href="#启动时上电" class="headerlink" title="启动时上电"></a>启动时上电</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置一次上电的磁盘的个数</span></span><br><span class="line">MegaCli -AdpSetProp SpinupDriveCount -val -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置上电的延迟时间</span></span><br><span class="line">MegaCli -AdpSetProp SpinupDelay -val -a0</span><br></pre></td></tr></table></figure><h2 id="刷新缓存"><a href="#刷新缓存" class="headerlink" title="刷新缓存"></a>刷新缓存</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">刷新raid卡缓存</span></span><br><span class="line">MegaCli -AdpCacheFlush –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">刷缓存的时间间隔</span></span><br><span class="line">MegaCli -AdpSetProp CacheFlushInterval –val –a0</span><br></pre></td></tr></table></figure><h2 id="让硬盘-LED-灯闪烁"><a href="#让硬盘-LED-灯闪烁" class="headerlink" title="让硬盘 LED 灯闪烁"></a>让硬盘 LED 灯闪烁</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">开启blink</span></span><br><span class="line">MegaCli -AdpSetProp UseDiskActivityforLocate -1 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">让硬盘LED灯闪烁</span></span><br><span class="line">MegaCli -PdLocate -start –physdrv[E:S] -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">停掉硬盘LED灯</span></span><br><span class="line">MegaCli -PdLocate -stopt –physdrv[E:S] -a0</span><br></pre></td></tr></table></figure><h2 id="电池告警"><a href="#电池告警" class="headerlink" title="电池告警"></a>电池告警</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpSetProp BatWarnDsbl -val -a0</span><br></pre></td></tr></table></figure><h2 id="纠错码相关"><a href="#纠错码相关" class="headerlink" title="纠错码相关"></a>纠错码相关</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置纠错码漏桶的字节数</span></span><br><span class="line">MegaCli -AdpSetProp EccBucketSize -val -a0</span><br></pre></td></tr></table></figure><h2 id="后台初始化，完全初始化，cc-校验，巡读等之间的关系"><a href="#后台初始化，完全初始化，cc-校验，巡读等之间的关系" class="headerlink" title="后台初始化，完全初始化，cc 校验，巡读等之间的关系"></a>后台初始化，完全初始化，cc 校验，巡读等之间的关系</h2><p>后台初始化和完全初始化，cc 校验时不能进行巡读;<br>巡读时可以后台初始化和完全初始化，此时巡读结束;;<br>在后台初始化和 cc 校验时，不能开始完全初始化;<br>扩容时不能建 raid，不能添加热备盘;<br>rebuild 的优先级高于 copyback;</p><h2 id="RAID-的创建与删除"><a href="#RAID-的创建与删除" class="headerlink" title="RAID 的创建与删除"></a>RAID 的创建与删除</h2><ul><li>创建 raid 0，1，5，6</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">MegaCli -CfgLdAdd -rX[E0:S0,E1:S1,...] [WT|WB] [NORA|RA|ADRA] [Direct|Cached] [CachedBadBBU|NoCachedBadBBU] [-szXXX [-szYYY ...]] [-strpszM] [-Hsp[E0:S0,...]] [-AfterLdX] [-Force]|[FDE|CtrlBased] -a0 可以设置写模式(wt，wb)，读模式(ra，nora，adra)，缓存模式(direct，cached)，大小(sz)，条块大小(strpszM)等。比如1000G，只用指定盘的一部分(sz1000G)，设置条块的大小strpsz(设置为16k，则为strpsz16)</span></span><br><span class="line">MegaCli -cfgldadd -r5[117:1,117:3,117:11] -wb -ra -cached -cachedbadbbu -force -a0</span><br></pre></td></tr></table></figure><ul><li>创建 raid 10，50，60</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">MegaCli -CfgSpanAdd -rX-Array0[E0:S0,E1:S1] -Array1[E0:S0,E1:S1] [-ArrayX[E0:S0,E1:S1] ...] [WT|WB] [NORA|RA|ADRA] [Direct|Cached] [CachedBadBBU| NoCachedBadBBU] [-szXXX[-szYYY ...]][-strpszM][-AfterLdX][-Force] |[FDE|CtrlBased] -aN</span></span><br><span class="line">MegaCli -CfgSpanAdd -r10 -Array0[245:0,245:1] Array1[245:2,245:3] -WB -RA -Cached -Cachedbadbbu -a0</span><br></pre></td></tr></table></figure><ul><li>批量创建 raid0</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">把每个槽位的磁盘都创建为只有一个盘的raid0</span></span><br><span class="line">MegaCli -CfgEachDskRaid0 -wb -ra -cached -cachedbadbbu -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">把所有的空闲盘都加入到raid中</span></span><br><span class="line">MegaCli -CfgAllFreeDrv -r5 -SATAOnly -wb -ra -cached -cachedbadbbu -a0</span><br></pre></td></tr></table></figure><ul><li>删除 raid 组</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">清除所有的raid组的配置</span></span><br><span class="line">MegaCli -cfgclr -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">删除指定的raid组(Target Id: 0)的raid组</span></span><br><span class="line">MegaCli -cfglddel -L0 -a0</span><br></pre></td></tr></table></figure><h2 id="设置-RAID-组的属性"><a href="#设置-RAID-组的属性" class="headerlink" title="设置 RAID 组的属性"></a>设置 RAID 组的属性</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置raid组的名字</span></span><br><span class="line">MegaCli -ldsetprop -name dg -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置访问策略为读写，MegaCli -ldsetprop -blocked -L0 -a0设置访问策略为阻塞，此时raid组的设备不可以访问，fdisk -l不能发现设备</span></span><br><span class="line">MegaCli -ldsetprop -rw -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置写策略为wt(直写)，直接写入到硬盘上，然后再返回。wb模式是写入到缓存中就返回，设置wb模式写速度有显著的改善，提高到12倍</span></span><br><span class="line">MegaCli -ldsetprop -wt -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置读策略为ra(预先读出一定的数据)，还有nora模式，ra模式读可以提高到2倍左右</span></span><br><span class="line">MegaCli -ldsetprop -ra -L0 -a0 </span><br><span class="line"><span class="meta">#</span><span class="bash">设置缓存策略为cached</span></span><br><span class="line">MegaCli -ldsetprop -cached -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">开启磁盘的缓存，对写速度有一定的提高(1.4倍)</span></span><br><span class="line">MegaCli -ldsetprop -endskcache -L0 -a0</span><br></pre></td></tr></table></figure><h2 id="查询篇"><a href="#查询篇" class="headerlink" title="查询篇"></a>查询篇</h2><ul><li><p>显示 BBU 状态信息    </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpBbuCmd -GetBbuStatus –aALL </span><br><span class="line">``` </span><br><span class="line">- 显示 BBU 容量信息    </span><br><span class="line">```shell</span><br><span class="line">MegaCli -AdpBbuCmd -GetBbuCapacityInfo –aALL</span><br></pre></td></tr></table></figure></li><li><p>显示 BBU 设计参数    </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpBbuCmd -GetBbuDesignInfo –aALL</span><br></pre></td></tr></table></figure></li><li><p>显示当前 BBU 属性   </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpBbuCmd -GetBbuProperties –aALL</span><br></pre></td></tr></table></figure></li><li><p>查看充电状态    </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpBbuCmd -GetBbuStatus -aALL |grep "Charger Status"</span><br></pre></td></tr></table></figure></li><li><p>查看充电进度百分比     </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpBbuCmd -GetBbuStatus -aALL |grep "Relative State of Charge"</span><br></pre></td></tr></table></figure></li><li><p>查看所有物理磁盘信息     </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -PDList -aALL</span><br></pre></td></tr></table></figure></li><li><p>显示所有逻辑磁盘组信息     </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -LDInfo -LALL –aAll</span><br></pre></td></tr></table></figure></li><li><p>查看物理磁盘重建进度(重要)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -PDRbld -ShowProg -PhysDrv [1:5] -a0</span><br></pre></td></tr></table></figure></li><li><p>查看适配器个数    </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli –adpCount</span><br></pre></td></tr></table></figure></li><li><p>查看适配器时间     </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpGetTime –aALL</span><br></pre></td></tr></table></figure></li><li><p>显示所有适配器信息    </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpAllInfo –aAll</span><br></pre></td></tr></table></figure></li><li><p>显示 RAID 卡型号，RAID 设置，Disk 相关信息      </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -cfgdsply –aALL</span><br></pre></td></tr></table></figure></li><li><p>查询 RAID 阵列个数    </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -cfgdsply -aALL |grep "Number of DISK GROUPS:"</span><br><span class="line">``` </span><br><span class="line">- 查看 Cache 策略设置    </span><br><span class="line">```shell</span><br><span class="line">MegaCli -cfgdsply -aALL |grep Polic</span><br></pre></td></tr></table></figure></li><li><p>查看磁盘缓存策略 </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> L----&gt;[VD num or ALL] a----&gt;[Adapter num or ALL]</span></span><br><span class="line">MegaCli -LDGetProp -Cache -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash"> or </span></span><br><span class="line">MegaCli -LDGetProp -DskCache -LALL -aALL</span><br></pre></td></tr></table></figure></li><li><p>查看物理磁盘重建进度</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -PDRbld -ShowProg -PhysDrv [1:5] -a0</span><br></pre></td></tr></table></figure></li><li><p>查看 Megacli 的 log</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -FwTermLog dsply -a0 &gt; adp2.log</span><br></pre></td></tr></table></figure></li></ul><h2 id="设置篇"><a href="#设置篇" class="headerlink" title="设置篇"></a>设置篇</h2><h3 id="创建-删除阵列"><a href="#创建-删除阵列" class="headerlink" title="创建/删除阵列"></a>创建/删除阵列</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个 RAID5 阵列，由物理盘 2,3,4 构成，该阵列的热备盘是物理盘 5 </span></span><br><span class="line">MegaCli -CfgLdAdd -r5 [1:2,1:3,1:4] WB Direct -Hsp[1:5] –a0 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建阵列，不指定热备 </span></span><br><span class="line">MegaCli -CfgLdAdd -r5 [1:2,1:3,1:4] WB Direct –a0 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除阵列 </span></span><br><span class="line">MegaCli -CfgLdDel -L1 –a0 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在线添加磁盘 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重建逻辑磁盘组 1 , RAID 级别是5，添加物理磁盘号 1:4。</span></span><br><span class="line">MegaCli -LDRecon -Start -r5 -Add -PhysDrv[1:4] -L1 -a0</span><br></pre></td></tr></table></figure><p><strong>注：</strong>重建完后，新添加的物理磁盘会自动处于重建(同步)状态，这个时候 <code>fdisk -l</code>是看不到阵列的空间变大的，只有在系统重启后才能看见。 </p><h3 id="查看阵列初始化信息"><a href="#查看阵列初始化信息" class="headerlink" title="查看阵列初始化信息"></a>查看阵列初始化信息</h3><ul><li><p>阵列创建完后，会有一个初始化同步块的过程，可以查看其进度。 </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -LDInit -ShowProg -LALL -aALL </span><br><span class="line"><span class="meta">#</span><span class="bash"> or 以动态可视化文字界面显示 </span></span><br><span class="line">MegaCli -LDInit -ProgDsply -LALL –aALL</span><br></pre></td></tr></table></figure></li><li><p>查看阵列后台初始化进度</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -LDBI -ShowProg -LALL -aALL </span><br><span class="line"><span class="meta">#</span><span class="bash"> or 以动态可视化文字界面显示 </span></span><br><span class="line">MegaCli -LDBI -ProgDsply -LALL -aALL</span><br></pre></td></tr></table></figure></li></ul><h3 id="设置磁盘缓存策略"><a href="#设置磁盘缓存策略" class="headerlink" title="设置磁盘缓存策略"></a>设置磁盘缓存策略</h3><p>缓存策略解释：</p><table><thead><tr><th style="text-align:left">代码</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">WT</td><td style="text-align:left">(Write through)</td></tr><tr><td style="text-align:left">WB</td><td style="text-align:left">(Write back)</td></tr><tr><td style="text-align:left">NORA</td><td style="text-align:left">(No read ahead)</td></tr><tr><td style="text-align:left">RA</td><td style="text-align:left">(Read ahead)</td></tr><tr><td style="text-align:left">ADRA</td><td style="text-align:left">(Adaptive read ahead)</td></tr><tr><td style="text-align:left">Cached</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left">Direct</td><td style="text-align:left">-</td></tr></tbody></table><p>eg：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -LDSetProp WT|WB|NORA|RA|ADRA -L0 -a0 </span><br><span class="line"><span class="meta">#</span><span class="bash"> or </span></span><br><span class="line">MegaCli -LDSetProp -Cached|-Direct -L0 -a0 </span><br><span class="line"><span class="meta">#</span><span class="bash"> or </span></span><br><span class="line">- enable / disable disk cache </span><br><span class="line">MegaCli -LDSetProp -EnDskCache|-DisDskCache -L0 -a0</span><br></pre></td></tr></table></figure><h3 id="热备管理"><a href="#热备管理" class="headerlink" title="热备管理"></a>热备管理</h3><ul><li>创建热备</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> [1:5]----&gt;[E:S]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定第 5 块盘作为全局热备</span></span><br><span class="line">MegaCli -PDHSP -Set [-EnclAffinity] [-nonRevertible] -PhysDrv[1:5] -a0 </span><br><span class="line"><span class="meta">#</span><span class="bash"> eg：</span></span><br><span class="line">MegaCli -PDHSP   -Set   -Dedicated  -Array0  -physdrv[E:S] -a0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 为某个阵列指定专用热备 </span></span><br><span class="line">MegaCli -PDHSP -Set [-Dedicated [-Array1]] [-EnclAffinity] [-nonRevertible] -PhysDrv[1:5] -a0</span><br></pre></td></tr></table></figure><ul><li>删除热备</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -PDHSP -rmv -PhysDrv[1:5] -a0</span><br></pre></td></tr></table></figure><ul><li>将某块物理盘下线/上线 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下线</span></span><br><span class="line">MegaCli -PDOffline -PhysDrv [1:4] -a0 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 上线</span></span><br><span class="line">MegaCli -PDOnline -PhysDrv [1:4] -a0</span><br></pre></td></tr></table></figure></li></ul><p><strong>注：</strong>如果直接删除 RAID 而不操作热备，其局部热备会变为全局热备，而不是删除。</p><h2 id="管理篇"><a href="#管理篇" class="headerlink" title="管理篇"></a>管理篇</h2><ul><li><p>点亮指定硬盘（定位）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -PdLocate -start -physdrv[252:2] -a0</span><br></pre></td></tr></table></figure></li><li><p>查看 RAID 阵列中掉线的盘</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -pdgetmissing -a0</span><br></pre></td></tr></table></figure></li><li><p>替换坏掉的模块</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -pdreplacemissing -physdrv[12:10] -Array5 -row0 -a0</span><br></pre></td></tr></table></figure></li><li><p>手动开启 rebuid</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -pdrbld -start -physdrv[12:10] -a0</span><br></pre></td></tr></table></figure></li><li><p>查看 Megacli 的 log</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -FwTermLog dsply -a0 &gt; adp2.log</span><br></pre></td></tr></table></figure></li><li><p>关闭 Rebuild</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpAutoRbld -Dsbl -a0</span><br></pre></td></tr></table></figure></li><li><p>设置 rebuild 的速率</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpSetProp RebuildRate -30 -a0</span><br></pre></td></tr></table></figure></li></ul><h3 id="foreign-管理"><a href="#foreign-管理" class="headerlink" title="foreign 管理"></a>foreign 管理</h3><p>创建 RAID 前, 需要检测是否具有<code>foreign</code>配置, 如果有但此时不需要保留 RAID 时需要清除 RAID 的 <code>foreign</code>状态。</p><ul><li><p>检测是否具有 <code>foreign</code> 配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -PDlist -aALL | grep "Foreign State"</span><br></pre></td></tr></table></figure></li><li><p>将标注为 <code>Foreign</code> 磁盘标注为<code>unconfigrue good</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -PDMakeGood -PhysDrv[32:5] -a0</span><br></pre></td></tr></table></figure></li><li><p>清除 <code>foreign</code> 配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -CfgForeign -Scan -a0</span><br></pre></td></tr></table></figure></li></ul><p><strong>注</strong>：一般以上两条都要执行才能清除 <code>foreign</code> 状态</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>磁盘状态 State<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">("Failed", "Online, Spun Up", "Online, Spun Down", "Unconfigured(bad)", "Unconfigured(good), Spun down", "Hotspare, Spun down", "Hotspare, Spun up" or "not Online")</span><br></pre></td></tr></table></figure></p><h2 id="Unsolved"><a href="#Unsolved" class="headerlink" title="Unsolved"></a>Unsolved</h2><ul><li>扩展 RAID（加盘）</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -LDRecon -Start -r1 -Add -PhysDrv[252:1] -L1 -a0                                     </span><br><span class="line"><span class="meta">#</span><span class="bash"> 报错</span></span><br><span class="line">Failed to Start Reconstruction of Virtual Drive.</span><br><span class="line"></span><br><span class="line">FW error description: </span><br><span class="line"> The requested command has invalid arguments.  </span><br><span class="line"></span><br><span class="line">Exit Code: 0x03</span><br></pre></td></tr></table></figure><p><a href="http://en.community.dell.com/support-forums/servers/f/956/t/19531272" target="_blank" rel="noopener">参见这里 1</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.broadcom.com/site-search?q=megacli" target="_blank" rel="noopener">官方资源下载-broadcom</a></li><li><a href="https://techedemic.com/2014/08/07/dell-perclsi-megacli-how-to-install/" target="_blank" rel="noopener">Dell – PERC/LSI MegaCLI – How to install</a></li><li><a href="https://hwraid.le-vert.net/wiki/LSIMegaRAIDSAS#a3.1.megactl" target="_blank" rel="noopener">LSIMegaRAIDSAS</a></li><li><a href="http://zh.community.dell.com/techcenter/b/weblog/archive/2013/03/07/megacli-command-share" target="_blank" rel="noopener">DELL 磁盘阵列控制卡（RAID 卡）MegaCli 常用管理命令汇总</a></li><li><a href="http://blog.csdn.net/heart_2011/article/details/7254404" target="_blank" rel="noopener">MegaCli 命令总结 - CSDN 博客</a></li><li><a href="http://www.ha97.com/4073.html" target="_blank" rel="noopener">Linux 下查看 Raid 磁盘阵列信息的方法</a></li><li><a href="http://www.mamicode.com/info-detail-860128.html" target="_blank" rel="noopener">Megacli 常用命令</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 存储 </tag>
            
            <tag> RAID </tag>
            
            <tag> MegaCli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在搭建 Hexo 中遇到的问题记录</title>
      <link href="/blog/2017-11-18/how-to-build-hexo-blog/"/>
      <url>/blog/2017-11-18/how-to-build-hexo-blog/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><img src="/images/v2-4b229aa661f0d337bd16390761963842.jpg" alt="Github loves Hexo"></p><p><br></p><p>在网络上搜索一天多才磕磕绊绊搭建好这个博客，⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄ 现在把过程中遇到的坑记录一下，希望可以给之后的同学们带来帮助。<br><a id="more"></a></p><h2 id="npm-包管理安装太慢怎么办"><a href="#npm-包管理安装太慢怎么办" class="headerlink" title="npm 包管理安装太慢怎么办"></a>npm 包管理安装太慢怎么办</h2><ul><li><p>临时使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm --registry https://registry.npm.taobao.org install express</span><br></pre></td></tr></table></figure></li><li><p>持久使用(更换源链接为淘宝源)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置后可通过下面方式来验证是否成功</span></span><br><span class="line">npm config get registry</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">npm info express</span><br></pre></td></tr></table></figure></li><li><p>通过 cnpm 使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"># 使用</span><br><span class="line">cnpm install expresstall express</span><br></pre></td></tr></table></figure></li></ul><p>还可以参考下面这个工具:</p><p><a href="https://segmentfault.com/a/1190000000473869" target="_blank" rel="noopener">nrm —— 快速切换 NPM 源 （附带测速功能）</a></p><h2 id="我有两台电脑-换电脑后如何重新发布博客"><a href="#我有两台电脑-换电脑后如何重新发布博客" class="headerlink" title="我有两台电脑/换电脑后如何重新发布博客"></a>我有两台电脑/换电脑后如何重新发布博客</h2><p>使用 Github 的 branch 功能建立两个分支，（如：master 和 hexo）设置 hexo 分支为默认分支，然后将博客后台配置文件全部<code>push</code>到该分支。master 端为使用<code>hexo d</code>命令发布分支。</p><p><strong>注：</strong>master 分支不能当作他用，只能作为 hexo 发布之后使用。</p><p>可以参考下面链接配置<br><a href="http://www.jianshu.com/p/beb8d611340a" target="_blank" rel="noopener">Hexo 博客从一台电脑迁移到其他电脑 - 简书</a></p><h2 id="如何设置腾讯公益为-404-页面"><a href="#如何设置腾讯公益为-404-页面" class="headerlink" title="如何设置腾讯公益为 404 页面"></a>如何设置腾讯公益为 404 页面</h2><p>以下是知乎网友给出的回答：</p><blockquote><p>直接在 source 根目录下创建自己的<code>404.html</code>即可。<del>但是自定义 404 页面仅对绑定顶级域名的项目才起作用。</del></p></blockquote><p>经我试验并不一定要绑定顶级域名才可以，使用官方给出的方案设置后并不能实现错误页 页面跳转到我们设置的 404 页面。<br>以下来自 github 网友在 issues 中的解释：</p><blockquote><p>你的站点(编注：二级域名即 Github)启用了 https，腾讯公益 404 的脚本是 http 协议，因此这段脚本被阻止了。</p></blockquote><p>解决的方法是将页面里的 script 换成如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/plain"</span> src=<span class="string">"http://www.qq.com/404/search_children.js"</span> charset=<span class="string">"utf-8"</span> homePageUrl=<span class="string">"/"</span> homePageName=<span class="string">"回到我的主页"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://qzone.qq.com/gy/404/data.js"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://qzone.qq.com/gy/404/page.js"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>经试验该方法还是会出现问题，使用 F12 审查元素出现报错信息。最后使用以下方案解决该问题:</p><p><a href="https://eason-yang.com/2016/08/06/set-tencent-lostchild-404-page-for-ssl/" target="_blank" rel="noopener">使腾讯 404 公益页面支持 HTTPS</a></p><p>目前存在问题：页面会有一个卡顿加载的过程，该页面没有适配移动端。</p><h2 id="Next-主题文章页如何设置多标签"><a href="#Next-主题文章页如何设置多标签" class="headerlink" title="Next 主题文章页如何设置多标签"></a>Next 主题文章页如何设置多标签</h2><p>在文章发布页（MARKDOWN 文件顶部）添加如下字段:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 在搭建Hexo中遇到的问题记录</span><br><span class="line"># 标签（注意短横杠后的空格）</span><br><span class="line">tags:</span><br><span class="line">- HOWTO</span><br><span class="line">- Hexo</span><br><span class="line">- Hexo-Next</span><br><span class="line">- etc.</span><br><span class="line">author: imoyao</span><br></pre></td></tr></table></figure><h2 id="如何给博客文章页添加音乐"><a href="#如何给博客文章页添加音乐" class="headerlink" title="如何给博客文章页添加音乐"></a>如何给博客文章页添加音乐</h2><p>可以用音乐网站的外链，但是一般外链是<code>&lt;iframe&gt;</code>，据说这个方法影响网站的 SEO。</p><p>下面我就隆重介绍一款 HTML5 音乐播放器：Aplayer。需要用到<code>hexo-tag-aplayer</code>插件。</p><p>切换到本地 Hexo 目录，运行：</p><p><code>npm install hexo-tag-aplayer@2.0.1</code></p><p>这里直接运行<code>npm install hexo-tag-aplayer</code>只会安装 2.0.0，该版本会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FATAL Cannot find module &apos;/Users/hechao/Documents/TechBlog/CniceToUpp/node_modules/hexo-tag-aplayer&apos;</span><br><span class="line">Error: Cannot find module &apos;/Users/hechao/Documents/TechBlog/CniceToUpp/node_modules/hexo-tag-aplayer&apos;</span><br></pre></td></tr></table></figure><p>作者给出来解决方案是用 2.0.1 版本。安装完成后，在需要添加音乐的地方加上：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#This is a example.</span><br><span class="line">&#123;% aplayer &quot;平凡之路&quot; &quot;朴树&quot; &quot;https://xxx.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3&quot; &quot;https://xxx.com/1.jpg&quot; &quot;autoplay&quot; %&#125;</span><br></pre></td></tr></table></figure><p>就会出现你想要的音乐啦。</p><p><div id="aplayer0" class="aplayer" style="margin-bottom: 20px;"></div><script>new APlayer({element: document.getElementById("aplayer0"),narrow: false,autoplay: true,showlrc: 0,music: {title: "蓝莲花",author: "许巍",url: "http://oh6j8wijn.bkt.clouddn.com/%E8%93%9D%E8%8E%B2%E8%8A%B1.mp3",pic: "http://oh6j8wijn.bkt.clouddn.com/133107859321201106e3c3ede9a13305.jpeg",}});</script>`</p><p>如果你想加入歌单，把上面的代码换成下面代码就行，参数的用法可以参照插件的使用说明。</p><p><code>`</code></p><h1 id="aplayer-删除（-）"><a href="#aplayer-删除（-）" class="headerlink" title="aplayer:删除（`）"></a>aplayer:删除（`）</h1><p>`<div id="aplayer1" class="aplayer" style="margin-bottom: 20px;"></div><script>var options = {"narrow":false,"autoplay":true,"showlrc":3,"mode":"random","music":[{"title":"平凡之路","author":"朴树","url":"http://xxx.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3","pic":"https://xxx.com/1.jpg","lrc":"http://og9ocpmwk.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.txt"},{"title":"野子","author":"苏运莹","url":"http://xxx.com/01%20%E9%87%8E%E5%AD%90.m4a","pic":"http://xxxx.com/%E9%87%8E%E5%AD%90.jpg","lrc":"https://xxx.com/%E9%87%8E%E5%AD%90.txt"}]};options.element = document.getElementById("aplayer1");new APlayer(options);</script>`<br><code>`</code>plain</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p><code>material</code> 主题填坑</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">开始使用 - NexT 使用文档 </a></li><li><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">GitHub+Hexo 搭建个人网站详细教程</a></li><li><a href="http://tc9011.com/2016/12/24/hexo%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E3%80%81high%E4%B8%80%E4%B8%8B%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9D%91/" target="_blank" rel="noopener">hexo添加音乐、high一下及一些坑 | tc9011’s</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HOWTO </tag>
            
            <tag> Hexo </tag>
            
            <tag> Hexo-Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 中 exec()和 eval()的区别</title>
      <link href="/blog/2017-11-17/exec-vs-eval-in-Python/"/>
      <url>/blog/2017-11-17/exec-vs-eval-in-Python/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Python 动态执行字符串代码片段（也可以是文件）， 一般会用到 exec,eval。那么这两个方法有什么区别呢？</p><a id="more"></a><h2 id="exec-方法"><a href="#exec-方法" class="headerlink" title="exec 方法"></a>exec 方法</h2><p>注意：<code>exec</code> 是一个语法声明，不是一个函数。也就是说和<code>if</code>、<code>for</code>一样。</p><p>官方文档对于 exec 的解释</p><blockquote><p>This statement supports dynamic execution of Python code.</p></blockquote><p>exec 的第一个表达式可以是：</p><ol><li>代码字符串</li><li>文件对象</li><li>代码对象</li><li>tuple</li></ol><p>前面三种情况差不多，第四种比较特殊最后讲</p><p>如果忽略后面的可选表达式,exec 后面代码将在当前域执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=2</span><br><span class="line">&gt;&gt;&gt; exec &quot;a=1&quot;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p>如果在表达式之后使用 in 选项指定一个<code>dict</code>，它将作为<code>global</code>和<code>local</code>变量作用域<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=10 </span><br><span class="line">&gt;&gt;&gt; b=20 </span><br><span class="line">&gt;&gt;&gt; g=&#123;&apos;a&apos;:6,&apos;b&apos;:8&#125; </span><br><span class="line">&gt;&gt;&gt; exec &quot;global a;print a,b&quot; in g </span><br><span class="line">6 8</span><br></pre></td></tr></table></figure></p><p>如果<code>in</code>后详指定两个表达式，它们将分别用作<code>global</code>和<code>local</code>变量作用域<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=10 </span><br><span class="line">&gt;&gt;&gt; b=20 </span><br><span class="line">&gt;&gt;&gt; c=20 </span><br><span class="line">&gt;&gt;&gt; g=&#123;&apos;a&apos;:6,&apos;b&apos;:8&#125; </span><br><span class="line">&gt;&gt;&gt; l=&#123;&apos;b&apos;:9,&apos;c&apos;:10&#125; </span><br><span class="line">&gt;&gt;&gt; exec &quot;global a;print a,b,c&quot; in g,l </span><br><span class="line">6 9 10</span><br></pre></td></tr></table></figure></p><p>现在说下<code>tuple</code>的情况，这也是导致很多人误以为<code>exec</code>是一个函数的原因。</p><p>如果第一个表达式是<code>tuple</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec(expr, globals) #它等效于 `exec expr in globals`</span><br><span class="line"></span><br><span class="line">exec(expr, globals, locals) #它等效于  `exec expr in globals,locals`</span><br></pre></td></tr></table></figure><h2 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval()方法"></a>eval()方法</h2><p><code>eval</code>通常用来执行一个字符串表达式，并返回表达式的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eval(expression[, globals[, locals]])</span><br></pre></td></tr></table></figure><p>有三个参数，表达式字符串，globals 变量作用域，locals 变量作用域。 其中第二个和第三个参数是可选的。</p><p>如果忽略后面两个参数，则<code>eval</code>在当前作用域执行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=1 </span><br><span class="line">&gt;&gt;&gt; eval(&quot;a+1&quot;) </span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>如果指定 globals 参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=1 </span><br><span class="line">&gt;&gt;&gt; g=&#123;&apos;a&apos;:10&#125; </span><br><span class="line">&gt;&gt;&gt; eval(&quot;a+1&quot;,g) </span><br><span class="line">11</span><br></pre></td></tr></table></figure></p><p>如果指定<code>locals</code>参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=10 </span><br><span class="line">&gt;&gt;&gt; b=20 </span><br><span class="line">&gt;&gt;&gt; c=20 </span><br><span class="line">&gt;&gt;&gt; g=&#123;&apos;a&apos;:6,&apos;b&apos;:8&#125; </span><br><span class="line">&gt;&gt;&gt; l=&#123;&apos;b&apos;:9,&apos;c&apos;:10&#125; </span><br><span class="line">&gt;&gt;&gt; eval(&quot;a+b+c&quot;,g,l) </span><br><span class="line">25</span><br></pre></td></tr></table></figure></p><p>如果要严格限制<code>eval</code>执行，可以设置<code>globals</code>为<code>__builtins__</code>,这样 这个表达式只可以访问<code>__builtin__</code> module。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">exec &apos;print(&quot;hello&quot;)&apos;   #支持str的表达式动态代码执行    &gt;&gt;hello</span><br><span class="line">exec (&apos;a = 3*4&apos;)</span><br><span class="line">print a     # &gt;&gt;12</span><br><span class="line">b = eval(&apos;3*4&apos;)     #不支持表达式 有返回值</span><br><span class="line">print b     # &gt;&gt;12</span><br></pre></td></tr></table></figure><p>参考来源：</p><p><a href="http://www.coolpython.com/index.php?aid=12" target="_blank" rel="noopener">python 的 exec、eval 详解 - 疯狂奔跑的猪</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>佛与姑娘</title>
      <link href="/blog/2017-11-11/choose-Buddha-or-gril/"/>
      <url>/blog/2017-11-11/choose-Buddha-or-gril/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>青灯，古佛。喝酒、吃肉、泡姑娘。</p><p>我盘坐参了你这么长的时间，却总不见你发言。</p><p>你说五蕴皆空。可谁的心里还不藏着一个不穿衣服的姑娘；你说观法自在，可那姑娘夜夜钻我的被窝，又让我如何是好？<br><a id="more"></a></p><p><br></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=28308561&auto=1&height=32"></iframe><p><br></p><p>我想了又想，还是把她办了吧。</p><p><br></p><p>你看这苍生万物，忙碌地生，忙碌地死。你笑他们无知无力，我仰你伟大慈悲。你关照那么多的生死，我却只关心自己的琐碎。</p><p>索性我也坦胸露乳，我也装它个四大皆空。</p><p><br></p><p>于是，你是不是也该教我个蒙事的法门？一念一执，念她个死心塌地，执她个执迷不悟。</p><p>管他欢乐还是痛苦，管他喜悦还是悲伤。</p><p>花间一壶酒，对着月亮喝个死去活来，摸着姑娘的大腿喃喃道：卧槽，真是难得糊涂。</p><p><br></p><p>糊涂着，我抱着那姑娘在床单上滚来又滚去。</p><p>你掐着手印笑而不语地看着我们手淫。</p><p>我想着等头发长长了也去烫一头如你一样五蕴皆空的头发，披上一身袈裟和姑娘拉着手私奔——也还是在你的手掌心里游荡。</p><p><br></p><p>说真的，如果你爱我就赶快带我离开。</p><p>其它的东西都是扯淡，扯多了你就是耍流氓。</p><p><br></p><p>谁说释迦老爷子不耍流氓？那是他自己说的。</p><p><br></p><p>我把木鱼敲碎，把蒲团坐穿，在梦里把你摸了一遍又一遍。</p><p>我脱了这身衣服就已不再是我，我穿上了衣服自己却怎么也找不到了。</p><p><br></p><p>一时，佛在舍卫国，破衣烂钵：“可有残羹施舍？”</p><p>一个说：“去去去，哪里来的叫花，这里人人都忙着寂寞，哪有闲工夫理你。”</p><p>佛说：“寂寞这个东西，多半是姑娘闹的。可到哪去找个姑娘，不可说，不可说。”</p><p><br></p><p>说到头来还是说到姑娘。</p><p>我就说寂寞就他妈是个光着大腿的姑娘，让你看着又偏偏不让你摸。</p><p>看得你心也痒痒嘴也痒痒，总憋着法地想一些污言秽语来挑逗她。</p><p>可越是挑逗她就离你越近，离你越近就越不让你摸。</p><p><br></p><p>我觉得，这很操蛋。</p><p><br></p><p>佛说，这就是法啊，你明知它是真的却总也抓不住，你分明看不到却总在你身边转。逗着你，馋着你，说一些恼人的话来勾引你，惹你生气，惹你欢喜。</p><p><br></p><p>我说，这分明是耍流氓。</p><p>佛说，对呀，就是耍流氓，你把恶根丢了，把执念丢了，把妄想丢了，把姑娘丢了，脱光了衣服站街上，就立地成佛了。</p><p><br></p><p>我脱光了衣服站在街上，来了两个漂亮的女警察问我在做什么。</p><p>我说，我立地成佛，然后度你们出苦厄。</p><p>她们非要把我抓走，我说我<strong>日</strong>你们老母！！！</p><p><br></p><p>佛笑了，坐在远远的云端，莲花台上。</p><p>我说这不科学，众生太执，姑娘又太美，教人怎么度，怎么个无欲无求。</p><p>佛打了个哈欠，就没再说什么。</p><p><br></p><p>我觉得这有些扯，但还是耐着性子思索一些事情。</p><p>最后我决定，还是把那个勾引我的小娘们给办了。</p><p><br></p><p>办她个五蕴皆空，度她出寂寞的苦厄。</p><p><br></p>]]></content>
      
      
      <categories>
          
          <category> 悦读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美文 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
