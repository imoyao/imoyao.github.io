<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>为什么Redis这么快？</title>
      <link href="/blog/2019-09-19/Why-redis-is-so-fast/"/>
      <url>/blog/2019-09-19/Why-redis-is-so-fast/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="太长不看版"><a href="#太长不看版" class="headerlink" title="太长不看版"></a>太长不看版</h2><ol><li><p>Redis是基于内存的访问，内存的读写速度非常快；</p></li><li><p>Redis是单线程的模型。保证了每个操作的原子性，省去了很多上下文切换线程的时间以及竞态而产生的消耗；</p></li><li><p>Redis使用多路复用技术，可以处理并发的连接。非阻塞IO内部实现采用epoll，采用了epoll+自己实现的简单的事件轮询（event loop）框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</p></li><li><p>数据结构。Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</p></li></ol><h2 id="为什么Redis使用单线程？"><a href="#为什么Redis使用单线程？" class="headerlink" title="为什么Redis使用单线程？"></a>为什么Redis使用单线程？</h2><p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案。</p><h3 id="详细原因"><a href="#详细原因" class="headerlink" title="详细原因"></a>详细原因</h3><ol><li><p>不需要各种锁的性能消耗</p><p> Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除</p><p> 一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p><p> 总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p></li><li><p>单线程多进程集群方案</p><p> 单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p><p> 所以单线程、多进程的集群不失为一个时髦的解决方案。</p></li><li><p>CPU消耗</p><p> 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p></li></ol><h2 id="但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？"><a href="#但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？" class="headerlink" title="但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？"></a>但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</h2><p>可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。</p><h2 id="Redis单线程的优劣势"><a href="#Redis单线程的优劣势" class="headerlink" title="Redis单线程的优劣势"></a>Redis单线程的优劣势</h2><ol><li><p>单进程单线程优势</p><ul><li>代码更清晰，处理逻辑更简单；</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>不存在多进程或者多线程导致的切换而消耗CPU； </li></ul></li><li><p>单进程单线程弊端<br> 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</p></li></ol><h2 id="IO多路复用技术"><a href="#IO多路复用技术" class="headerlink" title="IO多路复用技术"></a>IO多路复用技术</h2><p>Redis 采用网络IO多路复用技术来保证在多连接的时候，系统的高吞吐量。</p><p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路I/O复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/u011663149/article/details/85307615" target="_blank" rel="noopener">Redis为什么是单线程、及高并发快的大原因详解</a></li><li><a href="https://www.jianshu.com/p/3d54131ee94c" target="_blank" rel="noopener">Redis 为什么快？</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Gunicorn+Gevent+Supervisor+Nginx部署Flask应用</title>
      <link href="/blog/2019-08-07/how-to-deploy-flask-with-nginx-gunicorn-gevent-supervisor/"/>
      <url>/blog/2019-08-07/how-to-deploy-flask-with-nginx-gunicorn-gevent-supervisor/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h2><ol><li><p>Nginx: 高性能<code>Web</code>服务器+负责反向代理;</p></li><li><p>gunicorn: 高性能WSGI服务器;</p></li><li><p>gevent: 将<code>Python</code>同步代码转换为异步协议库;</p></li><li><p>supervisor: 监控服务流程的工具;</p><h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-bash-4.2<span class="comment"># gunicorn --version</span></span><br><span class="line">gunicorn (version 19.9.0)</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装gunicorn和gevent"><a href="#安装gunicorn和gevent" class="headerlink" title="安装gunicorn和gevent"></a>安装gunicorn和gevent</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install gunicorn</span><br><span class="line">pip install gevent</span><br></pre></td></tr></table></figure><h2 id="配置-gunicorn"><a href="#配置-gunicorn" class="headerlink" title="配置 gunicorn"></a>配置 gunicorn</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gun.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> gevent.monkey</span><br><span class="line"></span><br><span class="line">gevent.monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'log'</span>):</span><br><span class="line">    os.mkdir(<span class="string">'log'</span>)</span><br><span class="line">debug = <span class="literal">True</span></span><br><span class="line">loglevel = <span class="string">'debug'</span></span><br><span class="line"><span class="comment"># 绑定的ip及端口号</span></span><br><span class="line">bind = <span class="string">'0.0.0.0:5000'</span></span><br><span class="line">pidfile = <span class="string">'log/gunicorn.pid'</span></span><br><span class="line">logfile = <span class="string">'log/debug.log'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动的进程数</span></span><br><span class="line">workers = multiprocessing.cpu_count() * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">worker_class = <span class="string">'gunicorn.workers.ggevent.GeventWorker'</span></span><br><span class="line"></span><br><span class="line">x_forwarded_for_header = <span class="string">'X-FORWARDED-FOR'</span></span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-bash-4.2<span class="comment"># gunicorn -k gevent -c gun.py runserver:app</span></span><br><span class="line">[2019-08-07 16:00:20 +0800] [32111] [DEBUG] Current configuration:</span><br><span class="line">  config: gun.py</span><br><span class="line">  <span class="built_in">bind</span>: [<span class="string">'0.0.0.0:5000'</span>]</span><br><span class="line">  backlog: 2048</span><br><span class="line">  workers: 3</span><br><span class="line">  worker_class: gevent</span><br><span class="line">  threads: 1</span><br><span class="line">  worker_connections: 1000</span><br><span class="line">  max_requests: 0</span><br><span class="line">  max_requests_jitter: 0</span><br><span class="line">  timeout: 30</span><br><span class="line">  graceful_timeout: 30</span><br><span class="line">  keepalive: 2</span><br><span class="line">  limit_request_line: 4094</span><br><span class="line">  limit_request_fields: 100</span><br><span class="line">  limit_request_field_size: 8190</span><br><span class="line">  reload: False</span><br><span class="line">  reload_engine: auto</span><br><span class="line">  reload_extra_files: []</span><br><span class="line">  spew: False</span><br><span class="line">  check_config: False</span><br><span class="line">  preload_app: False</span><br><span class="line">  sendfile: None</span><br><span class="line">  reuse_port: False</span><br><span class="line">  <span class="built_in">chdir</span>: /root/PMMT</span><br><span class="line">  daemon: False</span><br><span class="line">  raw_env: []</span><br><span class="line">  pidfile: <span class="built_in">log</span>/gunicorn.pid</span><br><span class="line">  worker_tmp_dir: None</span><br><span class="line">  user: 0</span><br><span class="line">  group: 0</span><br><span class="line">  <span class="built_in">umask</span>: 0</span><br><span class="line">  initgroups: False</span><br><span class="line">  tmp_upload_dir: None</span><br><span class="line">  secure_scheme_headers: &#123;<span class="string">'X-FORWARDED-PROTOCOL'</span>: <span class="string">'ssl'</span>, <span class="string">'X-FORWARDED-PROTO'</span>: <span class="string">'https'</span>, <span class="string">'X-FORWARDED-SSL'</span>: <span class="string">'on'</span>&#125;</span><br><span class="line">  forwarded_allow_ips: [<span class="string">'127.0.0.1'</span>]</span><br><span class="line">  accesslog: None</span><br><span class="line">  disable_redirect_access_to_syslog: False</span><br><span class="line">  access_log_format: %(h)s %(l)s %(u)s %(t)s <span class="string">"%(r)s"</span> %(s)s %(b)s <span class="string">"%(f)s"</span> <span class="string">"%(a)s"</span></span><br><span class="line">  errorlog: -</span><br><span class="line">  loglevel: debug</span><br><span class="line">  capture_output: False</span><br><span class="line">  logger_class: gunicorn.glogging.Logger</span><br><span class="line">  logconfig: None</span><br><span class="line">  logconfig_dict: &#123;&#125;</span><br><span class="line">  syslog_addr: udp://localhost:514</span><br><span class="line">  syslog: False</span><br><span class="line">  syslog_prefix: None</span><br><span class="line">  syslog_facility: user</span><br><span class="line">  enable_stdio_inheritance: False</span><br><span class="line">  statsd_host: None</span><br><span class="line">  statsd_prefix: </span><br><span class="line">  proc_name: None</span><br><span class="line">  default_proc_name: runserver:app</span><br><span class="line">  pythonpath: None</span><br><span class="line">  paste: None</span><br><span class="line">  on_starting: &lt;<span class="keyword">function</span> OnStarting.on_starting at 0x7fbf4cf806a8&gt;</span><br><span class="line">  on_reload: &lt;<span class="keyword">function</span> OnReload.on_reload at 0x7fbf4cf807b8&gt;</span><br><span class="line">  when_ready: &lt;<span class="keyword">function</span> WhenReady.when_ready at 0x7fbf4cf808c8&gt;</span><br><span class="line">  pre_fork: &lt;<span class="keyword">function</span> Prefork.pre_fork at 0x7fbf4cf809d8&gt;</span><br><span class="line">  post_fork: &lt;<span class="keyword">function</span> Postfork.post_fork at 0x7fbf4cf80ae8&gt;</span><br><span class="line">  post_worker_init: &lt;<span class="keyword">function</span> PostWorkerInit.post_worker_init at 0x7fbf4cf80bf8&gt;</span><br><span class="line">  worker_int: &lt;<span class="keyword">function</span> WorkerInt.worker_int at 0x7fbf4cf80d08&gt;</span><br><span class="line">  worker_abort: &lt;<span class="keyword">function</span> WorkerAbort.worker_abort at 0x7fbf4cf80e18&gt;</span><br><span class="line">  pre_exec: &lt;<span class="keyword">function</span> PreExec.pre_exec at 0x7fbf4cf80f28&gt;</span><br><span class="line">  pre_request: &lt;<span class="keyword">function</span> PreRequest.pre_request at 0x7fbf4cf960d0&gt;</span><br><span class="line">  post_request: &lt;<span class="keyword">function</span> PostRequest.post_request at 0x7fbf4cf96158&gt;</span><br><span class="line">  child_exit: &lt;<span class="keyword">function</span> ChildExit.child_exit at 0x7fbf4cf96268&gt;</span><br><span class="line">  worker_exit: &lt;<span class="keyword">function</span> WorkerExit.worker_exit at 0x7fbf4cf96378&gt;</span><br><span class="line">  nworkers_changed: &lt;<span class="keyword">function</span> NumWorkersChanged.nworkers_changed at 0x7fbf4cf96488&gt;</span><br><span class="line">  on_exit: &lt;<span class="keyword">function</span> OnExit.on_exit at 0x7fbf4cf96598&gt;</span><br><span class="line">  proxy_protocol: False</span><br><span class="line">  proxy_allow_ips: [<span class="string">'127.0.0.1'</span>]</span><br><span class="line">  keyfile: None</span><br><span class="line">  certfile: None</span><br><span class="line">  ssl_version: 2</span><br><span class="line">  cert_reqs: 0</span><br><span class="line">  ca_certs: None</span><br><span class="line">  suppress_ragged_eofs: True</span><br><span class="line">  do_handshake_on_connect: False</span><br><span class="line">  ciphers: TLSv1</span><br><span class="line">  raw_paste_global_conf: []</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32111] [INFO] Starting gunicorn 19.9.0</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32111] [DEBUG] Arbiter booted</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32111] [INFO] Listening at: http://0.0.0.0:5000 (32111)</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32111] [INFO] Using worker: gevent</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32115] [INFO] Booting worker with pid: 32115</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32116] [INFO] Booting worker with pid: 32116</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32117] [INFO] Booting worker with pid: 32117</span><br><span class="line">[2019-08-07 16:00:20 +0800] [32111] [DEBUG] 3 workers</span><br></pre></td></tr></table></figure><p>此时正常访问<code>http://10.10.15.111:5000/</code>应该可以看到首页信息提示表示连接服务正常。<br><strong>注意</strong>：此处ip和端口均由自己设置，所以访问时应该做相应调整。<br>如果无法正常访问，则需要验证防火墙是否正常：  </p><ul><li><p>CentOS 7 以下版本  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询</span></span><br><span class="line">-bash-4.2<span class="comment"># iptables -nL|grep 5000</span></span><br><span class="line"><span class="comment"># 开放指定端口</span></span><br><span class="line">-bash-4.2<span class="comment"># iptables -I INPUT -p tcp --dport 5000 -j ACCEPT</span></span><br><span class="line"><span class="comment"># 再次查询</span></span><br><span class="line">-bash-4.2<span class="comment"># iptables -nL|grep 5000</span></span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:5000</span><br></pre></td></tr></table></figure></li><li><p>CentOS7<br>使用<code>firewall-cmd</code>管理防火墙端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --query-port=5000/tcp      <span class="comment"># no</span></span><br><span class="line">firewall-cmd --add-port=5000/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --query-port=5000/tcp  <span class="comment"># yes</span></span><br><span class="line">systemctl status firewall</span><br><span class="line">systemctl status firewalld</span><br><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure></li></ul><h2 id="安装nginx和supervisor"><a href="#安装nginx和supervisor" class="headerlink" title="安装nginx和supervisor"></a>安装nginx和supervisor</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install nginx supervisor</span><br></pre></td></tr></table></figure><h3 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h3><p>默认安装的Nginx配置文件<code>/etc/nginx/nginx.conf</code>内有如下配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include /etc/nginx/conf.d/*.conf;</span><br></pre></td></tr></table></figure><p>即从外部目录<code>/etc/nginx/conf.d/</code>文件夹下还引入了其他配置文件。<br>这样，我们不修改默认配置，只在<code>/etc/nginx/conf.d/</code>目录下增加一个<code>***.conf</code>，来在外面增加新配置。</p><p>在<code>/etc/nginx/conf.d/</code>增加<code>app.conf</code>，内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  80;     <span class="comment"># 如果80端口被占用，可以使用其他端口，记得在防火墙中打开相应端口</span></span><br><span class="line">    server_name localhost;</span><br><span class="line">    charset utf-8; </span><br><span class="line">    access_log /var/pmmt/access.log;</span><br><span class="line">    error_log /var/pmmt/error.log;</span><br><span class="line"></span><br><span class="line">    client_max_body_size 100M;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_pass  http://0.0.0.0:5000;</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_connect_timeout 300;</span><br><span class="line">            proxy_send_timeout 300;</span><br><span class="line">            proxy_read_timeout 300;</span><br><span class="line">            send_timeout 300;</span><br><span class="line">            proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">            proxy_set_header Connection <span class="string">"upgrade"</span>;</span><br><span class="line">            proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">            proxy_set_header X-Scheme <span class="variable">$scheme</span>;</span><br><span class="line">            proxy_set_header X-Forwarded-For <span class="variable">$remote_addr</span>;</span><br><span class="line">            proxy_set_header X-Forwarded-Port <span class="variable">$server_port</span>;</span><br><span class="line">            proxy_set_header X-Request-Start <span class="variable">$msec</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动服务-1"><a href="#启动服务-1" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><ul><li>报错<code>nginx: [emerg] getpwnam(&quot;nginx&quot;) failed in /etc/nginx/nginx.conf:5</code><br>查看配置该行内容为<code>user nginx;</code>，添加用户<code>useradd nginx</code>；</li></ul><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><ul><li><p>ERR_CONTENT_LENGTH_MISMATCH<br>  查看nginx错误日志</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tailf /var/<span class="built_in">log</span>/nginx/error.log</span><br><span class="line">2019/08/09 03:04:21 [crit] 24616<span class="comment">#0: *204 open() "/var/lib/nginx/tmp/proxy/2/03/0000000032" failed (13: Permission denied) while reading upstream, client: 10.10.15.199, server: localhost, request: "GET /static/js/app.1b53c809113e333c2727.js.map HTTP/1.1", upstream: "http://0.0.0.0:5000/static/js/app.1b53c809113e333c2727.js.map", host: "10.10.15.111:82"</span></span><br></pre></td></tr></table></figure><p>  参考这里：<a href="https://blog.csdn.net/mr_ooo/article/details/81068369" target="_blank" rel="noopener">ERR_CONTENT_LENGTH_MISMATCH解决方法</a>      </p></li><li>进入首页出现<code>403 Forbidden</code><ol><li>nginx启动用户和配置中的工作用户不一致；</li><li>配置文件中缺少index index.html index.htm index.php 行；</li><li>nginx用户没有响应工作目录的操作权限（<code>chown -R nginx:nginx WORK_DIR_PATH</code>）；</li><li>防火墙设置。<br>参考这里：<a href="https://blog.csdn.net/onlysunnyboy/article/details/75270533" target="_blank" rel="noopener">解决Nginx出现403 forbidden (13: Permission denied)报错的四种方法</a></li></ol></li></ul><h2 id="配置Supervisor"><a href="#配置Supervisor" class="headerlink" title="配置Supervisor"></a>配置Supervisor</h2><p>首先检查是否存在配置文件，一般配置文件的路径是<code>/etc/supervisord.conf</code>，如果配置文件不存在，我们可以通过命令来生成：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /etc/supervisord.conf</span><br></pre></td></tr></table></figure></p><p>配置文件的内容很多，项目配置可以参照<a href="http://www.supervisord.org/introduction.html" target="_blank" rel="noopener">官网文档</a></p><p>打开配置文件的最后一行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">;[include]</span><br><span class="line">;files = /etc/supervisord/*.conf    <span class="comment"># 注意：本人安装版本为ini格式，所以我们自写的配置也应该调整为相应的.ini格式[include] \n files = supervisord.d/*.ini</span></span><br></pre></td></tr></table></figure></p><p>默认一般是注释掉的，我们可以取消注释，这行配置的作用也很浅显，就是导入设置的路径下的所有<code>conf</code>文件，这使得我们如果有多个项目可以不用都写在同一个配置文件里，可以一个项目一个配置文件，更适合管理。这里的路径也是可以按照实际需求随意更改。<br>手动启动Supervisord<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">supervisord -c /etc/supervisord.conf</span><br></pre></td></tr></table></figure></p><p>在设置的路径下新建一个配置文件，命令请根据上一步设置的扩展名。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[program:project_name]</span><br><span class="line"><span class="built_in">command</span>=/usr/bin/gunicorn -c gun.py runserver:app       <span class="comment"># 具体路径根据自己安装或者虚拟环境中的位置进行配置</span></span><br><span class="line">directory=/project_path/        <span class="comment"># 项目路径</span></span><br><span class="line">startsecs=0</span><br><span class="line">stopwaitsecs=0</span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line">autorestart=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p><code>project_name</code>按照你的实际需求修改，作为你这个服务的唯一标识，用于启动停止服务时使用。<br><code>command</code>修改为测试<code>gunicorn</code>时使用的命令，建议使用绝对路径。<br><code>directory</code>指定了工作路径，通常设置为项目根目录，我们填写的gun.py和app都是基于这个路径的。</p><p>管理<code>Supervisor</code>的项目是使用<code>supervisorctl</code>命令，我们可以启动项目试试看</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">supervisorctl start PROJECT_NAME</span><br></pre></td></tr></table></figure><p>如果没有报错，应该可以和上一步测试<code>gunicorn</code>一样可以正常访问项目了。<br>验证<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-bash-4.2<span class="comment"># supervisorctl</span></span><br><span class="line">app                              RUNNING   pid 24639, uptime 0:20:55</span><br></pre></td></tr></table></figure></p><h3 id="报错记录"><a href="#报错记录" class="headerlink" title="报错记录"></a>报错记录</h3><ul><li>Error: Another program is already listening on a port that one of our HTTP servers is configured to use.  Shut this program down first before starting supervisord. For help, use /usr/bin/supervisord -h  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以查看supervisor.sock并删除 </span></span><br><span class="line">-bash-4.2<span class="comment"># find / -name supervisor.sock </span></span><br><span class="line">/run/supervisor/supervisor.sock</span><br><span class="line">-bash-4.2<span class="comment"># unlink /run/supervisor/supervisor.sock</span></span><br></pre></td></tr></table></figure></li></ul><p>再次重新启动<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-bash-4.2<span class="comment"># supervisord -c /etc/supervisord.conf</span></span><br></pre></td></tr></table></figure></p><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><ol><li><a href="https://programmer.help/blogs/5c13afa73d10a.html" target="_blank" rel="noopener">Huawei Cloud Centos7 Flask+Gunicorn+Gevent+Supervisor+Nginx Multi-site Production Environment Deployment</a></li><li><a href="https://www.jianshu.com/p/192e62a5cdd2" target="_blank" rel="noopener">Flask + Nginx + Gunicorn + Gevent部署</a></li><li><a href="https://www.jianshu.com/p/65fae00615b9" target="_blank" rel="noopener">gunicorn+gevent+nginx部署flask应用</a></li><li><a href="https://blog.csdn.net/spark_csdn/article/details/80790929" target="_blank" rel="noopener">CentOS 上 Flask + uWSGI + Nginx 部署</a></li><li><a href="https://www.zhihu.com/question/38528616" target="_blank" rel="noopener">Nginx、Gunicorn在服务器中分别起什么作用</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> Nginx </tag>
            
            <tag> 部署 </tag>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 报错&quot;TypeError:a-bytes-like-object-is-required,not-&#39;str&#39;&quot;解决办法</title>
      <link href="/blog/2019-07-11/a-bytes-like-object-is-required-not-str-python3/"/>
      <url>/blog/2019-07-11/a-bytes-like-object-is-required-not-str-python3/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天在解析一个工具输出问题时遇到这两个编码错误，记录一下。</p><ul><li>TypeError: a bytes-like object is required, not ‘str’</li><li>UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xb3 in position 38: invalid start byte<a id="more"></a></li></ul><h2 id="先上代码"><a href="#先上代码" class="headerlink" title="先上代码"></a>先上代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecCommandError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecCommand</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cust_popen_list</span><span class="params">(cmdlist, close_fds=True)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        subprocess.call只接受数组变量作为命令，并将数组的第一个元素作为命令，剩下的全部作为该命令的参数。</span></span><br><span class="line"><span class="string">        :param cmdlist:</span></span><br><span class="line"><span class="string">        :param close_fds:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lastcmdlist = list()</span><br><span class="line">        lastcmdlist.extend(cmdlist)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            proc = subprocess.Popen(lastcmdlist, shell=<span class="literal">False</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE,</span><br><span class="line">                                    close_fds=close_fds)</span><br><span class="line">            retcode = proc.wait()</span><br><span class="line">            <span class="keyword">return</span> retcode, proc</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> (ExecCommandError, e)</span><br><span class="line">            </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HwMaker</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.retcode = <span class="number">1</span></span><br><span class="line">        self.proc = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exec_command</span><span class="params">(cmd_list=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        调用执行命令的程序</span></span><br><span class="line"><span class="string">        :param cmd_list: list,</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">assert</span> cmd_list</span><br><span class="line">        cmd = ExecCommand()</span><br><span class="line">        <span class="keyword">return</span> cmd.cust_popen_list(cmd_list)</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_label</span><span class="params">(label)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        如果以空格分割，则替换为 with_under_case,最后调用lower()返回lower_with_under_case</span></span><br><span class="line"><span class="string">        :param label:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        split_label = label.split()</span><br><span class="line">        label = <span class="string">'_'</span>.join([span.lower() <span class="keyword">for</span> span <span class="keyword">in</span> split_label]) <span class="keyword">if</span> len(split_label) &gt; <span class="number">1</span> <span class="keyword">else</span> label.lower()</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensorMaker</span><span class="params">(HwMaker)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">secs2hours</span><span class="params">(secs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        秒转化为小时</span></span><br><span class="line"><span class="string">        :param secs:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        mm, ss = divmod(secs, <span class="number">60</span>)</span><br><span class="line">        hh, mm = divmod(mm, <span class="number">60</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"%d:%02d:%02d"</span> % (hh, mm, ss)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_vertical_line</span><span class="params">(self, parser_data)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        以“|” 分割之后获取有用信息</span></span><br><span class="line"><span class="string">        :param parser_data:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        _expect_info = dict()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> parser_data:</span><br><span class="line">            strip_line = line.strip().decode(<span class="string">'utf-8'</span>, <span class="string">"ignore"</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'|'</span> <span class="keyword">in</span> strip_line:</span><br><span class="line">                item, value = [item.strip() <span class="keyword">for</span> item <span class="keyword">in</span> strip_line.split(<span class="string">'|'</span>)]</span><br><span class="line">                lower_label = self.make_label(item)</span><br><span class="line">                _expect_info[lower_label] = value</span><br><span class="line">        <span class="keyword">return</span> _expect_info</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ipmi_pminfo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">         [SlaveAddress = B2h] [Module 2]</span></span><br><span class="line"><span class="string">         Item                           |                Value</span></span><br><span class="line"><span class="string">         ----                           |                -----</span></span><br><span class="line"><span class="string">         Status                         |     [STATUS OK](00h)</span></span><br><span class="line"><span class="string">         AC Input Voltage               |              237.0 V</span></span><br><span class="line"><span class="string">         AC Input Current               |               0.36 A</span></span><br><span class="line"><span class="string">         DC 12V Output Voltage          |              12.04 V</span></span><br><span class="line"><span class="string">         DC 12V Output Current          |               5.07 A</span></span><br><span class="line"><span class="string">         Temperature 1                  |              34C/94F</span></span><br><span class="line"><span class="string">         Temperature 2                  |              37C/98F</span></span><br><span class="line"><span class="string">         Fan 1                          |             5400 RPM</span></span><br><span class="line"><span class="string">         Fan 2                          |              985 RPM</span></span><br><span class="line"><span class="string">         DC 12V Output Power            |                 61 W</span></span><br><span class="line"><span class="string">         AC Input Power                 |                 78 W</span></span><br><span class="line"><span class="string">         PMBus Revision                 |               0xD222</span></span><br><span class="line"><span class="string">         PWS Serial Number              |      ³³³³³³³U³³³³³³³</span></span><br><span class="line"><span class="string">         PWS Module Number              |         ³³³³³³³³³³³³</span></span><br><span class="line"><span class="string">         PWS Revision                   |               ³³³³³³</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         out: &#123;'status': '[STATUS OK](00h)',</span></span><br><span class="line"><span class="string">             'ac_input_voltage': '237.0 V',</span></span><br><span class="line"><span class="string">             'ac_input_current': '0.39 A',</span></span><br><span class="line"><span class="string">             'dc_12v_output_voltage': '12.04 V',</span></span><br><span class="line"><span class="string">             'dc_12v_output_current': '5.19 A',</span></span><br><span class="line"><span class="string">             'temperature_1': '34C/94F',</span></span><br><span class="line"><span class="string">             'temperature_2': '37C/98F',</span></span><br><span class="line"><span class="string">             'fan_1': '5424 RPM',</span></span><br><span class="line"><span class="string">             'fan_2': '985 RPM',</span></span><br><span class="line"><span class="string">             'dc_12v_output_power': '63 W',</span></span><br><span class="line"><span class="string">             'ac_input_power': '71 W',</span></span><br><span class="line"><span class="string">             'pmbus_revision': '0xD222',</span></span><br><span class="line"><span class="string">             'pws_serial_number': 'U',</span></span><br><span class="line"><span class="string">             'pws_module_number': '',</span></span><br><span class="line"><span class="string">             'pws_revision': ''&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        _pm_info = &#123;&#125;</span><br><span class="line">        _cmd = [<span class="string">'ipmicfg'</span>, <span class="string">'-pminfo'</span>]</span><br><span class="line">        self.retcode, self.proc = self.exec_command(_cmd)</span><br><span class="line">        <span class="keyword">if</span> self.retcode == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 截取有用行（排除前三行）</span></span><br><span class="line">            out_data = self.out_data()</span><br><span class="line">            <span class="keyword">if</span> out_data:</span><br><span class="line">                _pm_info = self.parse_vertical_line(out_data[<span class="number">3</span>:])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> _pm_info</span><br></pre></td></tr></table></figure><h2 id="原因解释及解决方案"><a href="#原因解释及解决方案" class="headerlink" title="原因解释及解决方案"></a>原因解释及解决方案</h2><p>关于<code>TypeError: a bytes-like object is required, not &#39;str&#39;</code>错误，我们可以这样复现一下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: a = <span class="string">b'123|456'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: a.split(<span class="string">'|'</span>)                                                                                         </span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-17</span>-d4229c89bf5f&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 a.split('|')</span><br><span class="line"></span><br><span class="line">TypeError: a bytes-like object <span class="keyword">is</span> required, <span class="keyword">not</span> <span class="string">'str'</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: a = <span class="string">b'123|456'</span>                                                                                        </span><br><span class="line">In [<span class="number">21</span>]: a.decode(<span class="string">'utf-8'</span>).split(<span class="string">'|'</span>)                                                                         </span><br><span class="line">Out[<span class="number">21</span>]: [<span class="string">'123'</span>, <span class="string">'456'</span>]</span><br></pre></td></tr></table></figure><p>关于问题<code>UnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0xb3 in position 38: invalid start byte</code>，主要是因为结果中有<code>³³³³³³³U³³³³³³³</code>,这个没有办法按照<code>utf-8</code>解码。<br>出现异常报错是由于设置了<code>decode()</code>方法的第二个参数<code>errors</code>为严格（<code>strict</code>）形式造成的，因为默认就是这个参数，将其更改为<code>ignore</code>即可。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/wang7807564/article/details/78164855/" target="_blank" rel="noopener">Python3解决UnicodeDecodeError: ‘utf-8’ codec can’t decode byte..问题 终极解决方案</a></li><li><a href="https://stackoverflow.com/questions/33054527/typeerror-a-bytes-like-object-is-required-not-str-when-writing-to-a-file-in" target="_blank" rel="noopener">TypeError: a bytes-like object is required, not ‘str’ when writing to a file in Python3</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在 Vue 中实现显示全部的功能？</title>
      <link href="/blog/2019-07-05/how-to-make-show-all-with-Vue/"/>
      <url>/blog/2019-07-05/how-to-make-show-all-with-Vue/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h2><p>我们可以简单分析一下功能实现：</p><ol><li>显示内容是从后台一次性获取到的，不存在点击“阅读更多”再去请求一次后台获取剩余数据的可能；</li><li>通过第一步其实可以得出，网站是通过控制显示元素的高度来实现这一功能，而非控制内容的获取；</li><li>可以看到“阅读更多”按钮上有一层渐变遮罩层，网站通过这一遮罩挡住剩余内容。</li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-for=&quot;(item, key) in testItems&quot; v-show=&quot;key&lt;limitShowNum&quot;&gt;</span><br><span class="line">      &#123;&#123;item&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;el-button @click=&quot;showMore&quot; type=&quot;text&quot; style=&quot;color:#79bbff;&quot;&gt;&#123;&#123;showAllTip&#125;&#125;&lt;/el-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;</span><br><span class="line">&lt;!-- 引入组件库 --&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">          testItems: [&apos;海客谈瀛洲，烟涛微茫信难求；&apos;, &apos;越人语天姥，云霞明灭或可睹。&apos;, &apos;天姥连天向天横，势拔五岳掩赤城。&apos;, &apos;天台四万八千丈，对此欲倒东南倾。&apos;, &apos;我欲因之梦吴越，一夜飞度镜湖月。&apos;, &apos;湖月照我影，送我至剡溪。&apos;, &apos;谢公宿处今尚在，渌水荡漾清猿啼。&apos;, &apos;脚著谢公屐，身登青云梯。&apos;, &apos;半壁见海日，空中闻天鸡。&apos;, &apos;千岩万转路不定，迷花倚石忽已暝。&apos;, &apos;熊咆龙吟殷岩泉，栗深林兮惊层巅。&apos;, &apos;云青青兮欲雨，水澹澹兮生烟。&apos;, &apos;列缺霹雳，丘峦崩摧。&apos;, &apos;洞天石扉，訇然中开。&apos;, &apos;青冥浩荡不见底，日月照耀金银台。&apos;, &apos;霓为衣兮风为马，云之君兮纷纷而来下。&apos;, &apos;虎鼓瑟兮鸾回车，仙之人兮列如麻。&apos;, &apos;忽魂悸以魄动，恍惊起而长嗟。&apos;, &apos;惟觉时之枕席，失向来之烟霞。&apos;, &apos;世间行乐亦如此，古来万事东流水。&apos;, &apos;别君去兮何时还？且放白鹿青崖间。须行即骑访名山。&apos;, &apos;安能摧眉折腰事权贵，使我不得开心颜！&apos;],</span><br><span class="line">          isShow: true,</span><br><span class="line">  showAllTip: &apos;我全都要 😜&apos;,</span><br><span class="line">  limitShowNum: 5,</span><br><span class="line">      defaultShowNum:5</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        // 功能实现</span><br><span class="line">        showMore()&#123;</span><br><span class="line">let showDataLen = this.testItems.length</span><br><span class="line">this.isShow = !this.isShow;</span><br><span class="line">this.limitShowNum = this.isShow? this.defaultShowNum: showDataLen;</span><br><span class="line">this.showAllTip = this.isShow?&apos;我全都要 😜&apos;:&apos;收起&apos;</span><br><span class="line">&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h2><p>此处显示与直接代码运行效果不一样，主要是因为样式以及添加i标签图标等导致；样式不会写的话可以参考<code>element-ui</code>官方文档的实现。</p><p><img src="/images/show_all_example.gif" alt="显示全部与折叠"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/XuM222222/article/details/80189355" target="_blank" rel="noopener">利用vue实现“显示更多”功能</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> element-ui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask-sqlalchemy中的多对多关系模型问题记录</title>
      <link href="/blog/2019-07-03/flask-sqlalchemy-many-to-many/"/>
      <url>/blog/2019-07-03/flask-sqlalchemy-many-to-many/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlalchemy.exc.InvalidRequestError: One or more mappers failed to initialize - can<span class="string">'t proceed with initialization of other mappers. Triggering mapper: '</span>mapped class Article-&gt;iy_article<span class="string">'. Original exception was: Error creating backref '</span>articles<span class="string">' on relationship '</span>Article.tags<span class="string">': property of that name exists on mapper '</span>mapped class Tag-&gt;iy_tag<span class="string">'</span></span><br></pre></td></tr></table></figure><p>出现这个错误是因为两个关系表中互相定义，意思是你的代码中可能同时包含下面的语句：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class Article:</span></span><br><span class="line"></span><br><span class="line">tags = db.relationship(<span class="string">'Tag'</span>, secondary=posts_tags_table, backref=db.backref(<span class="string">'articles'</span>, lazy=<span class="string">'dynamic'</span>),</span><br><span class="line">                               lazy=<span class="string">"dynamic"</span>)</span><br><span class="line"><span class="comment"># Class Tag:                            </span></span><br><span class="line">articles = db.relationship(<span class="string">'Article'</span>, secondary=posts_tags_table,</span><br><span class="line">    <span class="comment">#                            back_populates='tags')</span></span><br></pre></td></tr></table></figure><h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p>当您使用<code>backref</code>时，<code>SQLAlchemy</code>会自动创建向后关联，因此它（backref）<strong>只应该</strong>在关系的一侧使用。所以应该删除上面其中的一句定义。</p><p>参见这里<br><a href="https://stackoverflow.com/questions/39869793/when-do-i-need-to-use-sqlalchemy-back-populates" target="_blank" rel="noopener">when-do-i-need-to-use-sqlalchemy-back-populates</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlalchemy.orm.exc.StaleDataError: DELETE statement on table <span class="string">'iy_post_tags'</span> expected to delete 4 row(s); Only 24 were matched.</span><br></pre></td></tr></table></figure><h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h3><p>出现这个问题原因是在多对多关系的关联表中，出现了重复数据。<br>书上说“将某个Book的Writer属性设置为None,就会解除与Writer对象的关系。”<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">post_obj = Article.query.filter(Article.post_id == post_id).one()</span><br><span class="line"><span class="keyword">if</span> post_obj:</span><br><span class="line">    body_id = post_obj.body_id</span><br><span class="line">    post_obj.tags = <span class="literal">None</span></span><br><span class="line">    db.session.commit()</span><br></pre></td></tr></table></figure></p><p>失败！！！</p><p>再次参考<a href="https://seagullbird.xyz/posts/how-to-delete-many-to-many-in-sqlalchemy/" target="_blank" rel="noopener">How to delete a Many-to-Many relationship in Flask-SQLAlchemy</a><br>作者提到可能是因为对数据手动处理的问题。<br>验证数据表中是否存在重复数据：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; delete from iy_post_tags where post_id=26;</span><br><span class="line">Query OK, 2 rows affected (0.22 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from iy_post_tags;</span><br><span class="line">+<span class="comment">---------+--------+</span></span><br><span class="line">| post_id | tag_id |</span><br><span class="line">+<span class="comment">---------+--------+</span></span><br><span class="line">|      20 |      7 |</span><br><span class="line">|      21 |      7 |</span><br><span class="line">|      22 |      7 |</span><br><span class="line">|      23 |      7 |</span><br><span class="line">|      24 |      7 |</span><br><span class="line">|      24 |      7 |</span><br><span class="line">|      20 |      7 |</span><br><span class="line">|      25 |      7 |</span><br><span class="line">|      27 |      7 |    <span class="comment">-- 注意这两行，表中出现同一篇文章，标签相同记录两次的情况，此时删除操作就会报错</span></span><br><span class="line">|      27 |      7 |</span><br><span class="line">+<span class="comment">---------+--------+</span></span><br></pre></td></tr></table></figure></p><p>的确存在，可以手动删除。</p><h3 id="利用代码限制永久解决"><a href="#利用代码限制永久解决" class="headerlink" title="利用代码限制永久解决"></a>利用代码限制永久解决</h3><p>还有<a href="https://stackoverflow.com/questions/36002638/how-to-fix-sqlalchemy-sawarning-delete-statement-on-table-expected-to-delete-1" target="_blank" rel="noopener">这里</a><br>修改表结构，解除确认删除。</p><p>利用主键唯一约束，在创建中间表的时候进行限制<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置： primary_key=True</span></span><br><span class="line">article_tag_rel = sa.Table(<span class="string">'article_tag_rel'</span>, Base.metadata,</span><br><span class="line">    sa.Column(<span class="string">'tag_id'</span>, sa.Integer, ForeignKey(<span class="string">'tag.id'</span>), primary_key=<span class="literal">True</span>),</span><br><span class="line">    sa.Column(<span class="string">'article_id'</span>, sa.Integer, ForeignKey(<span class="string">'article.id'</span>), primary_key=<span class="literal">True</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>参见<a href="https://github.com/kvesteri/sqlalchemy-continuum/issues/65" target="_blank" rel="noopener">这里</a><br>还有<a href="https://stackoverflow.com/questions/36002638/how-to-fix-sqlalchemy-sawarning-delete-statement-on-table-expected-to-delete-1" target="_blank" rel="noopener">这里</a>是修改表结构<br><a href="https://stackoverflow.com/questions/41941273/deleting-from-a-sqlalchemy-many-to-many-matches-the-wrong-number-of-rows" target="_blank" rel="noopener">这里</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上面的一种简便写法</span></span><br><span class="line"><span class="keyword">import</span> db</span><br><span class="line">posts_tags_table = db.Table(<span class="string">'iy_post_tags'</span>, db.Model.metadata,</span><br><span class="line">                            db.Column(<span class="string">'post_id'</span>, db.Integer, db.ForeignKey(<span class="string">'iy_article.post_id'</span>)),</span><br><span class="line">                            db.Column(<span class="string">'tag_id'</span>, db.Integer, db.ForeignKey(<span class="string">'iy_tag.id'</span>)),</span><br><span class="line">                            db.PrimaryKeyConstraint(<span class="string">'tag_id'</span>, <span class="string">'post_id'</span>)</span><br><span class="line">                            )</span><br></pre></td></tr></table></figure></p><p>参见<a href="https://groups.google.com/forum/#!topic/sqlalchemy/vfoTsQkqfHI" target="_blank" rel="noopener">这里</a></p><p>出现这个问题，可能是因为删除主键字段的时候，tags含有对post_id的引用。<br>参见<a href="https://groups.google.com/forum/#!topic/sqlalchemy/vfoTsQkqfHI" target="_blank" rel="noopener">这里</a></p><blockquote><p>A human being should be able to change a diaper, plan an invasion, butcher a hog, conn a ship, design a building, write a sonnet, balance accounts, build a wall, set a bone, comfort the dying, take orders, give orders, cooperate, act alone, solve equations, analyze a new problem, pitch manure, program a computer, cook a tasty meal, fight efficiently, die gallantly. Specialization is for insects.</p><p>一个人应该能够更换尿布，策划战争，杀一头猪，开船掌舵，设计建筑，写十四行诗，会计结算，粉刷砌墙，治疗脱臼，安慰临终的人，执行命令，发布命令，携手合作，独立行动，解数学方程，分析问题，施肥铲粪，电脑编程，做可口的饭菜，高效地战斗，勇敢地死去。只有昆虫才专业化。</p><p>– Robert A. Heinlein</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何在 Linux 上安装 MySQL？</title>
      <link href="/blog/2019-06-23/how-to-install-mysql-on-Linux/"/>
      <url>/blog/2019-06-23/how-to-install-mysql-on-Linux/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>在<code>Linux</code>上面安装<code>MySQL</code>本应该是很容易的一件事，但是有的时候不注意细节还是很容易“翻车”，出现一些预料不到的问题。本文在实践中做一个简单的记录。</p><a id="more"></a><h1 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h1><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 mysql]<span class="comment"># uname -a</span></span><br><span class="line">Linux 172.18.1.117 3.10.0-957.el7.x86_64 <span class="comment">#1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line"><span class="comment"># 发行版本</span></span><br><span class="line">[root@172 mysql]<span class="comment"># cat /etc/redhat-release</span></span><br><span class="line">CentOS Linux release 7.6.1810 (Core)</span><br></pre></td></tr></table></figure><h2 id="MySQL-版本"><a href="#MySQL-版本" class="headerlink" title="MySQL 版本"></a>MySQL 版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装完成之后才可以查询到</span></span><br><span class="line">[root@172 mysql]<span class="comment"># mysql --version</span></span><br><span class="line">mysql  Ver 14.14 Distrib 5.7.26, <span class="keyword">for</span> linux-glibc2.12 (x86_64) using  EditLine wrapper</span><br></pre></td></tr></table></figure><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>点击<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">此链接</a>选择适宜版本下载；<br>如图所示进行选择</p><p><img src="/images/download-mysql.png" alt="选择合适版本下载"></p><p>或者使用<code>wget</code>下载：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.26-linux-glibc2.12-x86_64.tar.gz</span><br></pre></td></tr></table></figure></p><h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><p>我一般习惯在工作目录新建<code>temp</code>文件夹，然后存放这些临时文件。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br><span class="line">/root/temp/</span><br><span class="line">tar -xzvf mysql-5.7.26-linux-glibc2.12-x86_64.tar.gz</span><br><span class="line"><span class="comment"># 省略解压结果</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure></p><h1 id="创建安装目录并切换"><a href="#创建安装目录并切换" class="headerlink" title="创建安装目录并切换"></a>创建安装目录并切换</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/mysql</span><br><span class="line"><span class="comment"># 将解压文件移动到新建目录</span></span><br><span class="line">mv mysql-5.7.26-linux-glibc2.12-x86_64/* /usr/<span class="built_in">local</span>/mysql/</span><br><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</span><br></pre></td></tr></table></figure><h1 id="检查并创建用户和用户组"><a href="#检查并创建用户和用户组" class="headerlink" title="检查并创建用户和用户组"></a>检查并创建用户和用户组</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># cat /etc/group | grep mysql</span></span><br><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># cat /etc/passwd |grep mysql</span></span><br><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># groupadd mysql</span></span><br><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># useradd -r -g mysql mysql</span></span><br></pre></td></tr></table></figure><h2 id="创建数据存储目录并赋权"><a href="#创建数据存储目录并赋权" class="headerlink" title="创建数据存储目录并赋权"></a>创建数据存储目录并赋权</h2><p><strong>注意</strong>：忘记授权会出问题，各种各样的问题。我第一次安装的时候没有新建用户并赋予相应权限，导致安装出现<br><code>Starting MySQL... ERROR! The server quit without updating PID file (/var/lib/mysql/xxx.pid).</code>等各种问题。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir data</span><br><span class="line"><span class="comment"># 用户赋权</span></span><br><span class="line">chown -R mysql mysql/</span><br><span class="line">chgrp -R mysql mysql/</span><br></pre></td></tr></table></figure></p><h1 id="安装并初始化"><a href="#安装并初始化" class="headerlink" title="安装并初始化"></a>安装并初始化</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysqld --initialize --user=mysql --basedir=/usr/<span class="built_in">local</span>/mysql/ --datadir=/usr/<span class="built_in">local</span>/mysql/data/   </span><br><span class="line">--pid-file=/usr/<span class="built_in">local</span>/mysql/data/mysql.pid --lc_messages_dir=/usr/<span class="built_in">local</span>/mysql/share --lc_messages=en_US</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:</p><ol><li><p>第一次安装时没有设置<code>--lc_messages_dir</code>和 <code>--lc_messages</code>出现以下报错，所以建议直接使用完整的命令，如果已经出现下面的报错。可以使用<code>rm -rf /usr/local/mysql/data/*</code>将数据删除之后重新初始化；</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2019-06-23T08:38:15.774307Z 0 [ERROR] Can<span class="string">'t find error-message file '</span>/usr/<span class="built_in">local</span>/mysql/share/errmsg.sys<span class="string">'. Check error-message file location and '</span>lc-messages-dir<span class="string">' configuration directive.</span></span><br></pre></td></tr></table></figure></li><li><p>此步骤如果出现<code>ERROR</code>错误一定要注意解决，不能继续操作，如：</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ERROR] Can<span class="string">'t find error-message file '</span>/usr/<span class="built_in">local</span>/mysql/share/errmsg.sys<span class="string">'. Check error-message file location and '</span>lc-messages-dir<span class="string">' configuration directive.</span></span><br></pre></td></tr></table></figure></li><li><p>记住最后一行生成的随机密码，安装成功后第一次登录需要使用：</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此处密码随机生成，注意记录</span></span><br><span class="line">2019-06-23T08:52:37.416821Z 1 [Note] A temporary password is generated <span class="keyword">for</span> root@localhost: PDRO-ab.a8jd</span><br></pre></td></tr></table></figure></li><li><p>最容易出现这个错误：<code>Starting MySQL. ERROR! The server quit without updating PID file</code>，网上搜到的解决方案没有啥用，我本次安装走到这里没有出现这个错误，但是下面<em>启动服务</em>环节出现该报错，使用<code>rm  /etc/my.cnf -rf</code>居然有用，暂时不知道造成原因。</p><h2 id="使用-mysqld-safe-启动服务"><a href="#使用-mysqld-safe-启动服务" class="headerlink" title="使用 mysqld_safe 启动服务"></a>使用 mysqld_safe 启动服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysqld_safe --user=mysql</span><br><span class="line">2019-06-23T09:00:10.100530Z mysqld_safe error: <span class="built_in">log</span>-error <span class="built_in">set</span> to <span class="string">'/var/log/mariadb/mariadb.log'</span>, however file don<span class="string">'t exists. Create writable for user '</span>mysql<span class="string">'.</span></span><br></pre></td></tr></table></figure></li></ol><p>根据提示修改配置或者新建<code>log</code>日志存放目录<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 mysql]<span class="comment"># mkdir /var/log/mariadb</span></span><br><span class="line">[root@172 mysql]<span class="comment"># touch /var/log/mariadb/mariadb.log</span></span><br></pre></td></tr></table></figure></p><p>再次启动<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 mysql]<span class="comment"># bin/mysqld_safe --user=mysql</span></span><br><span class="line">2019-06-23T09:00:58.541328Z mysqld_safe Logging to <span class="string">'/var/log/mariadb/mariadb.log'</span>.</span><br><span class="line">2019-06-23T09:00:58.546897Z mysqld_safe Directory <span class="string">'/var/lib/mysql'</span> <span class="keyword">for</span> UNIX socket file don<span class="string">'t exists.</span></span><br></pre></td></tr></table></figure></p><h2 id="根据报错信息修改-my-cnf-中的配置项"><a href="#根据报错信息修改-my-cnf-中的配置项" class="headerlink" title="根据报错信息修改 my.cnf 中的配置项"></a>根据报错信息修改 my.cnf 中的配置项</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 mysql]<span class="comment"># vi /etc/my.cnf</span></span><br><span class="line"><span class="comment"># 此处省略，每个人的配置不一样（我已经将该文件删除了，没办法记住怎么配置的了，这里的错误信息很明确，根据错误修改到不报错即可）</span></span><br><span class="line">[root@172 mysql]<span class="comment"># bin/mysqld_safe --user=mysql</span></span><br><span class="line">2019-06-23T09:03:54.795490Z mysqld_safe Logging to <span class="string">'/var/log/mariadb/mariadb.log'</span>.</span><br><span class="line">2019-06-23T09:03:54.845647Z mysqld_safe Starting mysqld daemon with databases from /usr/<span class="built_in">local</span>/mysql/data</span><br><span class="line">2019-06-23T09:03:55.148856Z mysqld_safe mysqld from pid file /var/run/mariadb/mariadb.pid ended</span><br></pre></td></tr></table></figure><h2 id="加入开机自启动项"><a href="#加入开机自启动项" class="headerlink" title="加入开机自启动项"></a>加入开机自启动项</h2><p>将<code>/usr/local/mysql/support-files/mysql.server</code> 拷贝为<code>/etc/init.d/mysql</code>并设置运行权限，这样就可以使用<code>service mysql</code>命令启动/停止服务，<br>否则就只能使用<code>/usr/local/mysql/bin/mysqld_safe</code>命令来启动服务<br>如果自定义了安装路径,还需要把<code>mysql.server</code>中<code>basedir</code>的相关路径，改为自定义的路径，默认路径是<code>/usr/local/mysql</code>。本文使用默认路径，所以不用修改。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@dbserver support-files]<span class="comment"># cp mysql.server /etc/init.d/mysql  </span></span><br><span class="line">[root@dbserver support-files]<span class="comment"># chmod +x /etc/init.d/mysql </span></span><br><span class="line">-- 把mysql注册为开机启动的服务</span><br><span class="line">[root@dbserver support-files]<span class="comment"># chkconfig --add mysql  </span></span><br><span class="line">-- 查看是否添加成功</span><br><span class="line">[root@dbserver support-files]<span class="comment">#  chkconfig --list mysql  </span></span><br><span class="line">Note: This output shows SysV services only and does not include native</span><br><span class="line">      systemd services. SysV configuration data might be overridden by native</span><br><span class="line">      systemd configuration.</span><br><span class="line"></span><br><span class="line">      If you want to list systemd services use <span class="string">'systemctl list-unit-files'</span>.</span><br><span class="line">      To see services enabled on particular target use</span><br><span class="line">      <span class="string">'systemctl list-dependencies [target]'</span>.</span><br><span class="line"></span><br><span class="line">mysql          0:off1:off2:on3:on4:on5:on6:off</span><br></pre></td></tr></table></figure></p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># service mysql start</span></span><br><span class="line">Starting MySQL. ERROR! The server quit without updating PID file (/usr/<span class="built_in">local</span>/mysql/data/172.18.1.117.pid).</span><br></pre></td></tr></table></figure><p>此时删除配置文件，可以解决该报错（原因未知，没有深究）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 mysql]<span class="comment"># rm  /etc/my.cnf -rf</span></span><br></pre></td></tr></table></figure></p><p>重新启动<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 mysql]<span class="comment"># /etc/init.d/mysql start</span></span><br><span class="line">Starting MySQL.Logging to <span class="string">'/usr/local/mysql/data/172.18.1.117.err'</span>.</span><br><span class="line"> SUCCESS!</span><br></pre></td></tr></table></figure></p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 mysql]<span class="comment"># /usr/local/mysql/bin/mysql -uroot -pPDRO-ab.a8jd</span></span><br></pre></td></tr></table></figure><p>修改密码<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有的文章说此处不能使用单引号，但是我使用单引号也成功了，好像没有问题。YOUR PASSWORD 为你自己设置的数据库的密码，这个要记住了，不然就要自己再去手动重置密码了！</span></span><br><span class="line">mysql&gt;  <span class="built_in">set</span> password=password(<span class="string">"YOUR PASSWORD"</span>);</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br><span class="line">mysql&gt; quit</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure></p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>上一步中启动 mysql 的时候使用的是全路径，有的时候会比较麻烦，可以通过配置环境变量修改；<br>执行<code>vi ~/.bash_profile</code>修改文件中<code>PATH</code>一行，将<code>/usr/local/mysql/bin</code> 加入到<code>PATH=$PATH:$HOME/bin</code>一行之后<br><strong>注意</strong>：这种方法只对当前登录用户生效。</p><h1 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h1><p><a href="https://blog.csdn.net/qq_30000313/article/details/85333971" target="_blank" rel="noopener">linux 安装 mysql5.7.24 - 绿色落日的博客 - CSDN 博客</a><br><a href="https://blog.csdn.net/zhou920786312/article/details/77750604" target="_blank" rel="noopener">linux 安装 mysql5.7.19</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用 flask-celery 实现异步任务？</title>
      <link href="/blog/2019-06-18/how-to-use-flask-celery/"/>
      <url>/blog/2019-06-18/how-to-use-flask-celery/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h1><ul><li><p><code>redis</code>版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli --version</span><br><span class="line">redis-cli 5.0.4</span><br></pre></td></tr></table></figure></li><li><p><code>celery</code>版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">celery --version</span><br><span class="line">4.3.0 (rhubarb)</span><br></pre></td></tr></table></figure></li><li><p><code>Flask</code>和 <code>Python</code> 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flask --version</span><br><span class="line">Flask 1.0.2</span><br><span class="line">Python 3.6.5 (default, Apr  1 2018, 05:46:30) </span><br><span class="line">[GCC 7.3.0]</span><br></pre></td></tr></table></figure></li><li><p><code>Linux</code> 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:Ubuntu</span><br><span class="line">Description:Ubuntu 18.04 LTS</span><br><span class="line">Release:18.04</span><br><span class="line">Codename:bionic</span><br><span class="line"><span class="comment"># ---</span></span><br><span class="line">uname -a</span><br><span class="line">Linux <span class="built_in">local</span> 4.15.0-22-generic <span class="comment">#24-Ubuntu SMP Wed May 16 12:15:17 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Celery是什么"><a href="#Celery是什么" class="headerlink" title="Celery是什么"></a><code>Celery</code>是什么</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>Celery</code> 是一个“自带电池”的专注于实时处理和任务调度的分布式任务队列，同时提供操作和维护分布式系统所需的<strong>工具</strong>。</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/images/structure-of-celery.png" alt="celery架构图"></p><center><span>celery架构图</span></center><p><code>Celery</code>支持定时任务（Celery Beat）和异步执行(Async Task)两种模式。同步模式为任务调用方等待任务执行完成，这种方式等同于RPC(Remote Procedure Call)， 异步方式为任务在后台执行，调用方调用后就去做其他工作，之后再根据需要来查看任务结果。<code>Celery</code>自己没有实现消息队列，而是直接已存在的消息队列作为<code>Broker</code>角色。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>使用 <code>Celery</code> 运行后台任务并不像在线程中这样做那么简单，但是好处多多。<code>Celery</code> 具有分布式架构，使应用更加易于扩展。一个 <code>Celery</code> 安装有三个核心组件：</p><ul><li><code>Celery</code> 客户端: 用于发布后台作业。当与 <code>Flask</code> 一起工作的时候，客户端与 <code>Flask</code> 应用一起运行。</li><li>Celery workers: 任务消费者，是运行后台作业的进程。<code>Celery</code> 支持本地和远程的 <code>workers</code>，因此你就可以在 <code>Flask</code> 服务器上启动一个单独的 <code>worker</code>，随后随着你的应用需求的增加而新增更多的 <code>workers</code>。</li><li>消息代理（<code>Broker</code>）: 客户端通过消息队列和 <code>workers</code> 进行通信，<code>Celery</code> 支持多种方式来实现这些队列。常见的为 <code>RabbitMQ</code> 和 <code>Redis</code>。</li><li>任务结果存储：用来存储<code>workers</code>执行的任务结果。<br>详见<a href="http://docs.jinkan.org/docs/celery/getting-started/introduction.html#id19" target="_blank" rel="noopener">Celery 是……</a></li></ul><h2 id="Celery的安装配置"><a href="#Celery的安装配置" class="headerlink" title="Celery的安装配置"></a><code>Celery</code>的安装配置</h2><h3 id="安装-Celery"><a href="#安装-Celery" class="headerlink" title="安装 Celery"></a>安装 <code>Celery</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install celery</span><br></pre></td></tr></table></figure><p>安装时会自动解决依赖：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Installing collected packages: vine, amqp, kombu, billiard, celery</span><br></pre></td></tr></table></figure></p><p>验证<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">celery --version</span><br><span class="line">4.3.0 (rhubarb)</span><br></pre></td></tr></table></figure></p><h3 id="与-redis-结合使用"><a href="#与-redis-结合使用" class="headerlink" title="与 redis 结合使用"></a>与 <code>redis</code> 结合使用</h3><p>redis 安装可以参考之前写的这篇文章<a href="https://imoyao.github.io/blog/2019-04-11/how-to-install-Redis-on-Linux/">Linux 下如何安装 Redis？</a></p><p><strong>注意</strong>： 此处需要同时安装<code>redis</code>客户端和<code>redis</code>的<code>Python</code>支持。</p><h3 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">imoyao@<span class="built_in">local</span>:~$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"_kombu.binding.celery"</span></span><br><span class="line">2) <span class="string">"celery-task-meta-a9db6911-e15a-4b9e-b321-958f5298652a"</span></span><br><span class="line">3) <span class="string">"celery-task-meta-e22b0603-8117-4f0d-ac6b-ad621738e256"</span></span><br><span class="line">4) <span class="string">"unacked_mutex"</span></span><br><span class="line">5) <span class="string">"_kombu.binding.celery.pidbox"</span></span><br><span class="line">6) <span class="string">"celery-task-meta-aac524bd-cb47-4493-b0dd-9712a98a3f14"</span></span><br><span class="line">7) <span class="string">"_kombu.binding.celeryev"</span></span><br><span class="line">8) <span class="string">"celery-task-meta-ccd8d274-7f14-4abc-8244-e80f01932097"</span></span><br><span class="line">9) <span class="string">"celery-task-meta-3b2b3efa-4ad7-4c7e-b92d-27636eaeaa6b"</span></span><br><span class="line">127.0.0.1:6379&gt; get celery-task-meta-a9db6911-e15a-4b9e-b321-958f5298652a</span><br><span class="line"><span class="string">"&#123;\"status\": \"SUCCESS\", \"result\": 30, \"traceback\": null, \"children\": [], \"task_id\": \"a9db6911-e15a-4b9e-b321-958f5298652a\", \"date_done\": \"2019-06-13T18:43:43.491009\"&#125;"</span></span><br></pre></td></tr></table></figure><h2 id="如何在项目中使用Celery"><a href="#如何在项目中使用Celery" class="headerlink" title="如何在项目中使用Celery"></a>如何在项目中使用<code>Celery</code></h2><p>以与<code>Flask</code>结合为例(使用<code>redis</code>作为<code>backend</code>)</p><ul><li>创建<code>celery</code>实例</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app\__init__.py</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_celery</span><span class="params">(app)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    参见：http://docs.jinkan.org/docs/flask/patterns/celery.html</span></span><br><span class="line"><span class="string">    初始化celery</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    celery = Celery(app.import_name, broker=app.config[<span class="string">'CELERY_BROKER_URL'</span>])</span><br><span class="line">    celery.conf.update(app.config)</span><br><span class="line">    TaskBase = celery.Task</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ContextTask</span><span class="params">(TaskBase)</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">with</span> app.app_context():</span><br><span class="line">                <span class="keyword">return</span> TaskBase.__call__(self, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    celery.Task = ContextTask</span><br><span class="line">    <span class="keyword">return</span> celery</span><br></pre></td></tr></table></figure><ul><li>创建后台任务</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> celery.utils.log <span class="keyword">import</span> get_task_logger</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> create_app, init_celery</span><br><span class="line"></span><br><span class="line">lg = get_task_logger(__name__)      <span class="comment"># 记录日志</span></span><br><span class="line">celery = init_celery(create_app(os.getenv(<span class="string">'FLASK_CONFIG'</span>, <span class="string">'default'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># @celery.task(name='pmrearend.task.log_it')        # 此处是解决导入失败的一种方案，但是感觉不够优雅，需要深入了解</span></span><br><span class="line"><span class="meta">@celery.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_it</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">    msg = num1 + num2</span><br><span class="line">    print(msg)</span><br><span class="line">    lg.debug(<span class="string">"in log_test()"</span>)</span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># task = log_it.delay(5,8)</span></span><br><span class="line">    task = log_it.apply_async(args=[<span class="number">10</span>, <span class="number">20</span>], countdown=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><ul><li><p>新建目录及文件</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /var/<span class="built_in">log</span>/celery/</span><br><span class="line">sudo touch /var/<span class="built_in">log</span>/celery/celery.log</span><br></pre></td></tr></table></figure></li><li><p>启动 celery worker 服务</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">celery -A task worker -l debug -f /var/<span class="built_in">log</span>/celery/celery.log</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="遇到的问题记录"><a href="#遇到的问题记录" class="headerlink" title="遇到的问题记录"></a>遇到的问题记录</h3><ol><li><p>sqlalchemy.exc.InvalidRequestError</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlalchemy.exc.InvalidRequestError: Table <span class="string">'user'</span> is already defined <span class="keyword">for</span> this MetaData instance.  </span><br><span class="line">Specify <span class="string">'extend_existing=True'</span> to redefine options and columns on an existing Table object.</span><br></pre></td></tr></table></figure><p> 解决：在对应 model 中添加<code>&#39;extend_existing&#39;: True</code></p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__table_args__ = &#123;<span class="string">'extend_existing'</span>: <span class="literal">True</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>celery: command not found</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo: celery: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p> 解决：按照绝对路径调用<code>celery</code></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> celery</span><br><span class="line">/home/imoyao/envs/py3flk/bin/celery</span><br></pre></td></tr></table></figure><p> 替换此处<code>celery</code>的位置即可运行（TODO：不够优雅，暂时测试性解决方案）</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /home/imoyao/envs/py3flk/bin/celery -A pmrearend.task worker -l debug -f /var/<span class="built_in">log</span>/celery/celery.log</span><br></pre></td></tr></table></figure></li><li><p>没有导入<code>task</code>模块</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2019-06-14 02:32:40,115: ERROR/MainProcess] Received unregistered task of <span class="built_in">type</span> <span class="string">'pmrearend.log_it'</span>.</span><br><span class="line">The message has been ignored and discarded.</span><br><span class="line"></span><br><span class="line">Did you remember to import the module containing this task?</span><br><span class="line">Or maybe you<span class="string">'re using relative imports?</span></span><br></pre></td></tr></table></figure><p> 解决：每个任务必须有不同的名称。如果没有显示提供名称，任务装饰器将会自动产生一个，产生的名称会基于这些信息： 1）任务定义所在的模块， 2）任务函数的名称</p><p> 显示设置任务名称的例子：在装饰器<code>@app.task</code>中加入参数<code>name</code>，就可以被<code>celery</code>读取到。  </p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@celery.task(name='pmrearend.task.log_it')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_it</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">    msg = num1 + num2</span><br><span class="line">    print(msg)</span><br><span class="line">    lg.debug(<span class="string">"in log_test()"</span>)</span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line">```   </span><br><span class="line">正常运行结果</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">43</span>,<span class="number">139</span>: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at <span class="number">0x7f72a03fef28</span>&gt; (args:(<span class="string">'pmrearend.task.log_it'</span>, <span class="string">'a9db6911-e15a-4b9e-b321-958f5298652a'</span>, &#123;<span class="string">'lang'</span>: <span class="string">'py'</span>, <span class="string">'task'</span>: <span class="string">'pmrearend.task.log_it'</span>, <span class="string">'id'</span>: <span class="string">'a9db6911-e15a-4b9e-b321-958f5298652a'</span>, <span class="string">'shadow'</span>: <span class="literal">None</span>, <span class="string">'eta'</span>: <span class="string">'2019-06-13T18:43:43.139123+00:00'</span>, <span class="string">'expires'</span>: <span class="literal">None</span>, <span class="string">'group'</span>: <span class="literal">None</span>, <span class="string">'retries'</span>: <span class="number">0</span>, <span class="string">'timelimit'</span>: [<span class="literal">None</span>, <span class="literal">None</span>], <span class="string">'root_id'</span>: <span class="string">'a9db6911-e15a-4b9e-b321-958f5298652a'</span>, <span class="string">'parent_id'</span>: <span class="literal">None</span>, <span class="string">'argsrepr'</span>: <span class="string">'[10, 20]'</span>, <span class="string">'kwargsrepr'</span>: <span class="string">'&#123;&#125;'</span>, <span class="string">'origin'</span>: <span class="string">'gen4669@local'</span>, <span class="string">'reply_to'</span>: <span class="string">'a2563c50-9249-3718-85a8-9ad44174831c'</span>, <span class="string">'correlation_id'</span>: <span class="string">'a9db6911-e15a-4b9e-b321-958f5298652a'</span>, <span class="string">'delivery_info'</span>: &#123;<span class="string">'exchange'</span>: <span class="string">''</span>, <span class="string">'routing_key'</span>: <span class="string">'celery'</span>, <span class="string">'priority'</span>: <span class="number">0</span>, <span class="string">'redelivered'</span>: <span class="literal">None</span>&#125;&#125;, <span class="string">b'[[10, 20], &#123;&#125;, &#123;"callbacks": null, "errbacks": null, "chain": null, "chord": null&#125;]'</span>, <span class="string">'application/json'</span>, <span class="string">'utf-8'</span>) kwargs:&#123;&#125;)</span><br><span class="line">[2019-06-14 02:43:43,281: DEBUG/MainProcess] basic.qos: prefetch_count-&gt;4</span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">43</span>,<span class="number">284</span>: WARNING/ForkPoolWorker<span class="number">-1</span>] <span class="number">30</span></span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">43</span>,<span class="number">286</span>: DEBUG/MainProcess] Task accepted: pmrearend.task.log_it[a9db6911-e15a<span class="number">-4</span>b9e-b321<span class="number">-958</span>f5298652a] pid:<span class="number">4089</span></span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">43</span>,<span class="number">287</span>: DEBUG/ForkPoolWorker<span class="number">-1</span>] pmrearend.task.log_it[a9db6911-e15a<span class="number">-4</span>b9e-b321<span class="number">-958</span>f5298652a]: <span class="keyword">in</span> log_test()</span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">43</span>,<span class="number">504</span>: INFO/ForkPoolWorker<span class="number">-1</span>] Task pmrearend.task.log_it[a9db6911-e15a<span class="number">-4</span>b9e-b321<span class="number">-958</span>f5298652a] succeeded <span class="keyword">in</span> <span class="number">0.22014467700500973</span>s: <span class="number">30</span></span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">44</span>,<span class="number">751</span>: INFO/MainProcess] Received task: pmrearend.task.log_it[aac524bd-cb47<span class="number">-4493</span>-b0dd<span class="number">-9712</span>a98a3f14]  ETA:[<span class="number">2019</span><span class="number">-06</span><span class="number">-13</span> <span class="number">18</span>:<span class="number">43</span>:<span class="number">54.619709</span>+<span class="number">00</span>:<span class="number">00</span>] </span><br><span class="line">[2019-06-14 02:43:44,752: DEBUG/MainProcess] basic.qos: prefetch_count-&gt;5</span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">54</span>,<span class="number">621</span>: DEBUG/MainProcess] TaskPool: Apply &lt;function _fast_trace_task at <span class="number">0x7f72a03fef28</span>&gt; (args:(<span class="string">'pmrearend.task.log_it'</span>, <span class="string">'aac524bd-cb47-4493-b0dd-9712a98a3f14'</span>, &#123;<span class="string">'lang'</span>: <span class="string">'py'</span>, <span class="string">'task'</span>: <span class="string">'pmrearend.task.log_it'</span>, <span class="string">'id'</span>: <span class="string">'aac524bd-cb47-4493-b0dd-9712a98a3f14'</span>, <span class="string">'shadow'</span>: <span class="literal">None</span>, <span class="string">'eta'</span>: <span class="string">'2019-06-13T18:43:54.619709+00:00'</span>, <span class="string">'expires'</span>: <span class="literal">None</span>, <span class="string">'group'</span>: <span class="literal">None</span>, <span class="string">'retries'</span>: <span class="number">0</span>, <span class="string">'timelimit'</span>: [<span class="literal">None</span>, <span class="literal">None</span>], <span class="string">'root_id'</span>: <span class="string">'aac524bd-cb47-4493-b0dd-9712a98a3f14'</span>, <span class="string">'parent_id'</span>: <span class="literal">None</span>, <span class="string">'argsrepr'</span>: <span class="string">'[10, 20]'</span>, <span class="string">'kwargsrepr'</span>: <span class="string">'&#123;&#125;'</span>, <span class="string">'origin'</span>: <span class="string">'gen4706@local'</span>, <span class="string">'reply_to'</span>: <span class="string">'ee66dc1c-aebd-3111-9ef4-f07a71943fc0'</span>, <span class="string">'correlation_id'</span>: <span class="string">'aac524bd-cb47-4493-b0dd-9712a98a3f14'</span>, <span class="string">'delivery_info'</span>: &#123;<span class="string">'exchange'</span>: <span class="string">''</span>, <span class="string">'routing_key'</span>: <span class="string">'celery'</span>, <span class="string">'priority'</span>: <span class="number">0</span>, <span class="string">'redelivered'</span>: <span class="literal">None</span>&#125;&#125;, <span class="string">b'[[10, 20], &#123;&#125;, &#123;"callbacks": null, "errbacks": null, "chain": null, "chord": null&#125;]'</span>, <span class="string">'application/json'</span>, <span class="string">'utf-8'</span>) kwargs:&#123;&#125;)</span><br><span class="line">[2019-06-14 02:43:54,631: DEBUG/MainProcess] basic.qos: prefetch_count-&gt;4</span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">54</span>,<span class="number">637</span>: WARNING/ForkPoolWorker<span class="number">-1</span>] <span class="number">30</span></span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">54</span>,<span class="number">639</span>: DEBUG/ForkPoolWorker<span class="number">-1</span>] pmrearend.task.log_it[aac524bd-cb47<span class="number">-4493</span>-b0dd<span class="number">-9712</span>a98a3f14]: <span class="keyword">in</span> log_test()</span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">54</span>,<span class="number">645</span>: DEBUG/MainProcess] Task accepted: pmrearend.task.log_it[aac524bd-cb47<span class="number">-4493</span>-b0dd<span class="number">-9712</span>a98a3f14] pid:<span class="number">4089</span></span><br><span class="line">[<span class="number">2019</span><span class="number">-06</span><span class="number">-14</span> <span class="number">02</span>:<span class="number">43</span>:<span class="number">54</span>,<span class="number">650</span>: INFO/ForkPoolWorker<span class="number">-1</span>] Task pmrearend.task.log_it[aac524bd-cb47<span class="number">-4493</span>-b0dd<span class="number">-9712</span>a98a3f14] succeeded <span class="keyword">in</span> <span class="number">0.012691148993326351</span>s: <span class="number">30</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="问题记录："><a href="#问题记录：" class="headerlink" title="问题记录："></a>问题记录：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">celery.platforms.LockFailed: [Errno 13] Permission denied: <span class="string">'/home/xxx/celerybeat.pid'</span></span><br><span class="line">```    </span><br><span class="line">pid文件没有权限；这种情况有两种解决办法：</span><br><span class="line">- 修改pid文件存储路径，放到当前执行用户有权限的位置</span><br><span class="line">```bash</span><br><span class="line">celery beat -A celeryapp --loglevel=INFO --pidfile=<span class="string">"/tmp/celerybeat.pid"</span>        <span class="comment"># 修改路径</span></span><br></pre></td></tr></table></figure><ul><li>对pid文件所在目录加权限，然后执行：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown -R YOUR_USER_NAME:YOUR_USER_NAME  CURRENT_PATH</span><br><span class="line">celery -A celery_worker:celery beat --loglevel=INFO</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://github.com/celery/celery/issues/3828" target="_blank" rel="noopener">参见这里</a></p><h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><p><strong>不要</strong>将task写进类中，因为可能导致执行出错等各种问题，如果真的要这么做，可以参考这里：<br>参见 <a href="https://stackoverflow.com/questions/9250317/using-class-methods-as-celery-tasks" target="_blank" rel="noopener">using class methods as celery tasks</a></p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>因为个人时间关系，这个暂时没有学完。关于<code>Celery</code>的使用需要进一步实践学习。</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="http://docs.celeryproject.org/en/latest/" target="_blank" rel="noopener">Celery 4.3.0 documentation »</a><br><a href="https://www.jianshu.com/p/807efde55d81" target="_blank" rel="noopener">在 Flask 中使用 Celery 的最佳实践</a><br><a href="https://blog.csdn.net/libing_thinking/article/details/78547816" target="_blank" rel="noopener">Celery中文文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> HOWTO </tag>
            
            <tag> Celery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解 cookie、session 与 token</title>
      <link href="/blog/2019-06-18/diff-cookie-session-token/"/>
      <url>/blog/2019-06-18/diff-cookie-session-token/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="https://segmentfault.com/a/1190000017831088" target="_blank" rel="noopener">彻底弄懂 session，cookie，token</a><br><a href="https://segmentfault.com/a/1190000015881055" target="_blank" rel="noopener">token 与 sessionId 的区别——学习笔记</a><br><a href="https://www.liangzl.com/get-article-detail-16019.html" target="_blank" rel="noopener">彻底理解 cookie，session，token</a><br><a href="https://www.zhihu.com/question/23202402" target="_blank" rel="noopener">HTTP 是一个无状态的协议。这句话里的无状态是什么意思？</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 之 Web 开发框架对比——Flask vs webpy</title>
      <link href="/blog/2019-06-05/Flask-vs-webpy/"/>
      <url>/blog/2019-06-05/Flask-vs-webpy/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><code>Python</code> 常用的<code>web</code>开发框架有很多如<code>Django</code>、<code>Flask</code>、<code>Tornado</code>、<code>Web.py</code>等，我们之前项目中使用的是 <code>web.py</code>,但是新项目中选择哪个？或许是个值得思考的问题。本文主要对<code>web.py</code>和<code>Flask</code>进行一个简单的对比。</p><a id="more"></a><h2 id="为什么要从web-py迁移到Flask"><a href="#为什么要从web-py迁移到Flask" class="headerlink" title="为什么要从web.py迁移到Flask"></a>为什么要从<code>web.py</code>迁移到<code>Flask</code></h2><p>大势所趋。根据最新的<a href="https://www.jetbrains.com/research/python-developers-survey-2018/" target="_blank" rel="noopener">Python 开发者调研-2018</a>结果显示，<code>Flask</code>和<code>Django</code>已经成为最流行的<code>web</code>开发框架。对企业的良性发展和开发者个人成长而言，使用热门技术都是值得鼓励且必要的。而且，众所周知，官方计划在<code>2020</code>年停止<code>Python2</code>支持，而相比<code>Flask</code>而言,<code>web.py</code><br>的版本更新计划有点跟不上节奏的感觉。</p><p><img src="/images/Web-frameworks-python-developers-survey-2018.jpg" alt="Web-frameworks-python-developers-survey-2018"></p><center><span>Web-frameworks-python-developers-survey-2018</span></center><h2 id="TL-DR，Flask-对比-web-py-的不同点"><a href="#TL-DR，Flask-对比-web-py-的不同点" class="headerlink" title="TL;DR，Flask 对比 web.py 的不同点"></a>TL;DR，<code>Flask</code> 对比 <code>web.py</code> 的不同点</h2><p><code>Flask</code>拥有活跃的社区文化和丰富而强大的第三方扩展，而<code>web.py</code>在原作者（Aaron Swartz）自杀之后自身维护已举步维艰，第三方扩展的发展更是不言而喻。</p><ul><li><p><strong>维护积极性</strong>  - 最新版本分别为<code>Flask-1.0.2</code>和 <code>webpy-0.39</code>。</p>  <figure class="half"><br>      <img src="/images/flask-contributors.jpg" alt="flask-contributors"><br>      <center><span>flask-contributors</span></center><br>      <img src="/images/webpy-contributors.jpg" alt="webpy-contributors"><br>      <center><span>webpy-contributors</span></center><br>  </figure></li><li><p><strong>官方文档</strong> - <code>Flask</code>具有良好的官方文档，并且有国内使用者翻译的中文文档；<code>web.py</code>只有勉强够用、捉襟见肘的入门级官方文档，剩下的需要开发人员自行摸索。</p></li><li><strong>社区活跃度</strong> - <code>Flask</code>拥有活跃的社区文化和数量庞大的拥趸者，<code>web.py</code>国内只有不活跃的专门的豆瓣小组或者在一些热门<code>Python</code>社区偶有提及。</li><li>第三方扩展  <ul><li>表单 - <code>Flask</code> 使用扩展<code>Flask-WTF</code>和<code>WTForms</code>可以实现很好的表单验证和 <code>csrf</code> 安全保护；（参阅<a href="https://www.jianshu.com/p/7e16877757f8" target="_blank" rel="noopener">Flask-WTF 与 WTForms 的用法详解</a>）；而<code>web.py</code>自带<a href="http://webpy.org/form" target="_blank" rel="noopener">Form 库</a>，可以实现表单及简单校验。</li><li>数据库 -  <code>Flask</code> 使用扩展<code>Flask-SQLAlchemy</code>实现对数据库的<code>ORM</code>操作,可以很好地管理和实现数据库的迁移(借助<code>Flask-Migrate</code>)工作；<code>web.py</code>我们使用自己封装的<code>database.py</code>。</li><li>身份验证和权限 - <code>Flask</code>提供安全<code>cookie</code>作为您自己实现的工具，第三方扩展如<code>Flask-Login</code>(用户会话管理)，<code>Flask-HTTPAuth</code><sup>①</sup>（简化了使用<code>Flask</code>路由的<code>HTTP</code>身份验证的使用），<code>Flask-Security</code>（提供一站式管理）， <code>Flask-Social</code>（用于添加“社交”或<code>OAuth</code>登录和连接管理）等，这些扩展良莠不齐，使用时需要对其有个初步了解并进行遴选；<code>web.py</code>还是要自己造轮子。</li><li><code>RESTful</code> - 使用<code>Flask-RESTful</code> 可以创建<code>REST</code>的<code>API</code>。</li><li>强大的页面渲染 -<code>Flask</code>使用<code>jinja2</code>作为模板引擎；<code>web.py</code>使用<code>Templetor</code>,类 <code>python</code>,写起来信手拈来，无痛衔接，也可以使用<code>Mako</code>模板引擎，两者平分秋色。性能对比见这里 &gt;&gt; <a href="http://www.pythontip.com/blog/post/2239/" target="_blank" rel="noopener">几个模板系统的性能对比</a></li></ul></li><li>伸缩性 - <code>Flask</code>既可以像<code>web.py</code>那样做微框架开发一个很小的<code>web</code>应用，也可以借助上方的各种扩展做到<code>Django</code>级别的应用。</li></ul><h2 id="Flask-框架"><a href="#Flask-框架" class="headerlink" title="Flask 框架"></a>Flask 框架</h2><blockquote><p>Flask is a microframework for Python based on Werkzeug, Jinja 2 and good intentions.<br>Flask 是一个基于 <code>Jinja2</code> 模板引擎和 <code>Werkzeug WSGI</code> 套件的一个微型的<code>Web</code>开发框架。体现了<code>logo</code>中的口号<code>web development, one drop at a time.</code>(<code>web</code>开发,一次一滴。)</p></blockquote><h3 id="什么是-“微”"><a href="#什么是-“微”" class="headerlink" title="什么是 “微”"></a>什么是 “微”</h3><blockquote><p>“微” (“Micro”) 并不是意味着把整个 <code>Web</code> 应用放入到一个 <code>Python</code> 文件，尽管确实可以这么做。当然“微” (“Micro”) 也不是意味 <code>Flask</code> 的功能上是不足的。微框架中的 “微” (“Micro”) 是指 <code>Flask</code> 旨在保持代码简洁且易于扩展。<code>Flask</code> 不会替你做出太多决策——比如使用何种数据库。而那些 <code>Flask</code> 所选择的——比如使用何种模板引擎——则很容易替换。除此之外的一切都可由你掌握。如此，<code>Flask</code> 可以与您珠联璧合。<br>默认情况下，<code>Flask</code> 并不包含数据库抽象层，表单验证或者任何其他现有的库( <code>Django</code> )能够处理的。相反，<code>Flask</code> 支持扩展，这些扩展能够添加功能到你的应用，像是 <code>Flask</code> 本身实现的一样。众多的扩展提供了数据库集成，表单验证，上传处理，多种开放的认证技术等功能。<code>Flask</code> 可能是“微”型的，但它可以游刃有余地应付需求繁杂的生产环境的使用。</p></blockquote><p>① 在 <code>Web</code> 应用中，我们经常需要保护我们的 <code>api</code>，以避免非法访问。比如，只允许登录成功的用户发表评论等。<code>Flask-HTTPAuth</code> 扩展可以很好地对 <code>HTTP</code> 的请求进行认证，不依赖于 <code>Cookie</code> 和 <code>Session</code>。而是基于密码和基于令牌 (<code>token</code>)。</p><h2 id="web-py-框架"><a href="#web-py-框架" class="headerlink" title="web.py 框架"></a><code>web.py</code> 框架</h2><blockquote><p>web.py is a web framework for Python that is as simple as it is powerful.<br>web.py 是一个简单且功能强大的用于 Python 语言的 web 框架。</p></blockquote><h3 id="web-py设计哲学"><a href="#web-py设计哲学" class="headerlink" title="web.py设计哲学"></a><code>web.py</code>设计哲学</h3><p><code>web.py</code>的口号是<code>Think about the ideal way to write a web app. Write the code to make it happen.</code>（思考编写<code>web</code>应用程序的理想方式，然后去编写代码实现它。）<br>在用<code>Python</code>编写<code>web</code>应用程序的时候，我想象自己想要<code>API</code>的方式。它始于导入<code>web</code>，然后有一个定义<code>URL</code>的地方，处理<code>GET</code>和<code>POST</code>的简单函数和一些处理输入变量的东西。一旦代码对我来说看起来是正确的, 我就会想尽办法使它在不更改应用程序代码的情况下执行——结果就是 <code>web.py</code>。<br>有人抱怨说我“搞了另一套模板语言”（yet another template language），我写了更多文字关于我的设计理念：<a href="http://groups.google.com/group/webpy/msg/f266701d97e7ceb1" target="_blank" rel="noopener">参阅</a></p><p>你不必使用它——<code>web.py</code>的每个部分都与其他部分完全分离。但你是对的, 它是“另一种模板语言”，而我不会为此道歉。<br><code>Web.py</code> 的目标是构建制作 <code>web</code> 应用程序的理想方法。如果为了实现这个目标需要有微小差异化的来重塑陈旧的东西, 我会捍卫自己对它们进行改造的权利。<code>理想的方式</code>和<code>几乎理想的方式</code>之间的区别, 正如马克·吐温所言：是闪电和萤火虫之间的区别。（The difference between the right word and the almost right word is the difference between lightning and the lightning Bug.）<br>但这些不仅仅是细微的差异。<code>Web.py</code> 允许您构建 <code>http</code> 响应, 而不暴露 <code>Python</code> 对象。<code>web.py</code> 使数据库更易使用,而不试图使数据库看起来像一个对象。 <code>web.py</code> 模板系统试图把 <code>Python</code> 纳入 <code>HTML</code>而不是想出另一种方法来编写 <code>HTML</code>。没多少人真正尝试过这么做的可能性。<br>你可以不同意这些方法更好并给出原因，但仅仅批评它们与众不同是浪费时间。是的, 它们天生骄傲。我的话讲完了。<br>文字来源：<a href="http://webpy.org/philosophy" target="_blank" rel="noopener">The web.py Philosophy</a></p><h2 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h2><h3 id="web-py"><a href="#web-py" class="headerlink" title="web.py"></a>web.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line">urls = (</span><br><span class="line">    <span class="string">'/'</span>, <span class="string">'Index'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, world!"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># def POST(self):</span></span><br><span class="line">    <span class="comment">#     pass    # TODO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    web.config.debug = <span class="literal">False</span></span><br><span class="line">    app = web.application(urls, globals())</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><ol><li>导入<code>web</code>模块；</li><li>组装<code>url</code>结构；<ul><li>第一部分为匹配<code>URL</code>的正则表达式，第二部分是接受请求的类名称</li></ul></li><li>定义类<ul><li>定义处理<code>GET</code>请求的方法；</li><li>定义（可选的）处理<code>POST</code>请求的方法；</li></ul></li><li><code>debug</code>模式<br> 当应用在内建的服务器中运行时，它会以<code>debug</code>模式启动程序。在<code>debug</code>模式下，任何代码、模板的修改，都会让服务器重新加载它们，然后还会输出有用的错误消息。<br> 只有在生产环境中<code>debug</code>模式是关闭的，如果你想禁用<code>debug</code>模式，你可以在创建程序/模板前添加置为<code>False</code>。</li><li>创建应用，这个<code>application</code>会在这个文件的全局命名空间中查找<code>urls</code>中定义的对应类。</li><li>启动应用。</li></ol><h3 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/',methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    打开调试模式的另一种设置方式</span></span><br><span class="line"><span class="string">    app.debug = True</span></span><br><span class="line"><span class="string">    app.run()</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>运行之后，浏览<code>http://0.0.0.1:5000/</code>即可访问。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python app.py</span><br><span class="line"> * Running on http://0.0.0.1:5000/</span><br></pre></td></tr></table></figure></p><p>代码解释</p><ol><li>导入<code>Flask</code>类；</li><li>实例化，即生成我们的 <code>WSGI</code> 应用，第一个参数是应用模块的名称。 如果你使用的是单一的模块（就如本例），第一个参数应该使用 <code>__name__</code>。我们还可以传递给它模块或包的名称。这样 <code>Flask</code> 才会知道去哪里寻找模板、静态文件等等。</li><li>使用装饰器 <code>route()</code> 告诉 <code>Flask</code> 哪个 <code>URL</code> 才能触发我们的函数。<ul><li>默认情况下，路由只会响应 <code>GET</code> 请求， 但是能够通过给 <code>route()</code> 装饰器提供 <code>methods</code> 参数改变。</li></ul></li><li>定义函数，该函数名也是用来给特定函数生成 <code>URLs</code>，并且返回我们想要显示在用户浏览器上的信息。</li><li>最后我们用函数 <code>run()</code> 启动本地服务器来运行我们的应用。<ul><li><code>host=&#39;0.0.0.0&#39;</code>你可以让你的服务器对外可见。</li><li><code>debug=True</code>开启调式模式,仅适用于开发阶段，在代码修改的时候服务器能够自动加载，发生错误之后可以更好追踪调试； <strong>生产模式时，一定要关闭该选项。</strong></li></ul></li></ol><p><strong>注意</strong><br>可能有人想要使用<code>Flask</code>实现<code>web.py</code>类似的<code>RESTful</code>的代码设计风格，借助<code>Flask-RESTful</code>可以实现像<code>web.py</code>一样的<code>RESTful</code>设计。示例如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_restful <span class="keyword">import</span> Resource, Api</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">api = Api(app)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span><span class="params">(Resource)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'hello'</span>: <span class="string">'world'</span>&#125;</span><br><span class="line"></span><br><span class="line">api.add_resource(HelloWorld, <span class="string">'/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><h2 id="关于-Flask-的蓝本-蓝图（Blueprint）"><a href="#关于-Flask-的蓝本-蓝图（Blueprint）" class="headerlink" title="关于 Flask 的蓝本/蓝图（Blueprint）"></a>关于 Flask 的蓝本/蓝图（Blueprint）</h2><p>在<code>Flask</code>中可以用<code>Blueprint</code> (蓝图) 实现应用的<strong>模块化</strong>，应用层次清晰，蓝图可以极大地<strong>简化大型应用</strong>并为扩展提供集中的注册入口。<br>蓝图通常作用于相同的<code>URL</code>前缀，如<code>/user/:id</code>、<code>/user/profile</code>这样的地址，都以<code>/user</code>开头，它们是一组用户相关的操作，那么就可以放在一个模块中。<br>在大型项目中，一般都是协同开发各共同进行的，使用蓝图可以避免互相干扰，开发人员一看路由就能很快的找到对应的视图，可以更容易地<strong>开发和维护</strong>项目。</p><p>一个典型的使用蓝图组织应用的项目结构：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">app/</span><br><span class="line">    __init__.py</span><br><span class="line">    admin/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    home/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    control_panel/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    models.py</span><br><span class="line">    runserver.py</span><br></pre></td></tr></table></figure></p><p>参阅<a href="https://www.zhihu.com/question/31748237" target="_blank" rel="noopener">如何理解 Flask 中的蓝本？</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>需求驱动，没有最好的框架，只有适合你的框架。<br>两者都是轻量级<code>web</code>开发框架（相较于<code>Django</code>而言），都具有良好的扩展性并遵循<code>Pythonic</code>设计，非常适合初学者学习与使用。<br><code>web.py</code>坚持小而美的设计理念。简单直接，学习成本更低，对于新手理解 web 处理流程很有帮助，更适合敏捷开发和定制化，当然也就意味着可能需要自己造更多的轮子。<br>而<code>Flask</code>拥有庞杂的第三方扩展可以参考使用，具备良好的扩展性，遇到问题更好向社区寻求答案。当然，随着开发的深入，可能伴随一系列扩展的了解和学习，会消耗较多时间。但是相比<code>Django</code>这种<code>完美主义者用来赶期限的选择</code>，你不必一开始就学所有的东西（session、ORM、CSRF、Form、Template、Middleware 等），可以自主搭配，渐进开发。<br>所以，对于全新项目，为了后续的可持续迭代和维护，相比<code>web.py</code>更建议选择<code>Flask</code>。</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><h3 id="框架对比"><a href="#框架对比" class="headerlink" title="框架对比"></a>框架对比</h3><ul><li><a href="https://kite.com/blog/python/flask-vs-django-python" target="_blank" rel="noopener">Flask vs Django</a></li><li><a href="https://www.douban.com/group/topic/29598761/" target="_blank" rel="noopener">web.py,web2py,django 三者间到底是什么关系？有什么不同呢？- 豆瓣</a></li><li><a href="https://www.zhihu.com/question/20708601" target="_blank" rel="noopener">Flask 框架怎么样，比起 Web.py 有哪些不同？- 知乎</a></li><li><a href="https://stackoverflow.com/questions/5695689/web-py-and-flask" target="_blank" rel="noopener">web.py-and-flask- StackOverflow</a></li><li><a href="https://www.quora.com/Which-is-better-Flask-vs-web-py-Why" target="_blank" rel="noopener">Which is better: Flask vs web.py? Why?-Quora</a></li><li><a href="https://www.reddit.com/r/Python/comments/28qr7c/can_anyone_explain_the_differences_between_web2py/" target="_blank" rel="noopener">Can anyone explain the differences between web2py, Django, Flask, etc, and when I should use one or the other and what the benefits and drawbacks of each?-Reddit</a></li></ul><h3 id="Flask学习资源"><a href="#Flask学习资源" class="headerlink" title="Flask学习资源"></a><code>Flask</code>学习资源</h3><ul><li><a href="http://flask.pocoo.org/" target="_blank" rel="noopener">Welcome | Flask (A Python Microframework)</a></li><li><a href="http://docs.jinkan.org/docs/flask/index.html" target="_blank" rel="noopener">Flask 中文文档</a></li><li><a href="https://www.ctolib.com/docs/sfile/head-first-flask/" target="_blank" rel="noopener">Flask Web 开发入门</a></li><li><a href="http://www.pythondoc.com/flask-mega-tutorial/index.html" target="_blank" rel="noopener">欢迎进入 Flask 大型项目教程</a></li><li><a href="https://book.douban.com/subject/26274202/" target="_blank" rel="noopener">Flask Web 开发：基于 Python 的 Web 应用开发实战 -（狗书）</a></li><li><a href="https://book.douban.com/subject/30310340/" target="_blank" rel="noopener">Flask Web 开发实战 -（狼书）</a></li></ul><h3 id="Flask扩展"><a href="#Flask扩展" class="headerlink" title="Flask扩展"></a><code>Flask</code>扩展</h3><ul><li><a href="https://github.com/humiaozuzu/awesome-flask" target="_blank" rel="noopener">Awesome Flask(Flask 资源和插件的精选列表)</a></li><li><a href="http://www.pythondoc.com/" target="_blank" rel="noopener">Flask 文档和主流第三方扩展文档</a></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://www.zhihu.com/question/20711220" target="_blank" rel="noopener">亚伦·斯沃茨 (Aaron Swartz) 是怎么样一个人？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> Web 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 中存储 IP 地址应该选用何种数据类型？</title>
      <link href="/blog/2019-05-11/which-mysql-datatype-use-for-store-an-ip-address/"/>
      <url>/blog/2019-05-11/which-mysql-datatype-use-for-store-an-ip-address/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天在项目开发时，遇到需要在数据库中存储 ip 地址，那么应该选用何种数据类型更加高效呢？<br>如果存储的是<code>IPV4</code>地址，可以选择使用<code>INT UNSIGNED</code>，然后借助 <code>MySQL</code> 自带的 <code>INET_ATON()</code> 和  <code>INET_NTOA()</code>来存取数据；<br>如果存储的是<code>IPV6</code>地址，可以选择使用<code>VARBINARY()</code>，然后借助 <code>INET6_ATON()</code>和<code>INET6_NTOA()</code> (<code>MySQL5.6+</code>支持)方法存取数据。</p><a id="more"></a><h2 id="针对IPv4地址"><a href="#针对IPv4地址" class="headerlink" title="针对IPv4地址"></a>针对<code>IPv4</code>地址</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select inet_aton('127.0.0.1');</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| inet_aton('127.0.0.1') |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">|             2130706433 |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">inet_ntoa</span>(<span class="number">2130706433</span>);</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| inet_ntoa(2130706433) |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| 127.0.0.1             |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h3><ul><li><p>存数据</p>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`ip_addresses`</span> (<span class="string">`ip_address`</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="keyword">INET_ATON</span>(<span class="string">'127.0.0.1'</span>));</span><br></pre></td></tr></table></figure></li><li><p>取数据</p>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">INET_NTOA</span>(<span class="string">`ip_address`</span>) <span class="keyword">AS</span> ip</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`ip_addresses`</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a><code>Python</code>实现</h3><p>对于上面的代码，如果我们不想使用内置的<code>MySQL</code>方法，也可以在应用层使用自己封装的方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket, struct</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ip2long</span><span class="params">(ip)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> struct.unpack(<span class="string">"!L"</span>,socket.inet_aton(ip))[<span class="number">0</span>]  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long2ip</span><span class="params">(longip)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> socket.inet_ntoa(struct.pack(<span class="string">'!L'</span>, longip))  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    print(<span class="string">'local ip address to long is %s'</span>%ip2long(<span class="string">'127.0.0.1'</span>))  </span><br><span class="line">    print(<span class="string">'local ip address to long is %s'</span>%ip2long(<span class="string">'255.255.255.255'</span>))  </span><br><span class="line">    print(<span class="string">'local ip address long to ip is %s'</span>%long2ip(<span class="number">2130706433</span>))  </span><br><span class="line">    print(<span class="string">'local ip address long to ip is %s'</span>%long2ip(<span class="number">4294967295</span>))</span><br></pre></td></tr></table></figure><h2 id="针对IPv6地址"><a href="#针对IPv6地址" class="headerlink" title="针对IPv6地址"></a>针对<code>IPv6</code>地址</h2><p>MySQL 提供内置函数<code>inet6_aton()</code>来存储和检索<code>IPv6</code>地址。敲黑板，不要把<code>IPv6</code>地址存储为整数，因为数字格式的<code>IPv6</code>地址需要比<code>UNSIGNED BIGINT</code>更多的字节。所以下面的函数返回<code>VARBINARY(16)</code>数据类型。让我们看一个例子。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select hex(inet6_aton('127.0.0.1'));</span><br><span class="line">+<span class="comment">---------------------------------+</span></span><br><span class="line">| hex(inet6_aton('127.0.0.1'))    |</span><br><span class="line">+<span class="comment">---------------------------------+</span></span><br><span class="line">| 7F000001                        |</span><br><span class="line">+<span class="comment">---------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">hex</span>(<span class="keyword">inet6_aton</span>(<span class="string">'2001:0db8:85a3:0000:0000:8a2e:0370:7334'</span>));</span><br><span class="line">+<span class="comment">---------------------------------------------------------------------------+</span></span><br><span class="line">| hex(inet6_aton('2001:0db8:85a3:0000:0000:8a2e:0370:7334'))                |</span><br><span class="line">+<span class="comment">---------------------------------------------------------------------------+</span></span><br><span class="line">| 20010DB885A3000000008A2E03707334                                          |</span><br><span class="line">+<span class="comment">---------------------------------------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">inet6_ntoa</span>(<span class="keyword">unhex</span>(<span class="string">'20010DB885A3000000008A2E03707334'</span>));</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------+</span></span><br><span class="line">| inet6_ntoa(unhex('20010DB885A3000000008A2E03707334'))                      |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------+</span></span><br><span class="line">| 2001:db8:85a3::8a2e:370:7334                                               |</span><br><span class="line">+<span class="comment">----------------------------------------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong></p><p>假设你正在编写查找以<code>ip</code>地址为<code>127.0.0.1</code>连接的用户，可能写出如下的查询语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">inet_ntoa</span>(ipaddress)=<span class="string">'127.0.0.1'</span>;</span><br></pre></td></tr></table></figure><p>请注意，此查询不会使用在<code>ipaddress</code>列上创建的索引，因为我们在<code>SQL</code>执行期间修改了索引列，它也会逐行将整数转换为真实的<code>IP</code>地址。所以要想让索引生效应该：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @ip = <span class="keyword">inet_aton</span>(<span class="string">'127.0.0.1'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> ipaddress = @ip;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> ipaddress = <span class="keyword">inet_aton</span>(<span class="string">'127.0.0.1'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.rathishkumar.in/2017/08/how-to-store-ip-address-in-mysql.html" target="_blank" rel="noopener">How to store IP (internet protocol) address in MySQL?</a></li><li><a href="https://itsolutionstuff.com/post/which-mysql-datatype-use-for-store-an-ip-address" target="_blank" rel="noopener">Which MySQL datatype use for store an IP address?</a></li><li><a href="https://stackoverflow.com/questions/2542011/most-efficient-way-to-store-ip-address-in-mysql" target="_blank" rel="noopener">Most efficient way to store IP Address in MySQL</a></li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/miscellaneous-functions.html#function_inet6-aton" target="_blank" rel="noopener">MySQL doc-function_inet6-aton</a></li><li><a href="https://www.cnblogs.com/gomysql/p/4595621.html" target="_blank" rel="noopener">IP 地址在数据库里面的存储方式</a></li><li><a href="https://www.cnblogs.com/skynet/archive/2011/01/09/1931044.html" target="_blank" rel="noopener">论 IP 地址在数据库中应该用何种形式存储?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何配置 Pycharm 使用远程的 Flask 虚拟开发环境？</title>
      <link href="/blog/2019-05-06/pycharm-with-remote-flask-venv/"/>
      <url>/blog/2019-05-06/pycharm-with-remote-flask-venv/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>学习<code>Flask</code>开发的时候，因为主机是<code>Windows</code>环境，而日常跑服务的是<code>Linux</code>环境，所以需要通过配置<code>pycharm</code>使之使用远端的虚拟环境。</p><a id="more"></a><h2 id="创建虚拟机Flask环境"><a href="#创建虚拟机Flask环境" class="headerlink" title="创建虚拟机Flask环境"></a>创建虚拟机<code>Flask</code>环境</h2><p>略</p><p>此处在网上可以找到很多写好的教程，不需要我再次叠床架屋了。</p><h2 id="配置Pycharm环境"><a href="#配置Pycharm环境" class="headerlink" title="配置Pycharm环境"></a>配置<code>Pycharm</code>环境</h2><p>打开 Pycharm 的 setting 对话框，按照如下配置  </p><p><img src="/images/snipaste_20190506_141224.jpg" alt="setting_start"></p><p>依次输入真实远端信息之后，点击下一步，直到出现下方对话框</p><p><img src="/images/snipaste_20190506_142141.jpg" alt="setting_end"></p><p>依次修改将要使用的解释器和主机与远端需要保持同步的目录；</p><p><img src="/images/snipaste_20190506_143428.jpg" alt="setting_flask"></p><p>如图设置之后运行，<code>Run</code>出现如下结果<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FLASK_APP = app</span><br><span class="line">FLASK_ENV = development</span><br><span class="line">FLASK_DEBUG = 1</span><br><span class="line">In folder D:/MYcode/flk</span><br><span class="line">ssh://root@192.168.116.21:22/home/imoyao/envs/flk/bin/python -u -m flask run --host=0.0.0.0</span><br><span class="line"> * Serving Flask app "app" (lazy loading)</span><br><span class="line"> * Environment: development</span><br><span class="line"> * Debug mode: on</span><br><span class="line"> * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line"> * Restarting with stat</span><br><span class="line"> * Debugger is active!</span><br><span class="line"> * Debugger PIN: 820-491-228</span><br></pre></td></tr></table></figure></p><p>之后在本机访问虚拟机<code>ip</code>，比如本例中的<code>192.168.116.21:5000</code>，即可进入<code>app</code>首页。</p><h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><p>在配置好上述选项之后，运行可能会提示 <code>NoAppException: Could not import &quot;app&quot;.</code>。这个问题暂时不知道是什么原因引起，可能是<code>Pycharm</code>识别路径有误导致，暂时没有找到很好的解决办法。大家可以参考下图尝试配置（递归手动设置目录，可能有用）。</p><p><img src="/images/snipaste_20190507_133810.jpg" alt="can&#39;t_import_app"></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>今天突然出现不能访问的问题，使用<code>netstat nap|grep 5000(flask 运行端口)</code>查看端口状态：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcp        0      0 0.0.0.0:5000            0.0.0.0:*               LISTEN      8195/python</span><br></pre></td></tr></table></figure></p><p>说明端口正常开放，怀疑是防火墙的原因<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure></p><p>关闭之后可以正常访问，确认是其问题。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=5000/tcp --permanent</span><br><span class="line">Warning: ALREADY_ENABLED: 5000:tcp</span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>重启防火墙之后可以正常访问：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172 ~]<span class="comment"># systemctl stop firewalld</span></span><br><span class="line"></span><br><span class="line">[root@172 ~]<span class="comment"># firewall-cmd --reload</span></span><br><span class="line">FirewallD is not running</span><br><span class="line"></span><br><span class="line">[root@172 ~]<span class="comment"># firewall-cmd --state</span></span><br><span class="line">running</span><br></pre></td></tr></table></figure></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jetbrains.com/help/pycharm/run-debug-configuration-flask-server.html" target="_blank" rel="noopener">配置<code>flask</code>服务进行调试</a></li><li><a href="https://www.jetbrains.com/help/pycharm/configuring-python-interpreter.html" target="_blank" rel="noopener">配置<code>Python</code>解释器</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> HOWTO </tag>
            
            <tag> PyCharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 传值还是传引用？| 通过对象引用传递</title>
      <link href="/blog/2019-04-13/python-pass-by-object-reference/"/>
      <url>/blog/2019-04-13/python-pass-by-object-reference/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>哈姆雷特不是莎士比亚写的;它只是由一个名叫莎士比亚的人写的。<br>Python 通过对象引用传递。</p><a id="more"></a><p>本文译自 <a href="https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/" target="_blank" rel="noopener">Is Python pass-by-reference or pass-by-value?</a></p><blockquote><p>“假设我对 Fat 说，或 Kevin 对 Fat 说，“你没有经历过上帝。你只不过经历了一些与上帝的品质、方面、性质、力量、智慧和善良有关的事情。”这就像是关于德国人讲的一个双重抽象倾向的笑话；德国英国文学权威宣称，“哈姆雷特不是莎士比亚写的;它只是由一个名叫莎士比亚的人写的。”在英语语境中，这句话的区别只是口头的，没有实际意义，尽管德语中这种表达存在差异（这解释了德国思想的一些奇怪特征）。”<br>  </p><p align="right"> –Valis，p71（Book-of-the-Month-Club Edition）</p><p></p></blockquote><p>Philip K. Dick 并不以其轻松或易懂的散文而闻名。绝大多数角色都很高。就像，真的，真的，真的很高。然而，在 Valis 的上述引文（1981 年出版）中，他对臭名昭着的<code>Python</code>参数传递范式给出了非常有远见的解释。Plus ça change, plus c’est omnomnomnom drugs.</p><p>在编程语言中参数传递的两种最广为人知且易于理解的方法是按引用传递( pass-by-reference )和按值传递 ( pass-by-value )。不幸的是，<code>Python</code>是“传递对象引用”( pass-by-object-reference )，经常说：</p><p>“对象引用按值传递。”(Object references are passed by value.)</p><p>当我第一次看到这个沾沾自喜和过于精辟的定义时，我想捶人。在从手上取下玻璃碎片并被护送出脱衣舞俱乐部后，<del>我意识到所有 3 种范例都可以理解它们如何导致以下 2 个功能的表现：</del></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reassign</span><span class="params">(alist)</span>:</span></span><br><span class="line">    alist = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(alist)</span>:</span></span><br><span class="line">    alist.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">0</span>]</span><br><span class="line">reassign(alist)</span><br><span class="line">append(alist)</span><br></pre></td></tr></table></figure><p>让我们来一探究竟。</p><h2 id="变量不是对象"><a href="#变量不是对象" class="headerlink" title="变量不是对象"></a>变量不是对象</h2><p>“哈姆雷特不是莎士比亚写的;它只是由一个名叫莎士比亚的人写的。” Python 和 PKD（ Philip K. Dick）都在一个东西的本质与我们用来指代那个东西的标签之间做出了至关重要的区分。 “这个名叫莎士比亚的男人”是一个具体的人。 而“莎士比亚”只是一个名字。如果我们这样做：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br></pre></td></tr></table></figure></p><p><code>[]</code>是一个空列表。 a 是指向空列表的变量，但其本身并不是空列表。我画图并将变量称为包含对象的“盒子”;但无论如何你构想它，这种差异是关键。<br><img src="https://robertheaton.com/images/Intro.jpg" alt="Pass-by-reference"></p><h2 id="通过引用传递"><a href="#通过引用传递" class="headerlink" title="通过引用传递"></a>通过引用传递</h2><p>在 pass-by-reference 中，box（变量）直接传递给函数，其内容（由变量表示的对象）隐性地随之而来。在函数上下文中，参数本质上是调用者传入的变量的完整别名。它们都是完全相同的盒子，因此也指向内存中完全相同的对象。<br><img src="https://robertheaton.com/images/PBRIntro.jpg" alt></p><p>因此，函数对变量或它所代表的对象所做的任何操作都将对调用者可见。例如，该函数可以完全更改变量的内容，并将其指向完全不同的对象：</p><p><img src="https://robertheaton.com/images/PBRReassign.jpg" alt></p><p>该函数还可以在不重新分配对象的情况下操作对象，效果相同：<br><img src="https://robertheaton.com/images/PBRAppend.jpg" alt></p><p>重申一下，在<code>pass-by-reference</code>中，函数和调用者都使用完全相同的变量和对象。</p><h2 id="通过值传递"><a href="#通过值传递" class="headerlink" title="通过值传递"></a>通过值传递</h2><p>在<code>pass-by-value</code>中，函数接收调用者传递给它的参数对象的副本，并在内存中开辟新的空间保存。</p><p><img src="https://robertheaton.com/images/PBVIntro.jpg" alt></p><p>然后，该函数有效地提供其自己的盒子以将值放入，并且函数和调用者引用的变量或对象之间不再存在任何关系。这些对象碰巧具有相同的值，但它们完全是分开的，一个对象不会影响到另一个。如果我们再次尝试重新分配：</p><p><img src="https://robertheaton.com/images/PBVReassign.jpg" alt></p><p>在函数之外，没有任何反应。同理：</p><p><img src="https://robertheaton.com/images/PBVAppend.jpg" alt></p><p>调用者上下文中的变量和对象的副本是完全隔离的。</p><h2 id="通过对象引用传递"><a href="#通过对象引用传递" class="headerlink" title="通过对象引用传递"></a>通过对象引用传递</h2><p>在<code>Python</code>是不同的。众所周知，在<code>Python</code>中，“对象引用按值传递”（<code>Object references are passed by value</code>）。</p><p>函数接收对（并将访问）内存中与调用者使用的相同对象的引用。但是，它不会收到调用者正在存储此对象的盒子;在<code>pass-by-value</code>中，函数提供自己的筐并为自己创建一个新变量。让我们再次执行<code>append</code>：</p><p><img src="https://robertheaton.com/images/PBORAppend.jpg" alt></p><p>函数和调用者都引用内存中的同一个对象，所以当<code>append</code>函数向列表中添加一个额外的项时，我们也会在调用者中看到这个！它们是同一个东西的不同名称;包含相同对象的不同筐。这意味着是通过值传递对象引用的——函数和调用者在内存中使用相同的对象，但是通过不同的变量访问。这意味着同一个对象被存储在多个不同的筐中，而这种隐喻会被打破。<del>假定它是量子或其他东西。</del></p><p>但关键是它们真的是不同的名字和不同的盒子。在<code>pass-by-reference</code>中，它们是相同的盒子。当你试图重新分配一个变量，并将一些不同的东西放入函数的盒子中时，你也将它放入调用者的盒子中，因为它们是同一个盒子。但是，在<code>pass-by-object-reference</code>中：</p><p><img src="https://robertheaton.com/images/PBORReassign.jpg" alt></p><p>调用者不在乎你是否重新分配方法的盒子。不同的盒子，相同的内容。</p><p>现在我们看看菲利普·K·迪克试图告诉我们的事情。名字和人是不同的东西。变量和对象是不同的东西。有了这些知识，你或许可以开始推断当你做这样的事情时会发生什么</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listA = [0]</span><br><span class="line">listB = listA</span><br><span class="line">listB.append(1)</span><br><span class="line">print listA</span><br></pre></td></tr></table></figure><p>你可能还想了解这些概念与可变和不可变类型之间的有趣交互。但这些是另一回事了。现在，如果你能原谅我，我要去读《Dororoids Dream Of Electric Sheep？》了。 - 我对元编程有点生疏。</p><hr><p><a href="https://eev.ee/blog/2012/05/23/python-faq-passing/" target="_blank" rel="noopener">Does Python pass by reference or value?</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://foobarnbaz.com/2012/07/08/understanding-python-variables/" target="_blank" rel="noopener">http://foobarnbaz.com/2012/07/08/understanding-python-variables/</a> </li><li><a href="http://javadude.com/articles/passbyvalue.htm" target="_blank" rel="noopener">http://javadude.com/articles/passbyvalue.htm</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下如何安装 Redis？</title>
      <link href="/blog/2019-04-11/how-to-install-Redis-on-Linux/"/>
      <url>/blog/2019-04-11/how-to-install-Redis-on-Linux/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><code>Redis</code>是一款高性能的<code>key-value</code>数据库，本文主要记录如何在<code>Linux</code>系统上进行安装，以及为<code>Python</code>开发安装对应的<code>redis</code>模块。</p><a id="more"></a><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><ul><li><p><code>Linux</code>版本</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ubuntu 18.04 LTS &amp;&amp; NeoKylin 3.2</span><br></pre></td></tr></table></figure></li><li><p><code>Python</code>版本</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Python 2.7.15rc1 &amp;&amp; Python 2.6.6</span><br></pre></td></tr></table></figure></li><li><p><code>Redis</code>版本</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-5.0.4</span><br></pre></td></tr></table></figure></li><li><p><code>redis-py</code>版本</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-3.2.1 &amp;&amp; redis-2.10.6</span><br></pre></td></tr></table></figure></li></ul><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载地址：<code>http://redis.io/download</code>，下载最新稳定版本源码。</p><p>本文使用的版本为 <code>redis-5.0.4</code>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><ol><li><p>解压缩</p><p> 首先要解压<code>Redis</code>压缩包。进入压缩包下载的路径，执行：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar xzf redis-5.0.4.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>使用<code>GCC</code>编译源码</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis-5.0.4</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>安装<code>Redis</code></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>验证</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@local:~/temp# redis-server -v</span><br><span class="line">Redis server v=5.0.4 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=3dcf53963ddc396a</span><br><span class="line">root@local:~/temp# whereis redis-server</span><br><span class="line">redis-server: /usr/local/bin/redis-server</span><br></pre></td></tr></table></figure></li></ol><p>至此，<code>Redis</code>安装完成。</p><h3 id="CentOs"><a href="#CentOs" class="headerlink" title="CentOs"></a>CentOs</h3><ol><li><p>编译安装</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make $$ make install</span><br></pre></td></tr></table></figure><p> 此时报错</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CC adlist.o</span><br><span class="line">/bin/sh: cc: command not found</span><br><span class="line">make[1]: *** [adlist.o] Error 127</span><br><span class="line">make[1]: Leaving directory `/root/temp/redis-5.0.4/src'</span><br><span class="line">make: *** [all] Error 2</span><br></pre></td></tr></table></figure></li><li><p>安装 gcc</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install gcc -y</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>重新 make</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p> 此时报错</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">In file included from adlist.c:34:</span><br><span class="line">zmalloc.h:50:31: error: jemalloc/jemalloc.h: No such file or directory</span><br><span class="line">zmalloc.h:55:2: error: #error "Newer version of jemalloc required"</span><br><span class="line">make[1]: *** [adlist.o] Error 1</span><br><span class="line">make[1]: Leaving directory `/root/temp/redis-5.0.4/src'</span><br><span class="line">make: *** [all] Error 2</span><br></pre></td></tr></table></figure><p> 在构建<code>Redis</code>时选择非默认内存分配器是通过设置<code>MALLOC</code>环境变量完成的， 默认情况下 Redis 是使用<code>malloc</code>为<code>libc</code>编译和链接的。<br> 而<code>libc</code>并不是<code>Linux</code>上默认的分配器，默认的是 <code>jemalloc</code>, 因为 <code>jemalloc</code> 被证明比<code>libc</code>有更少的碎片问题（<code>fragmentation problems</code>）。<br> 但是如果你没有<code>jemalloc</code> 而只有<code>libc</code> 当然 <code>make</code> 出错。 所以有两种解决办法：</p></li></ol><ul><li><p><del>方法一</del>（不推荐）</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make MALLOC=libc</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p>方法二</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd deps/</span><br><span class="line">make hiredis jemalloc linenoise lua geohash-int</span><br></pre></td></tr></table></figure></li></ul><p>原因参见： <a href="http://www.jb51.net/article/100575.htm" target="_blank" rel="noopener">浅谈 redis 采用不同内存分配器 tcmalloc 和 jemalloc</a></p><blockquote><p>对于<code>tcmalloc</code>，<code>jemalloc</code>和<code>libc</code>对应的三个内存分配器。其性能和碎片率如何呢？<br>下面是一个简单测试结果，使用<code>Redis</code>自带的<code>redis-benchmark</code>写入等量数据进行测试，数据摘自采用不同分配器时<code>Redis info</code>信息。<br>我们可以看到，采用<code>tcmalloc</code>时碎片率是最低的，为<code>1.01</code>，<code>jemalloc</code>为<code>1.02</code>，而<code>libc</code>的分配器碎片率为<code>1.31</code>，</p></blockquote><ol><li><p>编译安装</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make $$ make install</span><br></pre></td></tr></table></figure></li><li><p>验证</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server -v</span><br><span class="line">Redis server v=5.0.4 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=b139020f90f1d493</span><br><span class="line">whereis redis-server</span><br><span class="line">redis-server: /usr/local/bin/redis-server</span><br></pre></td></tr></table></figure></li></ol><p>至此，<code>Redis</code>安装完成。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>通过配置文件，设置<code>Redis</code>服务开机自启动。</p><ol><li><p>设置自启动配置文件</p><ol><li><p>切换目录</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd utils/</span><br></pre></td></tr></table></figure></li><li><p>复制脚本文件</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp redis_init_script /etc/init.d/redisd</span><br></pre></td></tr></table></figure><p> 将<code>redis_init_script</code>文件重新命名为<code>redisd</code>，作为系统启动服务名（以<code>d</code>结尾表示是自启动服务，约定俗成）。</p></li><li><p>修改配置</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/init.d/redisd</span><br></pre></td></tr></table></figure></li><li><p>修改<code>redisd</code>文件，注意要在文件头部加上两句注释来设定该服务的运行级别</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chkconfig:   2345 90 10</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>设置<code>Redis</code>控制脚本的配置文件</p><ol><li><p>切换目录</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd -</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure></li><li><p>在<code>redis</code>安装目录下，找到<code>redis.conf</code>文件</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p> 如下</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">00-RELEASENOTES  INSTALL     runtest           tests</span><br><span class="line">BUGS             Makefile    runtest-cluster   utils</span><br><span class="line">CONTRIBUTING     MANIFESTO   runtest-sentinel</span><br><span class="line">COPYING          README.md   sentinel.conf</span><br><span class="line">deps             redis.conf  src</span><br></pre></td></tr></table></figure></li><li><p>复制配置文件并重命名</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp redis.conf /etc/redis/6379.conf</span><br></pre></td></tr></table></figure></li><li><p>编辑<code>Redis</code>配置文件</p><ol><li><p>设置<code>daemonize</code>为<code>yes</code>，使服务可以后台运行：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nu:136</span></span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure></li><li><p>设置<code>log</code>文件路径：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nu:171</span></span><br><span class="line">logfile /var/log/redis/redis-server.log</span><br></pre></td></tr></table></figure></li><li><p>设置持久化文件存放路径：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nu:263</span></span><br><span class="line">dir /var/lib/redis</span><br></pre></td></tr></table></figure></li></ol></li><li><p>保存退出，并创建相应的目录结构：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /var/log/redis</span><br><span class="line">touch /var/log/redis/redis-server.log</span><br><span class="line">mkdir /var/lib/redis</span><br></pre></td></tr></table></figure></li></ol></li><li><p>设置开机自启</p><h4 id="Ubuntu-1"><a href="#Ubuntu-1" class="headerlink" title="Ubuntu"></a>Ubuntu</h4> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 赋权</span></span><br><span class="line">chmod +x /etc/init.d/redisd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新系统启动项</span></span><br><span class="line">update-rc.d redisd defaults</span><br></pre></td></tr></table></figure><h4 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h4> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master init.d]# chmod +x ./redisd</span><br><span class="line">[root@master init.d]# chkconfig redisd on</span><br></pre></td></tr></table></figure></li></ol><h2 id="附：常用redis管理命令"><a href="#附：常用redis管理命令" class="headerlink" title="附：常用redis管理命令"></a>附：常用<code>redis</code>管理命令</h2><ul><li>启动<code>Redis</code>服务：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service redisd start</span><br><span class="line">[root@master init.d]# service redisd start</span><br><span class="line">Starting Redis server...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证</span></span><br><span class="line">[root@master init.d]# ps aux|grep redis|grep -v grep</span><br><span class="line">root      6728  0.1  0.4  55572  9820 ?        Ssl  11:03   0:00 /usr/local/bin/redis-server 127.0.0.1:6379</span><br></pre></td></tr></table></figure><ul><li>关闭服务：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master init.d]# service redisd stop</span><br><span class="line">Stopping ...</span><br><span class="line">Redis stopped</span><br><span class="line">[root@master init.d]# ps aux|grep redis|grep -v grep</span><br></pre></td></tr></table></figure><ul><li>重启服务：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service redisd restart</span><br></pre></td></tr></table></figure><ul><li>在控制台中登录<code>redis</code>客户端：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master init.d]# redis-cli</span><br><span class="line"># 测试redis连通性</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br></pre></td></tr></table></figure><h2 id="安装提供Python支持"><a href="#安装提供Python支持" class="headerlink" title="安装提供Python支持"></a>安装提供<code>Python</code>支持</h2><h3 id="pip-安装"><a href="#pip-安装" class="headerlink" title="pip 安装"></a>pip 安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install redis</span><br></pre></td></tr></table></figure><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p>去<code>https://pypi.org/project/redis/</code>下载源码，<code>Ubuntu</code>上使用最新版本<code>redis 3.2.1</code></p><ol><li><p>解压</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzvf redis-3.2.1.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>切换目录</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis-3.2.1</span><br></pre></td></tr></table></figure></li><li><p>安装</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></li><li><p>验证</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@local:~/temp/redis-3.2.1# python</span><br><span class="line">Python 2.7.15rc1 (default, Apr 15 2018, 21:51:34) </span><br><span class="line">[GCC 7.3.0] on linux2</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import redis</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import redis</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; r = redis.Redis(host=<span class="string">'localhost'</span>, port=6379, db=0)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; ret = r.get(<span class="string">'hello'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">print</span> ret</span></span><br><span class="line">world</span><br></pre></td></tr></table></figure></li></ol><hr><p><strong>小插曲</strong></p><p>关于 redis-py 的 Python 低版本支持</p><p>在<code>CentOS</code>上安装<code>redis-3.2.1</code>的时候由于<code>python</code>版本较低（<code>2.6.6</code>）出现以下问题<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master redis-3.2.1]# python setup.py install</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "setup.py", line 4, in &lt;module&gt;</span><br><span class="line">    from setuptools import setup</span><br><span class="line">ImportError: No module named setuptools</span><br></pre></td></tr></table></figure></p><p>安装<code>setuptools-0.6c9</code>之后执行<code>python setup.py install</code>报错：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "setup.py", line 7, in &lt;module&gt;</span><br><span class="line">    from redis import __version__</span><br><span class="line">  File "/root/temp/pyredis-3.2.1/redis/__init__.py", line 1, in &lt;module&gt;</span><br><span class="line">    from redis.client import Redis, StrictRedis</span><br><span class="line">  File "/root/temp/pyredis-3.2.1/redis/client.py", line 3046</span><br><span class="line">    return &#123;decode(encode(k)): v for k, v in iteritems(data)&#125;</span><br><span class="line">                                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>去官网查看，发现最新版版本支持为：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Meta</span><br><span class="line">……</span><br><span class="line"> Tags: Redis, key-value store</span><br><span class="line"></span><br><span class="line">Requires: Python &gt;=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*</span><br></pre></td></tr></table></figure></p><p>以及</p><blockquote><p>Python Version Support<br>redis-py 3.0 now supports Python 2.7 and Python 3.4+. Python 2.6 and 3.3 support has been dropped.</p></blockquote><p>最后安装较低版本（<code>redis-2.10.6</code>）成功，步骤同上，不再赘述。</p><p>读者可以从 <a href="https://pypi.org/project/redis/#history" target="_blank" rel="noopener">这里</a> 获取历史版本：<code>https://pypi.org/project/redis/#history</code></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://redis.io/topics/quickstart" target="_blank" rel="noopener">Redis Quick Start</a></li><li><a href="https://blog.csdn.net/softwave/article/details/53838194" target="_blank" rel="noopener">Ubuntu 安装 Redis 并设置为开机自启动服务</a></li><li><a href="https://www.cnblogs.com/cnkai/p/7642787.html" target="_blank" rel="noopener">Python 操作 Redis 数据库</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> HOWTO </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何获取 Ztree 的所有叶子节点？</title>
      <link href="/blog/2019-01-30/how-to-get-leaf-nodes-of-Ztree/"/>
      <url>/blog/2019-01-30/how-to-get-leaf-nodes-of-Ztree/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>使用<code>Ztree</code>时，<code>treeNode.children</code>只能获取到子节点，该如何拿到节点的叶子节点呢？</p><a id="more"></a><h2 id="创建初始化设置"><a href="#创建初始化设置" class="headerlink" title="创建初始化设置"></a>创建初始化设置</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setting = &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        simpleData: &#123;</span><br><span class="line">            enable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    callback: &#123;</span><br><span class="line">        onCheck:onCheck,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="创建点击响应事件"><a href="#创建点击响应事件" class="headerlink" title="创建点击响应事件"></a>创建点击响应事件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onCheck</span>(<span class="params">event, treeId, treeNode, clickFlag</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> treeObj = $(ELT).fn.zTree.getZTreeObj(<span class="string">"datarecdirs"</span>);</span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line">        str = getAllChildNodes(treeNode,str);</span><br><span class="line">        <span class="comment">// // 加上被选择节点自身</span></span><br><span class="line">        <span class="comment">// str = str + ',' + treeNode.id;</span></span><br><span class="line">        <span class="comment">// 去掉最前面的逗号</span></span><br><span class="line">        <span class="keyword">var</span> ids = str.substring(<span class="number">1</span>, str.length);</span><br><span class="line">        <span class="comment">// 得到所有节点ID 的数组</span></span><br><span class="line">        <span class="keyword">var</span> idsArray = ids.split(<span class="string">','</span>);</span><br><span class="line">        <span class="comment">// 过滤掉序列中的空元素 [1,2,'3',"", ''] &gt;&gt;&gt; [1,2,'3']   (javascript 1.6 and above)</span></span><br><span class="line">        <span class="keyword">var</span> filterArr = idsArray.filter(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;<span class="keyword">return</span> n&#125;);       </span><br><span class="line">        <span class="comment">// 得到节点总数量</span></span><br><span class="line">        <span class="keyword">var</span> leafNodesLen = filterArr.length;</span><br><span class="line">        <span class="keyword">if</span>(filterArr)&#123;</span><br><span class="line">            <span class="keyword">var</span> nodeChecked = treeNode.checked;</span><br><span class="line">            <span class="keyword">if</span>(nodeChecked)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; leafNodesLen; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> idVal = filterArr[i];</span><br><span class="line">                    <span class="keyword">var</span> node = treeObj.getNodeByParam(<span class="string">"id"</span>, idVal, <span class="literal">null</span>);</span><br><span class="line">                    treeObj.setChkDisabled(node,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; leafNodesLen; j++) &#123;</span><br><span class="line">                    idVal = filterArr[j];</span><br><span class="line">                    <span class="comment">// 按照id获取节点，see:https://www.oschina.net/question/222309_131001</span></span><br><span class="line">                    node = treeObj.getNodeByParam(<span class="string">"id"</span>, idVal, <span class="literal">null</span>);       <span class="comment">// 注意：此处不可使用getNodeByTId()方法</span></span><br><span class="line">                    treeObj.setChkDisabled(node,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>);  <span class="comment">//取消禁用时，影响到子节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> nodes = treeObj.getCheckedNodes();</span><br><span class="line">                <span class="built_in">console</span>.log(nodes);</span><br><span class="line">                <span class="keyword">if</span> (nodes.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">var</span> c=<span class="number">0</span>;c&lt;nodes.length;c++)&#123;</span><br><span class="line">                        treeObj.checkNode(nodes[c],<span class="literal">false</span>,<span class="literal">true</span>);     <span class="comment">//注意，此处不可使用cancelSelectedNode()</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 递归，获取所有子节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAllChildNodes</span>(<span class="params">treeNode,result</span>)</span>&#123;     <span class="comment">// 获取节点的所有叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (treeNode.isParent) &#123;</span><br><span class="line">        <span class="keyword">var</span> childrenNodes = treeNode.children;</span><br><span class="line">        <span class="keyword">if</span> (childrenNodes) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; childrenNodes.length; i++) &#123;</span><br><span class="line">                result += <span class="string">','</span> + childrenNodes[i].id;</span><br><span class="line">                result = getAllChildNodes(childrenNodes[i], result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span class="label label-danger">注意</span><blockquote><p>zTree 里严格区分了选中和勾选这两个概念，选中是指节点被选择背景颜色有变化，因此 cancelSelectedNode()只是把你选择的节点，变成不选择状态，也就是节点的背景色发生变化。<br>而勾选是指节点的勾选框被选中，你要将节点的勾选状态由勾选变为不勾选，就不能使用 cancelSelectedNode()方法，只能使用 checknode()方法！</p></blockquote><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><ul><li><a href="https://blog.csdn.net/qq_15071263/article/details/82797734" target="_blank" rel="noopener">zTree 插件 - 获取当前选择节点下的全部子节点</a> </li><li><a href="https://tieba.baidu.com/p/4157358359?red_tag=3393089686" target="_blank" rel="noopener">为什么 cancelSelectedNode()取消不了节点的选中状态？</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zTree </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次 MySQL 错误 —— mysqld-dead-but-subsys-locked</title>
      <link href="/blog/2019-01-25/mysqld-dead-but-subsys-locked/"/>
      <url>/blog/2019-01-25/mysqld-dead-but-subsys-locked/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>记一次<code>MySQL</code>服务出错排查过程。</p><a id="more"></a><p>今天登录管理系统的时候输入账户信息没有反应，后台查看系统日志发现报错信息：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span></span></span><br><span class="line">tailf /var/log/ODSP.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> out(部分有用信息)</span></span><br><span class="line">2019-01-25 11:30:07 database [line:263]: Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2)</span><br></pre></td></tr></table></figure></p><h2 id="查看MySQL服务状态"><a href="#查看MySQL服务状态" class="headerlink" title="查看MySQL服务状态"></a>查看<code>MySQL</code>服务状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span></span></span><br><span class="line">/etc/init.d/mysqld status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> out</span></span><br><span class="line">mysqld dead but subsys locked</span><br></pre></td></tr></table></figure><h2 id="查看MySQL的log信息"><a href="#查看MySQL的log信息" class="headerlink" title="查看MySQL的log信息"></a>查看<code>MySQL</code>的<code>log</code>信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span></span></span><br><span class="line">tailf /var/log/mysqld.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> out（截取部分有用信息）</span></span><br><span class="line">700101 00:28:38 mysqld_safe mysqld from pid file /var/run/mysqld/mysqld.pid ended</span><br><span class="line">700101 00:28:42 mysqld_safe Starting mysqld daemon with databases from /secbox/var/db</span><br><span class="line">700101  0:28:42 [ERROR] This MySQL server doesn't support dates later then 2038</span><br><span class="line">700101  0:28:42 [ERROR] Aborting</span><br></pre></td></tr></table></figure><h2 id="查看系统时间"><a href="#查看系统时间" class="headerlink" title="查看系统时间"></a>查看系统时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master digitools]# date</span><br><span class="line">Wed Jan  1 00:31:52 CST 2070</span><br></pre></td></tr></table></figure><h2 id="重新设置系统时间"><a href="#重新设置系统时间" class="headerlink" title="重新设置系统时间"></a>重新设置系统时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master digitools]# date -s "20190125 11:28:50"</span><br><span class="line">Fri Jan 25 11:28:50 CST 2019</span><br></pre></td></tr></table></figure><h2 id="重新启动MySQL服务"><a href="#重新启动MySQL服务" class="headerlink" title="重新启动MySQL服务"></a>重新启动<code>MySQL</code>服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master digitools]# /etc/init.d/mysqld status</span><br><span class="line">mysqld dead but subsys locked</span><br><span class="line"></span><br><span class="line">[root@master digitools]# /etc/init.d/mysqld stop</span><br><span class="line">Stopping mysqld:                                           [  OK  ]</span><br><span class="line">[root@master digitools]# /etc/init.d/mysqld start</span><br><span class="line">Starting mysqld:                                           [  OK  ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面两步命令也可以直接合并为执行 `/etc/init.d/mysqld restart`</span></span><br><span class="line">[root@master digitools]# /etc/init.d/mysqld status</span><br><span class="line">mysqld (pid  19402) is running...</span><br></pre></td></tr></table></figure><h2 id="日志恢复正常"><a href="#日志恢复正常" class="headerlink" title="日志恢复正常"></a>日志恢复正常</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">190125 11:30:10  InnoDB: Initializing buffer pool, size = 8.0M</span><br><span class="line">190125 11:30:10  InnoDB: Completed initialization of buffer pool</span><br><span class="line">190125 11:30:10  InnoDB: Started; log sequence number 0 398010</span><br><span class="line">190125 11:30:10 [Note] Event Scheduler: Loaded 0 events</span><br><span class="line">190125 11:30:10 [Note] /usr/libexec/mysqld: ready for connections.</span><br><span class="line">Version: '5.1.71'  socket: '/var/lib/mysql/mysql.sock'  port: 3306  Source distribution</span><br></pre></td></tr></table></figure><p>至此，数据库异常问题修复，前台登录系统恢复正常。</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><ul><li><a href="https://en.wikipedia.org/wiki/Year_2038_problem" target="_blank" rel="noopener">Year 2038 problem</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重在参与的 2018</title>
      <link href="/blog/2019-01-22/Annual-record-of-2018/"/>
      <url>/blog/2019-01-22/Annual-record-of-2018/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>岁月不居，时光如流。今天心血来潮换了个 Hexo 的主题——FreeMind。原本的 Material 主题在将网站背景图片自定义为 Bing 随机图片之后会打开很慢，按照「超过 3 秒都是病」的原则，遂换上了现在的主题。本该早点对 2018 年做个年终总结的（虽然也没什么人看），可是最近拖延症发作加上一直加班，所以就很久没更新博客和公众号了。（注意：这是我为自己找的一个骗人的借口。）<br><a id="more"></a></p><p>首先对 2018 年立的 Flag 做个简单回顾：</p><ul><li>找个女朋友；</li></ul><p>今年认识了 2、3 个女生，不过令人遗憾的是到头来还是无功而返。（我们跟随着可怜的小家伙的脚步，到头来发现这个笨蛋还是没能送出祖传的 DNA !）<br>还有一个令人绝望的消息是：由于年龄的增长，逐渐对现实有了清晰一点的认识，意识到大多数人根本没有收获爱情的可能，大多数到头来只是对生活做出妥协找了一个伙伴以降低生活中的不可控风险。可能比起爱情来，找一个在事业或者生活上可以为你提供帮助的人，甚至只是性格上合得来的同伴相对现实一些。</p><ul><li>克服困难，通过节食加锻炼将体重控制在可接受的范围之内；</li></ul><p>今年的体重总体上来说形成了一条「微笑曲线」。六月份到十月份之间通过跑步和不规律性的节食减掉了将近 20 斤。然而由于天气转冷后人变懒了，跑步中止，运动放弃，现在体重又恢复到 140 斤左右。所以只能说万幸没有增重，但是减肥的结果依然不是很理想。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>今年总体上来说没有什么大的收获，甚至可以说有点乏味。每天都忙着解决公司代码中的 BUG ,技术上也没有很大的提高，在这种重复中想要提高自己真的很慢，同时没有动力和意志去学习成长提高自己。偶尔只是在心血来潮的那么一下子做个「马来人」收集一些看起来有用的资料，可是到头来真的沉下心去看的机会依然很少。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>两点一线的废柴生活没有多少波澜，也没有什么值得浪费笔墨的点。噩耗是并不年迈的舅舅却因为意外去世。实际上三舅是我比较钦佩的一个亲人，在上个世纪大家受教育程度普遍不高的大背景下通过个人辛勤劳动攒下百万家产，同时对亲人也很热心。我生性孤冷，一向不擅于表达自己的感情。原本想着在朋友圈纪念一下舅舅的去世，又担心被别人认为是哗众取宠的傻×，所以暂且在这里写下一段文字聊表对舅舅去世的惋惜吧。</p><p><em>呜呼，天降灾否，小甥伤悲，痛何如哉！</em></p><p><em>您性也孝，外婆久病，不嫌不弃，以克终养；</em><br><em>您性又贤，姊妹有难，亲力亲为，急其所难。</em></p><p><em>余忆幼时，不辨叔舅，呼汝大大，惹人捧腹；</em><br><em>童龀之年，舅父严厉，甩鞭山响，吓我趋走。</em></p><p><em>再忆高中，条件艰苦，披星戴月，载我回家；</em><br><em>呜呼，言有穷而情不可终。呜呼哀哉！伏惟尚飨！</em></p><h2 id="一点困惑"><a href="#一点困惑" class="headerlink" title="一点困惑"></a>一点困惑</h2><ul><li><span class="label label-warning">Q:</span> 只写代码是否过好这一生？随着年龄增长如何不被新人替代？</li></ul><p>程序员工作是一个不断学习的职业，在一个公司呆久了可能对公司的代码特别熟悉。但是对熟悉的东西越熟悉，对陌生的东西可能也会逐渐变得更加陌生。在这样的情况下，如果避免「后来者居上」的尴尬？</p><ul><li><span class="label label-warning">Q:</span> 如何提高自己的亲和力，变成一个让别人感觉舒服的陌生人？</li></ul><p>同样是一个和你无怨无仇的同事，为什么有的人你和 Ta 很聊得来，有的人只是表面应付，其实内心很抵触和 Ta 沟通？排除颜值上面的外在因素，还有什么在影响着人与人之间的和谐相处呢？</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>2019 年可能会考虑换一个工作环境。一方面希望技术能够有更好的锤炼，感觉自己还需要在深广度上学习一个，而目前的工作更多的只是一些很基础的操作，很多高级用法根本没有应用场景，因此缺少学习的动力；另一方面，在一个平常的地方待久了，人也没有了危机感和进取心。</p><blockquote><p>吾常身不离鞍，髀肉皆消。今不复骑，髀里肉生。日月若驰，老将至矣，而功业不建，是以悲耳。</p></blockquote><p>还有，计划在找好工作之后报考驾照，我原本以为无人驾驶技术的普及到后来就没有必要学习驾照。但是现在看来当初对的预测有点乐观。或许的可期的未来，城市之中的热点线路上自动化驾驶技术可以实现普及，但是在更多的个性化定制方面可能依然需要假以时日。一如人们吐槽的那样，目前的人工智能暂时还只能被叫做「人工智障」。</p><p>老生常谈的一件事：既然没有能力做一个单身贵族，那么还是要尽量努力解决个人问题，不要让父母过分担心。但是这个问题我更多的只能尽人事而知天命，有合适的姑娘的话加倍努力，没合适的我也只能有心杀贼，无力回天啦！</p><p>心有大愿，不计风雨，风雨之中，愿你安好，阳光之下，愿你灿烂。</p><p>胸有鸿鹄志，奈何燕雀身。今天很难,明天更难。真是「长恨此身非我有」，不知「何时忘却营营」。正所谓<code>万物之中,希望至美</code>。加油吧！  </p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=353993&auto=1&height=32"></iframe><blockquote><p>鸿鹄之志千万里，你勃然而起。<br>嘿我能，嘿我能，老子可以！<br>你引颈向天歌一曲。<br>天将降大任于你，磨练你的筋骨皮。<br>玉不琢不成器，出水才见两腿泥<br>住大房子开大车嗅大蜜，<br>谁家的姑娘都能明媒正娶。<br>让那些狗眼看人低的东西，再也不敢瞧不起你。</p><p>你爸爸不是贪官污吏，母亲是良家妇女。<br>你也没有可以让你少奋斗十年的上流社会关系。<br>幻想的假象多么美丽，你很傻很天真。<br>这真枪实弹的成人游戏，很黄很暴力。</p><p>路漫漫其修远兮，十万八千里。<br>时运不济你的磨难兮，九九八十一。<br>你用鸡生蛋用蛋生鸡，真他妈不容易。<br>他突然一场暴风雨，鸡飞蛋打了。</p><p>昨日的朋友今非昔比，你再也没有兴趣谈起。<br>昔日的恋人随青春而去，童话般的回忆。</p><p>夕阳西下湖水边的倒影里，你看清楚了自己。<br>妻子在不远处呼唤着你的名字，儿子跑过来说他会多么了不起。</p><p>鸿鹄志你的鸿鹄志，像一首年少轻狂的诗。<br>那曾经自命不凡的日子，在多年以后一笑了之。<br>鸿鹄志你的鸿鹄之志，像一首年少轻狂的诗。</p><p>那曾经自命不凡的日子，在上下班的人流中慢慢消失。<br>在你的酒杯中慢慢消失，在你的床单上慢慢消失，<br>在你的工资里慢慢消失，在现实的旋涡中慢慢消失。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pip 小老弟，你怎么肥四？</title>
      <link href="/blog/2018-09-21/get-some-trouble-with-pip/"/>
      <url>/blog/2018-09-21/get-some-trouble-with-pip/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天用<code>pip</code>的时候突然不能正常使用，在这里简单记录一下。<br><a id="more"></a></p><h2 id="提示pip版本不对"><a href="#提示pip版本不对" class="headerlink" title="提示pip版本不对"></a>提示<code>pip</code>版本不对</h2><h3 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You are using pip version 9.0.3, however version 18.0.1 is available.</span><br><span class="line">You should consider upgrading via the &apos;python -m pip install --upgrade pip&apos; command.</span><br></pre></td></tr></table></figure><h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h3><p>去<a href="https://pypi.org/project/pip/" target="_blank" rel="noopener">官网</a>下载最新版的包，直接解压安装即可；</p><h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><p><a href="https://blog.csdn.net/XavierDarkness/article/details/81234066" target="_blank" rel="noopener">Python2.7 自带的 pip9.0 升级到 pip18.0</a></p><h2 id="明确已经安装pip，但是系统提示找不到pip"><a href="#明确已经安装pip，但是系统提示找不到pip" class="headerlink" title="明确已经安装pip，但是系统提示找不到pip"></a>明确已经安装<code>pip</code>，但是系统提示找不到<code>pip</code></h2><h3 id="错误提示-1"><a href="#错误提示-1" class="headerlink" title="错误提示"></a>错误提示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-bash: /home/imoyao/.local/bin/pip: No such file or directory</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.which pip </span><br><span class="line">/usr/local/bin/pip</span><br><span class="line"></span><br><span class="line">2.pip </span><br><span class="line">-su: /usr/bin/pip: No such file or directory</span><br><span class="line"></span><br><span class="line">3.type pip </span><br><span class="line">pip is hashed (/usr/bin/pip) </span><br><span class="line">So pip is definintely in /usr/local/bin/pip but it is been cached as in /usr/bin/pip, thanks to the Stackoverflow question, the solution is very simple:</span><br><span class="line"></span><br><span class="line">4.hash -r </span><br><span class="line">When the cache is clear, pip is working again.</span><br></pre></td></tr></table></figure><h3 id="参考来源-1"><a href="#参考来源-1" class="headerlink" title="参考来源"></a>参考来源</h3><p><a href="https://blog.csdn.net/qq_32755575/article/details/80443714" target="_blank" rel="noopener">/usr/bin/pip: No such file or directory</a></p><h2 id="安装或升级pip时提示SSLError"><a href="#安装或升级pip时提示SSLError" class="headerlink" title="安装或升级pip时提示SSLError"></a>安装或升级<code>pip</code>时提示<code>SSLError</code></h2><h3 id="错误提示-2"><a href="#错误提示-2" class="headerlink" title="错误提示"></a>错误提示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;SSLError(SSLError(1, &apos;[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:833)&apos;),)&apos;: /simple/pip/</span><br><span class="line">Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;SSLError(SSLError(1, &apos;[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:833)&apos;),)&apos;: /simple/pip/</span><br><span class="line">Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;SSLError(SSLError(1, &apos;[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:833)&apos;),)&apos;: /simple/pip/</span><br><span class="line">Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;SSLError(SSLError(1, &apos;[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:833)&apos;),)&apos;: /simple/pip/</span><br><span class="line">Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by &apos;SSLError(SSLError(1, &apos;[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:833)&apos;),)&apos;: /simple/pip/</span><br><span class="line">Could not fetch URL https://pypi.python.org/simple/pip/: There was a problem confirming the ssl certificate: HTTPSConnectionPool(host=&apos;pypi.python.org&apos;, port=443): Max retries exceeded with url: /simple/pip/ (Caused by SSLError(SSLError(1, &apos;[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:833)&apos;),)) - skipping</span><br><span class="line">#其实本人遇到的错误是</span><br><span class="line">(Caused by SSLError(SSLError(1, u&apos;[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:726)&apos;),))</span><br></pre></td></tr></table></figure><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>临时方案</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装时添加参数：</span><br><span class="line">--trusted-host pypi.python.org</span><br><span class="line">此方式表示信任该域名，但是每一次安装包的时候都需要该操作，比较麻烦；</span><br></pre></td></tr></table></figure><ul><li>永久方案</li></ul><p>修改<code>pip.conf</code> 配置文件，该文件在<code>Linux</code>系统中的可能位置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/pip.conf</span><br><span class="line"></span><br><span class="line">~/.pip/pip.conf</span><br><span class="line"></span><br><span class="line">~/.config/pip/pip.conf</span><br></pre></td></tr></table></figure></p><p>如果都没有的话，可以手动创建之后添加以下内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple/      # 本机使用阿里源代理</span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br><span class="line"></span><br><span class="line"># global字段还看到其他写法：</span><br><span class="line">[global]</span><br><span class="line">trusted-host = pypi.python.org</span><br><span class="line">               pypi.org</span><br><span class="line">               files.pythonhosted.org</span><br></pre></td></tr></table></figure><h3 id="参考来源-2"><a href="#参考来源-2" class="headerlink" title="参考来源"></a>参考来源</h3><p><a href="https://stackoverflow.com/questions/16370583/pip-issue-installing-almost-any-library" target="_blank" rel="noopener">pip issue installing almost any library</a><br><a href="https://www.cnblogs.com/yudar/p/4657511.html" target="_blank" rel="noopener">linux 设置 pip 镜像 Pip Warning：–trusted-host 问题解决方案</a></p><h2 id="安装MySQL-python时提示"><a href="#安装MySQL-python时提示" class="headerlink" title="安装MySQL-python时提示"></a>安装<code>MySQL-python</code>时提示</h2><h3 id="错误提示-3"><a href="#错误提示-3" class="headerlink" title="错误提示"></a>错误提示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EnvironmentError: mysql_config not found</span><br></pre></td></tr></table></figure><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>CentOS</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install libffi-devel </span><br><span class="line">pip install mysql-connector-python</span><br></pre></td></tr></table></figure><ul><li>Ubuntu</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install default-libmysqlclient-dev</span><br></pre></td></tr></table></figure><h3 id="参考来源-3"><a href="#参考来源-3" class="headerlink" title="参考来源"></a>参考来源</h3><p><a href="https://stackoverflow.com/questions/5178292/pip-install-mysql-python-fails-with-environmenterror-mysql-config-not-found" target="_blank" rel="noopener">pip install mysql-python fails with EnvironmentError: mysql_config not found</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRBD 备忘记录</title>
      <link href="/blog/2018-09-11/Record-of-drbd/"/>
      <url>/blog/2018-09-11/Record-of-drbd/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>这是一个关于 <code>DRBD</code> 的使用备忘录。<br><a id="more"></a></p><p><img src="https://docs.linbit.com/ug-src/users-guide-8.4/images/drbd-in-kernel.png" alt="DRBD在Linux内核I/O栈的位置"></p><p>开始阅读之前，请先注意示例中使用的 DRBD 版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm -V</span><br><span class="line"><span class="meta">#</span><span class="bash"> DRBDADM_VERSION=8.4.3</span></span><br></pre></td></tr></table></figure><p>注意：安装的 kernel-devel 的内核源码（内核源码路径/usr/src/kernel/）和当前系统的 kernel 版本(uname -r)不一致的话需要把当前内核更新一下。<br>在<code>2.6.33</code>及以上版本的内核默认中有<code>DRBD</code>,之前在用的<code>DRBD</code>主要<code>8.0</code>、<code>8.2</code>、<code>8.3</code> 三个版本,对应的<code>rpm</code>包是<code>drbd</code>,<code>drbd82</code>和<code>drbd83</code>，因此需要安装对应的内核模块，对应的名字为<code>kmod-drbd</code>,<code>kmod-drbd82</code>,<code>kmod-drbd83</code>。<br>由于<code>drbd</code>是作为内核模块进行工作的，故建议使用与内核对应的版本，对应关系如下表。</p><table><thead><tr><th style="text-align:left">Linux releases</th><th style="text-align:left">DRBD releases</th></tr></thead><tbody><tr><td style="text-align:left">2.6.33</td><td style="text-align:left">8.3.7</td></tr><tr><td style="text-align:left">2.6.34</td><td style="text-align:left">8.3.7</td></tr><tr><td style="text-align:left">2.6.35</td><td style="text-align:left">8.3.8</td></tr><tr><td style="text-align:left">2.6.36</td><td style="text-align:left">8.3.8.1</td></tr><tr><td style="text-align:left">2.6.37</td><td style="text-align:left">8.3.9</td></tr><tr><td style="text-align:left">2.6.38</td><td style="text-align:left">8.3.9</td></tr><tr><td style="text-align:left">2.6.39</td><td style="text-align:left">8.3.10</td></tr><tr><td style="text-align:left">3.0 - 3.4</td><td style="text-align:left">8.3.11</td></tr><tr><td style="text-align:left">3.5 - 3.7</td><td style="text-align:left">8.3.13</td></tr></tbody></table><p><strong>注意:</strong>目前官网上面 8.0 – 8.3.x 已标注为<code>Deprecated</code>即不建议使用状态。</p><h2 id="drbd-状态记录"><a href="#drbd-状态记录" class="headerlink" title="drbd 状态记录"></a>drbd 状态记录</h2><p><a href=".">本部分内容详见此处</a></p><h2 id="清除单个-DRBD-资源配置：-以-drbd10-为例"><a href="#清除单个-DRBD-资源配置：-以-drbd10-为例" class="headerlink" title="清除单个 DRBD 资源配置：(以 drbd10 为例)"></a>清除单个 <code>DRBD</code> 资源配置：(以 drbd10 为例)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbd-overview       # drbd概览</span><br><span class="line">drbdadm down drbd10         #down drbd</span><br><span class="line">echo yes|drbdadm wipe-md drbd10     #清除metadata</span><br><span class="line">cd /etc/drbd.d/         # 注意，此处根据drbd版本不同也可能在/usr/local/etc/drbd.d/</span><br><span class="line">rm drbd10.res           #删除resource文件</span><br></pre></td></tr></table></figure><h2 id="重启-DRBD-服务"><a href="#重启-DRBD-服务" class="headerlink" title="重启 DRBD 服务"></a>重启 <code>DRBD</code> 服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service drbd stop </span><br><span class="line">service drbd start</span><br></pre></td></tr></table></figure><h2 id="DRBD扩容"><a href="#DRBD扩容" class="headerlink" title="DRBD扩容"></a><code>DRBD</code>扩容</h2><p>当遇到我们的<code>drbd resource</code>设备容量不够的时候，而且我们的底层设备支持在线增大容量的时候（比如 lvm），我们可以先增大底层设备的大小，然后再通过<code>drbdadm resize resource_name</code>来实现对<code>resource</code>的扩容。<br>这里有需要注意的是：<br>只有在单主模式下可以这样做，而且需要先在两节点上都增大底层设备的容量，然后仅在主节点上执行<code>resize</code>命令。</p><p>在执行了<code>resize</code>命令后，将自动触发一次当前主节点到其他所有从节点的 re-synchronization；</p><p>如果我们在<code>drbd</code>非工作状态下对底层设备进行了扩容，然后再启动<code>drbd</code>，将不需要执行<code>resize</code>命令（当然前提是在配置文件中没有对 disk 参数项指定大小），<code>drbd</code>自己会知道已经增大了容量；</p><p>在进行底层设备的增容操作的时候千万不要修改到原设备上面的数据，尤其是<code>drbd</code>的<code>meta</code>信息，否则有可能毁掉所有数据。</p><h3 id="流程简单示例"><a href="#流程简单示例" class="headerlink" title="流程简单示例"></a>流程简单示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先在两端扩展Lun（需要相同大小）     </span></span><br><span class="line">lvextend -Ll(50G) lvpath</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> drbd从端：（双主模式切换为主从模式）</span></span><br><span class="line">drbdadm secondary drbd[Num]     </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> drbd主端：</span></span><br><span class="line">drbdadm resize drbd[Num]</span><br></pre></td></tr></table></figure><h2 id="global-common-conf-配置（示例）"><a href="#global-common-conf-配置（示例）" class="headerlink" title="global_common.conf 配置（示例）"></a>global_common.conf 配置（示例）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">global &#123;</span><br><span class="line">    usage-count no;     # 是否向官方发送统计报告（影响性能）</span><br><span class="line">&#125;</span><br><span class="line">common &#123;            # 定义drbd设备共享的属性信息</span><br><span class="line">    handlers &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    startup &#123;       # 启动时候的相关设置</span><br><span class="line">        wfc-timeout 50;</span><br><span class="line">        become-primary-on both;     # 允许双主</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    disk &#123;</span><br><span class="line">        on-io-error detach;     # 配置I/O错误处理策略为分离</span><br><span class="line">        no-disk-flushes ;</span><br><span class="line">        no-disk-barrier;</span><br><span class="line">        c-plan-ahead 0;</span><br><span class="line">        c-fill-target 24M;</span><br><span class="line">        c-min-rate 80M;</span><br><span class="line">        c-max-rate 720M;</span><br><span class="line">    &#125; </span><br><span class="line">    net &#123;               # 网络配置相关</span><br><span class="line">        protocol C;     # 同步异步控制（见下方介绍）</span><br><span class="line">        after-sb-0pri discard-younger-primary;  # 脑裂修复</span><br><span class="line">        after-sb-1pri discard-secondary;</span><br><span class="line">        after-sb-2pri call-pri-lost-after-sb;</span><br><span class="line">        allow-two-primaries yes;        # 允许双主</span><br><span class="line">        max-buffers        36k;</span><br><span class="line">        sndbuf-size         1024k ;</span><br><span class="line">        rcvbuf-size      2048k;</span><br><span class="line">    &#125;</span><br><span class="line">    syncer &#123;    # 同步相关的设置</span><br><span class="line">            rate                   4194304k;    # bytes/second</span><br><span class="line">            al-extents              6433;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Read_More:http://tech.sina.com.cn/smb/2008-12-22/1050926302.shtml</span></span><br></pre></td></tr></table></figure><h3 id="数据同步协议"><a href="#数据同步协议" class="headerlink" title="数据同步协议"></a>数据同步协议</h3><p><code>DRBD</code>有三种数据同步模式:同步，异步，半同步</p><ol><li>异步：指的是当数据写到磁盘上，并且复制的数据已经被放到我们的<code>tcp</code>缓冲区并等待发送以后，就认为写入完成；</li><li>半同步：指的是数据已经写到磁盘上，并且这些数据已经发送到对方内存缓冲区，对方的<code>tcp</code>已经收到数据，并宣布写入；</li><li>同步：指的是主节点已写入，从节点磁盘也写入；</li></ol><p><code>DRBD</code>的复制模型是靠<code>protocol</code>关键字来定义的：<code>protocol A</code>表示异步；<code>protocol B</code>表示半同步；<code>protocol C</code>表示同步，默认为<code>protocol C</code>。</p><p>在同步模式下只有主、从节点上两块磁盘同时损害才会导致数据丢失。在半同步模式下只有主节点宕机，同时从节点异常停电才会导致数据丢失。</p><p><strong>注意:</strong></p><ol><li>主从所在的磁盘分区最好大小相等,<code>DRBD</code>磁盘镜像相当于网络<code>RAID1</code>；（本人使用时强制相等，但网上没有关于分区大小是否一定要相同的确切说法）</li><li>网络同步时需要一定的时间，在同步完成之前最好不要重启，否则会重新同步；</li><li><code>DRBD</code>的主节点不会监控从节点的状态，所以有可能会造成数据重传；</li><li>格式化只需要在<code>primary</code>节点上进行,且只能在主节点上挂载；若主节点下线,从节点上线,则从节点可以直接挂载,不需要再次格式化。集群中只有 primary 服务器可以挂载设备，secondary 挂载会报错。只有在进行故障迁移升级为主时才需要挂载。</li><li>如果<code>DRBD</code>状态下关机双控恢复不过来，尝试删除<code>DRBD</code>配置信息，然后停掉<code>DRBD</code>端 ODSP 和<code>mysql</code>重启之后即可；(此条仅针对公司项目)</li></ol><h2 id="单个drbd配置文件（以-drbd10-res-为例）"><a href="#单个drbd配置文件（以-drbd10-res-为例）" class="headerlink" title="单个drbd配置文件（以 drbd10.res 为例）"></a>单个<code>drbd</code>配置文件（以 drbd10.res 为例）</h2><h3 id="项目中的配置方案"><a href="#项目中的配置方案" class="headerlink" title="项目中的配置方案"></a>项目中的配置方案</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resource drbd11 &#123;</span><br><span class="line">    on controller-1 &#123;</span><br><span class="line">        device /dev/drbd11;</span><br><span class="line">        disk /dev/StorPool11/SANLun11;</span><br><span class="line">        address 192.168.2.10:57811;</span><br><span class="line">        meta-disk internal;</span><br><span class="line">    &#125;</span><br><span class="line">    on controller-2 &#123;</span><br><span class="line">        device /dev/drbd11;</span><br><span class="line">        disk /dev/StorPool11/SANLun11;</span><br><span class="line">        address 192.168.2.18:57811;</span><br><span class="line">        meta-disk internal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="另外一种配置方案"><a href="#另外一种配置方案" class="headerlink" title="另外一种配置方案"></a>另外一种配置方案</h3><p>来自<a href="https://www.suse.com/documentation/sle_ha/book_sleha/data/sec_ha_drbd_configure.html" target="_blank" rel="noopener">这里</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resource r0 &#123;   # ①</span><br><span class="line">  device /dev/drbd0; # ②</span><br><span class="line">  disk /dev/sda1;   # ③</span><br><span class="line">  meta-disk internal;   # ④</span><br><span class="line">  on alice &#123;    # ⑤</span><br><span class="line">    address  192.168.1.10:7788;     # ⑥</span><br><span class="line">  &#125;</span><br><span class="line">  on bob &#123; </span><br><span class="line">    address 192.168.1.11:7788; </span><br><span class="line">  &#125;</span><br><span class="line">  syncer &#123;</span><br><span class="line">    rate  7M;   # ⑦</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻译以看懂为目的：</p><p>1.允许某些系统服务项关联的名称，如：nfs, http, mysql_0, postgres_wal 等；<br>Name that allows some association to the service that needs them. For example, nfs, http, mysql_0, postgres_wal, etc.</p><p>2.<code>DRBD</code>设备名称及编号；<br>The device name for DRBD and its minor number.</p><p>在上面的例子中，<code>drbd</code>的编号是<code>0</code>。udev 集成脚本提供符号链接<code>/dev/drbd/by-res/nfs/0</code>。或者，也可以省略配置中的设备节点名称，然后使用下面这种形式代替：<br><code>drbd0 minor 0</code>（/dev/可选）或<code>/dev/drbd0</code>；</p><p>In the example above, the minor number 0 is used for DRBD. The udev integration scripts will give you a symbolic link /dev/drbd/by-res/nfs/0. Alternatively, omit the device node name in the configuration and use the following line instead:<br>drbd0 minor 0 (/dev/ is optional) or /dev/drbd0</p><p>3.节点之间进行复制的原始设备。注意：在本例中，两个节点上面的设备是相同的。若使用不同设备，请将磁盘参数移动到主机上。（？）</p><p>The raw device that is replicated between nodes. Note, in this example the devices are the same on both nodes. If you need different devices, move the disk parameter into the on host.</p><p>4.<code>meta-disk</code>参数通常包含隐式值，但是你也可以指定一个显式设备保存元数据。详情参见：<a href="http://www.drbd.org/users-guide-emb/ch-internals.html#s-metadata" target="_blank" rel="noopener">这里&gt;&gt;&gt;</a></p><p>The meta-disk parameter usually contains the value internal, but it is possible to specify an explicit device to hold the meta data. See <a href="http://www.drbd.org/users-guide-emb/ch-internals.html#s-metadata" target="_blank" rel="noopener">http://www.drbd.org/users-guide-emb/ch-internals.html#s-metadata</a> for more information.</p><p>5.<code>on</code>节配置指明改配置应用于具体哪个<code>host</code>。</p><p>The on section states which host this configuration statement applies to.</p><p>6.各节点的<code>IP</code>地址和端口号。每个资源需要一个单独的端口，通常以<code>7788</code>开始。</p><p>The IP address and port number of the respective node. Each resource needs an individual port, usually starting with 7788.</p><p>7.同步率。将其设置为磁盘读写和网络带宽的三分之一。仅限制重新同步，而不是复制。</p><p>The synchronization rate. Set it to one third of the lower of the disk- and network bandwidth. It only limits the resynchronization, not the replication.</p><h2 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h2><p>主备节点切换有两种方式，分别是停止<code>DRBD</code>服务切换和正常切换。</p><h3 id="正常切换"><a href="#正常切换" class="headerlink" title="正常切换"></a>正常切换</h3><p>主切换成从，需要先卸载文件系统，再执行降级为从的命令</p><h4 id="主端"><a href="#主端" class="headerlink" title="主端"></a>主端</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umount /data/</span><br><span class="line">drbdadm secondary all</span><br></pre></td></tr></table></figure><h4 id="从端"><a href="#从端" class="headerlink" title="从端"></a>从端</h4><p>从切换成主，要先执行升主的命令，然后挂载文件系统</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm  primary all</span><br><span class="line">mount /dev/drbd0 /data/</span><br></pre></td></tr></table></figure><h3 id="停止-drbd-服务切换"><a href="#停止-drbd-服务切换" class="headerlink" title="停止 drbd 服务切换"></a>停止 drbd 服务切换</h3><p>基本思路：关闭主节点服务，此时挂载的<code>DRBD</code>分区就自动在主节点卸载了，然后在备用节点执行切换命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@drbd2 ~]#drbdadm primary all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时报错：</span></span><br><span class="line">2: State change failed: (-7) Refusing to be Primary while peer is not outdated</span><br><span class="line">Command 'drbdsetup 2 primary' terminated with exit code 11</span><br><span class="line"><span class="meta">#</span><span class="bash"> 因此，必须在备用节点执行如下命令：</span></span><br><span class="line">[root@drbd2 ~]#drbdsetup /dev/drbd0 primary –o</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">[root@drbd2~]#drbdadm -- --overwrite-data-of-peer primary all</span><br></pre></td></tr></table></figure><p>当在备用节点执行切换到主节点命令后，原来的主用节点自动变为备用节点。无需在主用节点再次执行切换到备用节点的命令。</p><h2 id="脑裂修复"><a href="#脑裂修复" class="headerlink" title="脑裂修复"></a>脑裂修复</h2><p>当<code>DRBD</code>出现脑裂后，会导致<code>DRBD</code>两边的磁盘数据不一致，在确定要作为从的节点上切换成<code>secondary</code>，并放弃该资源的数据:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm secondary r0</span><br><span class="line">drbdadm -- --discard-my-data connect r0</span><br></pre></td></tr></table></figure><p>然后作为<code>primary</code>的节点重新连接<code>secondary</code>（如果这个节点当前的连接状态为<code>WFConnection</code>的话，可以省略），使用如下命令连接：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm connect r0</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="双控配置互信（假定在控-1-执行）"><a href="#双控配置互信（假定在控-1-执行）" class="headerlink" title="双控配置互信（假定在控 1 执行）"></a>双控配置互信（假定在控 1 执行）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo y|ssh-keygen -t dsa -f ~/.ssh/id_dsa -N ""</span><br><span class="line">cp ~/.ssh/id_dsa.pub ~/.ssh/authorized_keys</span><br><span class="line">scp -r ~/.ssh controller-2:         #双控对端hostname</span><br></pre></td></tr></table></figure><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><ul><li><p><a href="https://docs.linbit.com/docs/users-guide-8.4/" target="_blank" rel="noopener">官方手册</a></p></li><li><p><a href="https://www.suse.com/documentation/sle_ha/book_sleha/data/cha_ha_drbd.html" target="_blank" rel="noopener">SUSE 高可用配置</a></p></li><li><p><a href="http://clusterlabs.org/doc/en-US/Pacemaker/1.1/html/Clusters_from_Scratch/ch07.html" target="_blank" rel="noopener">使用 DRBD 实现复制存储</a></p></li><li><p><a href="http://www.cnblogs.com/wxl-dede/p/5114696.html" target="_blank" rel="noopener">drbd 配置 - Rikewang - 博客园</a></p></li><li><p><a href="http://www.3mu.me/centos%E4%B8%8B%E5%AE%9E%E7%8E%B0heartbeatdrbdmysql%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87%E7%A1%AC%E4%BB%B6%E6%95%85%E9%9A%9C%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E9%AB%98%E5%8F%AF%E7%94%A8ha/#respond" target="_blank" rel="noopener">CentOS 下实现 Heartbeat+DRBD+MySQL 双机热备硬件故障自动切换高可用(HA)方案 | 三木的人生——3mu.me</a></p></li><li><p><a href="https://www.ibm.com/developerworks/library/l-drbd/index.html" target="_blank" rel="noopener">High availability with the Distributed Replicated Block Device</a></p></li><li><p><a href="https://yq.aliyun.com/articles/52043" target="_blank" rel="noopener">记一次 DRBD Unknown 故障处理过程</a></p></li><li><p><a href="https://www.linuxidc.com/wap.aspx?nid=93422&amp;cid=9&amp;sp=654" target="_blank" rel="noopener">DRBD 管理、故障处理部分</a>(<a href="https://www.linuxidc.com/Linux/2013-12/93422.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2013-12/93422.htm</a>)</p></li><li><p><a href="http://blog.csdn.net/t1anyuan/article/details/52143789" target="_blank" rel="noopener">DRBD 编译安装中出现的问题及解决小结 - CSDN 博客</a></p></li><li><p><a href="https://www.linuxidc.com/Linux/2012-01/51661.htm" target="_blank" rel="noopener">DRBD 配置参数</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> 集群 </tag>
            
            <tag> DRBD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRBD 状态指标记录</title>
      <link href="/blog/2018-08-29/state-of-drbd/"/>
      <url>/blog/2018-08-29/state-of-drbd/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>在管理<code>DRBD</code>的时候，需要关注<code>drbd</code>相关的各种状态指标，本文主要记录相关的指令及显示含义。<br><a id="more"></a></p><h2 id="DRBD状态概览"><a href="#DRBD状态概览" class="headerlink" title="DRBD状态概览"></a><code>DRBD</code>状态概览</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbd-overview</span><br><span class="line">drbd status</span><br><span class="line">cat /proc/drbd      # 9.0废止在drbd9中，更多的是使用drbdadm或drbdsetup来获取节点的状态信息。</span><br></pre></td></tr></table></figure><p>以上命令略有不同，可自行对照</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Storage drbd]# pwd</span><br><span class="line">/usr/lib/drbd</span><br><span class="line">[root@Storage drbd]# ./drbd status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出示例</span></span><br><span class="line">drbd driver loaded OK; device status:</span><br><span class="line">version: 8.4.3 (api:1/proto:86-101)</span><br><span class="line">GIT-hash: 89a2942***221f964d3ee515 build by root@third, 2017-07-20 10:58:42</span><br><span class="line">m:res          cs            ro                 ds                 p       mounted       fstype</span><br><span class="line">0:drbd0        Connected     Primary/Secondary  UpToDate/UpToDate  C</span><br><span class="line">1:drbd1^^0     StandAlone    Primary/Unknown    UpToDate/DUnknown  r----s</span><br><span class="line">……</span><br><span class="line">6:drbd6        Connected     Primary/Secondary  UpToDate/UpToDate  C       /xxx  ext4</span><br></pre></td></tr></table></figure><p>缩写解释</p><ul><li>res：资源名称</li><li>cs：connect state,资源连接状态</li><li>ro：role，表示节点角色信息<br>第一次启动 drbd 时，两个 drbd 节点默认都处于 Secondary 状态，<br>Primary/Secondary（代表这个是主节点）<br>Secondary/Primary（代表这个是副节点）</li><li>ds：disk state,磁盘状态信息<br>Inconsistent/Inconsisten，即为“不一致/不一致”状态，表示两个节点的磁盘数据处于不一致状态。<br>UpToDate/Inconsistent（正在同步，数据还没有一致）<br>UpToDate/UpToDate （同步完成，数据一致）</li><li>C drbd 的复制协议，即 A、B、C 协议。</li><li>r—–是 IO 标记，反映的是该资源的 IO 状态信息。共有 6 种 IO 状态标记符号。</li></ul><h2 id="连接状态"><a href="#连接状态" class="headerlink" title="连接状态"></a>连接状态</h2><p>节点间通过 TCP 连接进行通信，在建立连接、断开连接、特殊情况下有很多种连接状态。</p><p>DRBD 连接建立完成，表示元数据区、数据区等一切都已准备好，可以进行任何数据同步的操作。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# drbdadm cstate drbd20</span><br><span class="line">Connected</span><br></pre></td></tr></table></figure></p><p>一个资源可能有以下连接状态中的一种</p><ul><li>Unconfigured：设备在等待配置</li><li><strong>WFConnection</strong>：当前节点正在等待对端节点出现。例如对方节点<code>drbdadm down</code>后，本节点将处于本状态。</li><li><strong>StandAlone</strong>：无连接。出现这种状态可能是因为：未连接过、使用<code>drbdadm disconnect</code>断开连接、节点由于身份验证的原因未成功加入 drbd 集群使得连接被删除、脑裂后断开连接。</li><li>Disconnecting：断开连接的一个临时过渡状态。它很快就会切入下一状态就是<code>StandAlone</code>。</li><li>Unconnected：尝试再次发起<code>TCP</code>连接时的一个临时连接状态(是连接超时后再次发送连接请求产生的状态)，它的下一个状态可能是<code>WFConnection</code>，也可能是<code>WFReportParams</code>。</li><li>Timeout：和对端通信超时时的临时状态。下一个状态就是<code>Unconnection</code>。</li><li>BrokenPipe：和对端连接丢失时的临时状态。下一个状态是<code>Unconnection</code>。</li><li>NetworkFailure：和对端连接丢失时的临时状态。下一个状态是<code>Unconnection</code>。(没错，和上面的一样)</li><li>ProtocolError：和对端连接丢失时的临时状态。下一个状态是<code>Unconnection</code>。(没错，还是和上面的一样)</li><li>TearDown：对端关闭 TCP 连接时的临时状态。下一个状态是<code>Unconnection</code>。</li><li><strong>Connected</strong>：DRBD 连接已经建立完成，数据镜像已经激活成功。这个状态是<code>drbd</code>正常运行时的状态。</li><li>WFReportParams：TCP 连接已经建立完成，该节点正在等待对端的第一个数据包。</li><li>StartingSyncS：全盘数据同步中。只有在初始化时才应该全盘同步。下一个状态是：<code>SyncSource</code>或<code>PauseSyncS</code>。</li><li>StartingSyncT：全盘数据同步中。只有在初始化时才应该全盘同步。下一个状态是：<code>WFSyncUUID</code>。</li><li>WFBitMapS：部分数据正在同步。下一个状态是：<code>SyncSource</code>或<code>PauseSyncS</code>。</li><li>WFBitMapT：部分数据正在同步。下一个状态是：<code>WFSyncUUID</code>。</li><li>WFSyncUUID：同步马上就要开始了。下一个状态：<code>SyncTarget</code>或<code>PauseSyncT</code>。</li><li><strong>SyncSource</strong>：正在同步，且本节点是数据同步的源端。</li><li><strong>SyncTartget</strong>：正在同步，且本节点是数据同步的目标端。</li><li>PauseSyncS：本节点是同步的源端节点，但同步过程当前被暂停。出现这种状态的原因可能是当前同步进程依赖于另一个同步进程完成，或者使用<code>drbdadm pause-sync</code>手动中断了同步操作。</li><li>PauseSyncT：本节点是同步的目标端，但同步过程当前被暂停。出现这种状态的原因可能是当前同步进程依赖于另一个同步进程完成，或者使用<code>drbdadm pause-sync</code>手动中断了同步操作。</li><li>VerifyS：正在进行在线设备验证，且本节点将成为验证的源端。</li><li>VerifyT：正在进行在线设备验证，且本节点将成为验证的目标端。</li></ul><p>在 drbd9 中，<code>WFConnection</code>状态改为<code>connecting</code>状态。删除了<code>WFReportParams</code>状态。添加了以下几个同步相关的状态：</p><ul><li>Off：该卷组还未同步，因为连接未建立。</li><li><strong>Established</strong>：所有对该卷组的写操作已经在线完成同步。这是<code>drbd</code>正常运行时的状态。</li><li>Ahead：数据同步操作被挂起，因为网络套接字中达到了一定的堵塞程度，无法应付更多的负载。该状态需要配置<code>on-congestion</code>选项来启用。</li><li>Behind：对端将数据同步操作挂起，因为网络套接字中达到了一定的堵塞程度，无法应付更多的负载。该状态需要在对端节点上配置<code>on-congestion</code>选项来启用。</li></ul><h2 id="角色状态"><a href="#角色状态" class="headerlink" title="角色状态"></a>角色状态</h2><p>资源的角色状态既可以从/proc/drbd 文件中获取，也可以使用下面的命令来获取。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@drbd1 ~]# drbdadm role data1</span><br><span class="line">Primary/Unknown</span><br></pre></td></tr></table></figure></p><p>在角色状态信息中，本地节点总是标记在第一位，远程节点标记在结尾。</p><p>可能的节点角色状态有：</p><ul><li>Primary：资源的 primary 角色，该角色状态下的 drbd 设备可以进行挂载、读、写等。在没有启用多主复制模型(dual-primary mode)，只能有一个 primary 节点。</li><li>Secondary：资源的 secondary 角色。该角色状态下的 drbd 设备会接收来自 primary 端的数据更新(除非和对端不是 primary)。且该角色的 drbd 设备不可挂载、不可读、不可写。</li><li>Unknown：资源的角色未知。本地节点的角色状态绝对不可能会是这种状态。只有对端节点断开连接时对端节点才处于 Unknown 状态。</li></ul><h2 id="硬盘状态"><a href="#硬盘状态" class="headerlink" title="硬盘状态"></a>硬盘状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# drbdadm dstate drbd20</span><br><span class="line">UpToDate/UpToDate</span><br></pre></td></tr></table></figure><p>在磁盘状态信息中，本地节点的磁盘状态总是标记在第一位，远程节点标记在结尾。本地和对等节点的硬盘有可能为下列状态之一：</p><ul><li>Diskless 无盘：本地没有块设备分配给<code>DRBD</code>使用，这意味着资源可能从没有和它的底层块设备进行关联绑定(attach)，也可能是手动 detach 解除了关联，还可能是出现了底层 I/O 错误时自动分离（detach）。</li><li>Attaching：读取无数据时候的瞬间状态</li><li>Failed：失败，本地块设备报告<code>I/O</code>错误的下一个状态，其下一个状态为<code>Diskless</code>无盘</li><li>Negotiating：在已经连接的 DRBD 设置进行<code>Attach</code>读取无数据前的瞬间状态</li><li>Inconsistent：数据不一致，在两个节点上（初始的完全同步前）这种状态出现后立即创建一个新的资源。此外，在同步期间（同步目标端）正接收同步数据时，也会进入不一致状态。</li><li>Outdated：数据资源是一致的，但是已经过时。(例如，已经同步后 secondary 下线了，之后又上线了，在还没开始重新同步的时候就是 Outdated 状态)</li><li>DUnknown：当对等节点网络连接不可用时出现这种状态</li><li>Consistent：连接断开时的数据处于一致性状态，当连接建立后，将决定数据是<code>UpToDate</code>还是<code>Outdated</code>状态</li><li>UpToDate：一致的、最新的数据状态，这个状态为正常状态</li></ul><h2 id="IO-状态标记"><a href="#IO-状态标记" class="headerlink" title="IO 状态标记"></a>IO 状态标记</h2><p>IO 状态标记表示的是当前资源的 IO 操作状态。共有 6 种状态：</p><ul><li>IO 挂起：r 或 s 都可能表示 IO 挂起，一般是 r。r=running，s=suspended。</li><li>串行重新同步：资源正在等待进行重新同步，但被 resync-after 选项延迟了同步进度。该状态标记为”a”，通常该状态栏应该处于”-“。</li><li>对端初始化同步挂起：资源正在等待进行重新同步，但对端节点因为某些原因而 IO 挂起。该状态标记为”p”，通常该状态栏应该处于”-“。</li><li>本地初始化同步挂起：资源正在等待进行重新同步，但本节点因为某些原因而 IO 挂起。该状态标记为”u”，通常该状态栏应该处于”-“。</li><li>本地 IO 阻塞：通常该状态栏应该处于”-“。可能有以下几种标记：<ul><li>d：因为 DRBD 内部原因导致的 IO 阻塞。</li><li>b：后端设备正处于 IO 阻塞。</li><li>n：网络套接字阻塞。</li><li>a：网络套接字和后端块设备同时处于阻塞状态。</li></ul></li><li>Activity Log 更新挂起：当 al 更新被挂起时，处于该状态，标记为”s”，通常该状态栏应该处于”-“。(如果不知道什么是 Active Log，请无视本标记)</li></ul><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p>习惯上，我们使用<code>cat /proc/drbd</code>获取<code>drbd</code>状态信息。主要是一些计数器和计量器的值。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Storage ~]# cat /proc/drbd </span><br><span class="line">version: 8.4.3 (api:1/proto:86-101)</span><br><span class="line">srcversion: 9D811F04CD6DC2C9A9A608F </span><br><span class="line"></span><br><span class="line"> 3: cs:Connected ro:Secondary/Secondary ds:UpToDate/UpToDate C r-----</span><br><span class="line">    ns:0 nr:0 dw:0 dr:0 al:0 bm:0 lo:0 pe:0 ua:0 ap:0 ep:1 wo:f oos:0</span><br><span class="line"></span><br><span class="line">301: cs:Connected ro:Secondary/Secondary ds:UpToDate/UpToDate C r-----</span><br><span class="line">    ns:0 nr:0 dw:0 dr:0 al:0 bm:0 lo:0 pe:0 ua:0 ap:0 ep:1 wo:f oos:0</span><br></pre></td></tr></table></figure></p><p>drbd84 中使用缩写符号来标记性能指标，而 drbd9 中使用全称来表示。例如 drbd84 中的 ns 和 drbd9 中的 send 是同一个意思。</p><ul><li>ns/send (network send)：通过网络连接发送给对端的数据量，单位为 Kb。</li><li>nr/receive (network receive)：通过网络连接接收到对端发送来的数据量，单位为 Kb。</li><li>dw/written (disk write)：该卷(volume)写入本地磁盘的数据量，单位为 Kb。</li><li>dr/read (disk read)：该卷(volume)从本地磁盘读取的数据量，单位为 Kb。</li><li>al/al-writes (activity log)：元数据区中 al 更新的次数。</li><li>bm/bm-writes (bit map)：元数据区中 bitmap 更新的次数。</li><li>lo/lower-pending (local count)：DRBD 发起的打开本地 IO 子系统的请求次数。</li><li>pe/pending (pending)：本地发送给对端但却没有回复的次数。</li><li>ua/unacked (unacknowledged)：接收到对端发送的请求但却没有给予回复的请求数量。</li><li>ap/upper-pending (application pending)：转发给 DRBD 的 IO 块的请求，但 DRBD 还没给予回复的请求数量。</li><li>ep (epochs):epoch 对象的数量。通常为 1。drbd9 中没有该指标。</li><li>wo/write-ordering (write order):当前正在使用的 write order 方法：b(barrier), f(flush), d(drain)或 n(none)。</li><li>oos/out-of-sync (out of sync):当前不同步的数据量，单位为 Kb。</li></ul><p>上面所有”未给予回复”的指标数量都表示动作还未完成，需要回复后才表示操作完成。这些未回复数值不能太大。</p><p>此外，drbd9 中添加了以下几个指标：</p><ul><li>resync-suspended：重新同步操作当前是否被挂起。可能的值为 no/user/peer/dependency。</li><li>blocked：本地 IO 的拥挤情况。<ul><li>no：本地 IO 不拥挤。</li><li>upper：DRBD 层之上的 IO 被阻塞。例如到文件系统上的 IO 阻塞。可能有以下几种原因：<ul><li>管理员使用 drbdadm suspend-io 命令挂起了 I/O 操作。</li><li>短暂的 IO 阻塞，例如 attach/detach 导致的。</li><li>删除了缓冲区。</li><li>bitmap 的 IO 等待。</li></ul></li><li>lower：底层设备处于拥挤状态。</li></ul></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cnblogs.com/f-ck-need-u/p/8684648.html" target="_blank" rel="noopener">drbd(三)：drbd 的状态说明 - 骏马金龙 - 博客园</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DRBD </tag>
            
            <tag> Linux </tag>
            
            <tag> 高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 DRBD 使用外部元数据</title>
      <link href="/blog/2018-08-28/drbd-with-external-disk/"/>
      <url>/blog/2018-08-28/drbd-with-external-disk/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>裂脑一旦发生，需要及时排查问题所在，最大限度保护数据完整性。mathjax<br><a id="more"></a></p><h2 id="meta-data存放位置优缺点比较"><a href="#meta-data存放位置优缺点比较" class="headerlink" title="meta data存放位置优缺点比较"></a><code>meta data</code>存放位置优缺点比较</h2><h3 id="internal-meta-data"><a href="#internal-meta-data" class="headerlink" title="internal meta-data"></a>internal meta-data</h3><p>meta-data 和数据存放在同一个底层设备之上，它通过在设备末端预留一个区域以存储元数据做到这一点。</p><ul><li>优点：</li></ul><p>一旦 meta-data 创建之后，就和实际数据绑在了一起，在维护上会更简单方便，不用担心 meta-data 会因为某些操作而丢失。另外在硬盘损坏丢失数据的同时，meta-data 也跟着一起丢失，当更换硬盘之后，只需要执行重建 meta-data 的命令即可，丢失的数据会很容易的从其他节点同步过来。</p><ul><li>缺点：</li></ul><p>如果底层设备是单一的磁盘，没有做 raid，也不是 lvm 等，那么可能会对写入吞吐量产生负面影响。因为每一次写 io 都需要更新 meta-data 里面的信息，那么每次写 io 都会有两次，而且肯定会有磁头的较大寻道移动，因为 meta-data 都是记录在设备的最末端的，这样就会造成写 io 的性能降低。</p><h3 id="external-meta-data"><a href="#external-meta-data" class="headerlink" title="external meta data"></a>external meta data</h3><p><code>meta-data</code>存放在独立的，与存放数据的设备分开的设备之上。</p><ul><li>优点：</li></ul><p>与 internal meta-data 的缺点完全相对。对于某些写操作, 使用外部元数据会稍微改进延迟行为。</p><ul><li>缺点：</li></ul><p>由于 meta-data 存放在与数据设备分开的地方，就意味着如果磁盘故障且仅破坏生产数据 (而不是 DRBD 元数据), 则可以通过手动干预, 以使发起从幸存的节点到后续更换的磁盘上的完整数据同步。也就是管理维护会稍微麻烦一点，很小的一点点。</p><p><strong>注意：</strong> 如果我们希望在已经存在数据的设备上面建立 drbd 的资源，并且不希望丢失该设备上面的数据，又没办法增大底层设备的容量，而且上层文件系统不支持收缩，我们就只能将 meta data 创建成 external 方式。</p><h2 id="估算元数据大小"><a href="#估算元数据大小" class="headerlink" title="估算元数据大小"></a>估算元数据大小</h2><p>注意：如果公式渲染出错，可以去<a href="https://zohooo.github.io/jaxedit/" target="_blank" rel="noopener">这里</a>预览</p><p>你可以使用以下公式计算 DRBD 元数据的精确空间要求:</p><p><img src="https://docs.linbit.com/ug-src/users-guide-8.4/images/metadata-size-exact.png" alt="精确计算元数据大小"></p><p>$$M<em>{S}= \lceil\frac{C</em>{s}}{2^{18}} \rceil \ast 8 \ast N + 72$$</p><p>Cs 是存储设备扇区大小。N 是对端的数量，一般情况下 drbd 实现的是双节点，因此 N=1，可以不用考虑。</p><p>您可以通过发出 blockdev –getsz <device>来检索设备大小。</device></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Storage ~]# blockdev --getsz /dev/StorPool1/SANLun2</span><br><span class="line">2097152</span><br></pre></td></tr></table></figure><p>结果中的 Ms 的大小也是用扇区表示的,要转换为 MB, 请除以 2048。(对于 512 字节的扇区大小, 这是除 s390 之外的所有 Linux 平台上的默认值)。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: (math.ceil(<span class="number">2097152</span>/<span class="number">2</span>**<span class="number">18</span>)*<span class="number">8</span>+<span class="number">72</span>)/float(<span class="number">2048</span>)</span><br><span class="line">Out[<span class="number">23</span>]: <span class="number">0.06640625</span></span><br></pre></td></tr></table></figure></p><p>在实践中, 你可以使用一个合理的好的近似, 下面给出。请注意, 在此公式中, 单位为兆字节(megabytes), 而非扇区:</p><p><img src="https://docs.linbit.com/ug-src/users-guide-8.4/images/metadata-size-approx.png" alt="预估计算元数据大小"></p><p>$$M<em>{MB} \lt \frac{C</em>{MB}}{32768} \ast N + 1$$</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取块设备大小</span></span><br><span class="line">[root@Storage ~]# lsblk /dev/StorPool1/SANLun2</span><br><span class="line">NAME              MAJ:MIN RM SIZE RO TYPE MOUNTPOINT</span><br><span class="line">StorPool1-SANLun2 253:3    0   1G  0 lvm</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预估元数据设备大小</span></span><br><span class="line">In [<span class="number">30</span>]: <span class="number">1024</span>/float(<span class="number">32768</span>)+<span class="number">1</span></span><br><span class="line">Out[<span class="number">30</span>]: <span class="number">1.03125</span></span><br></pre></td></tr></table></figure><p>此处插播一个小的知识点,来源参考<a href="https://blog.csdn.net/starshine/article/details/8226320" target="_blank" rel="noopener">这里</a>（解释）和<a href="http://www.maixj.net/ict/kbkib-mbmib-gbgib-15095" target="_blank" rel="noopener">这里</a>（区别）。</p><table><thead><tr><th style="text-align:left">名字</th><th style="text-align:left">缩写</th><th style="text-align:left">次方</th><th style="text-align:left">名字</th><th style="text-align:left">缩写</th><th style="text-align:left">次方</th></tr></thead><tbody><tr><td style="text-align:left">kilobyte</td><td style="text-align:left">KB</td><td style="text-align:left">10^3</td><td style="text-align:left">kibibyte</td><td style="text-align:left">KiB</td><td style="text-align:left">2^10</td></tr><tr><td style="text-align:left">megabyte</td><td style="text-align:left">MB</td><td style="text-align:left">10^6</td><td style="text-align:left">mebibyte</td><td style="text-align:left">MiB</td><td style="text-align:left">2^20</td></tr><tr><td style="text-align:left">gigabyte</td><td style="text-align:left">GB</td><td style="text-align:left">10^9</td><td style="text-align:left">gibibyte</td><td style="text-align:left">GiB</td><td style="text-align:left">2^30</td></tr><tr><td style="text-align:left">terabyte</td><td style="text-align:left">TB</td><td style="text-align:left">10^12</td><td style="text-align:left">tebibyte</td><td style="text-align:left">TiB</td><td style="text-align:left">2^40</td></tr><tr><td style="text-align:left">petabyte</td><td style="text-align:left">PB</td><td style="text-align:left">10^15</td><td style="text-align:left">pebibyte</td><td style="text-align:left">PiB</td><td style="text-align:left">2^50</td></tr><tr><td style="text-align:left">exabyte</td><td style="text-align:left">EB</td><td style="text-align:left">10^18</td><td style="text-align:left">exbibyte</td><td style="text-align:left">EiB</td><td style="text-align:left">2^60</td></tr><tr><td style="text-align:left">zettabyte</td><td style="text-align:left">ZB</td><td style="text-align:left">10^21</td><td style="text-align:left">zebibyte</td><td style="text-align:left">ZiB</td><td style="text-align:left">2^70</td></tr><tr><td style="text-align:left">yottabyte</td><td style="text-align:left">YB</td><td style="text-align:left">10^24</td><td style="text-align:left">yobibyte</td><td style="text-align:left">YiB</td><td style="text-align:left">2^80</td></tr></tbody></table><h2 id="重置资源的大小"><a href="#重置资源的大小" class="headerlink" title="重置资源的大小"></a>重置资源的大小</h2><h3 id="在线增加"><a href="#在线增加" class="headerlink" title="在线增加"></a>在线增加</h3><p>需要满足两个条件：</p><ol><li><p>支持设备必须是逻辑卷</p></li><li><p>当前的资源必须处于<code>connected</code>的连接状态。</p></li></ol><p>在两个节点给设备增加大小后，再确认只有一个节点处于<code>primary</code>状态。然后输入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm resize &lt;resource&gt;</span><br></pre></td></tr></table></figure><p>此命令会触发新扇区的同步，完成主节点到备用节点间的同步。</p><p>如果你添加的空间是干净没有数据的，你可以使用<code>--assume-clean</code>选项：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm -- --assume-clean resize &lt;resource&gt;</span><br></pre></td></tr></table></figure><p>来跳过额外的空间同步。</p><h3 id="离线增加"><a href="#离线增加" class="headerlink" title="离线增加"></a>离线增加</h3><p>（此为高级功能，请自审之后使用。）</p><ol><li>资源被配置为 external meta data 时</li></ol><p>当 DRBD 在处于非活动情况下，在两个节点的支持设备被扩展时，且 DRBD 资源使用的是 external meta data，那么新的大小会自动被识别，不需要管理员干预。DRBD 设备将在下次两个节点活动并且成功建立网络连接之后，显示增加后的新容量。</p><ol><li>资源被配置为 internal meta data 时</li></ol><p>当 DRBD 资源被配置为使用 internal meta data 时，在新大小变为可用之前, 则必须将此元数据移动到已扩容设备的末尾。为此, 请完成以下步骤:</p><ul><li>down 掉 DRBD 资源:</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm down &lt;resource&gt;</span><br></pre></td></tr></table></figure><ul><li>在收缩之前将元数据保存在文本文件中</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm dump-md &lt;resource&gt; &gt; /tmp/metadata</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 以上步骤必须在两个节点上分别运行。不能在一个节点上保存了元数据然后在拷贝到另外一个节点上。否则就无法正常工作。</p><ul><li><p>在两个节点上给支持的块设备增加容量</p></li><li><p>分别在两个节点上调整/tmp/metadata 文件中<code>la-size-sect</code>的大小信息。注：这里 la-size-sect 指定的是扇区数量</p></li><li><p>重新初始化元数据区域</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm create-md &lt;resource&gt;</span><br></pre></td></tr></table></figure><ul><li>分别在两个节点上重新导入修正的元数据</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 此处使用bash脚本，需要确认可用性</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> drbdmeta_cmd=$(drbdadm -d dump-md &lt;resource&gt;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$&#123;drbdmeta_cmd/dump-md/restore-md&#125;</span> /tmp/metadata</span></span><br><span class="line">Valid meta-data in place, overwrite? [need to type 'yes' to confirm]</span><br><span class="line">yes</span><br><span class="line">Successfully restored meta data</span><br></pre></td></tr></table></figure><ul><li>重新启用 DRBD 资源</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm up &lt;resource&gt;</span><br></pre></td></tr></table></figure><ul><li>在一个节点上，设置 DRBD 为 primary</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm primary &lt;resource&gt;</span><br></pre></td></tr></table></figure><p>至此，已完成 DRBD 设备大小的扩容。</p><h3 id="在线缩小容量"><a href="#在线缩小容量" class="headerlink" title="在线缩小容量"></a>在线缩小容量</h3><p>注：在线缩小容量，仅支持<code>external metadata</code></p><p>在缩小 DRBD 设备时必须首先缩小 DRBD 的上层块设备。例如文件系统。由于 DRBD 无法获知文件系统到底使用了多少空间，所以在缩小文件系统时需要格外小心防止数据丢失！文件系统是否可以被缩小取决于所使用的文件系统。大多数文件系统不支持在线缩减。XFS 也不支持在线缩减。</p><p>因此，在缩小文件系统后，可以使用以下命令在线缩小 DRBD 设备容量。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm resize --size=&lt;new-size&gt;  &lt;resource&gt;</span><br></pre></td></tr></table></figure><h3 id="离线收缩容量"><a href="#离线收缩容量" class="headerlink" title="离线收缩容量"></a>离线收缩容量</h3><p>（此为高级功能，请自审之后使用。）</p><p>如果在 DRBD 处于非活动状态时收缩后备块设备, DRBD 将拒绝在下次尝试<code>attach</code>期间<code>attach</code>到此块设备, 因为它现在太小 (external meta-data), 或者它将无法找到其元数据 (internal meta-data)。要变通解决这些问题, 请使用此过程 (如果不能使用上面的在线收缩):</p><ul><li><p>在 DRBD 还处于配置运行状态时，在一个节点上缩小文件系统</p></li><li><p>down 掉 DRBD 资源</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm down &lt;resource&gt;</span><br></pre></td></tr></table></figure><ul><li>在缩小前保存元数据到一个文件中：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm dump-md &lt;resource&gt; &gt; /tmp/metadata</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 以上步骤必须在两个节点上分别运行。不能在一个节点上保存了元数据然后在拷贝到另外一个节点上。否则就无法正常工作。</p><ul><li><p>在两个节点上给支持的块设备缩小容量</p></li><li><p>分别在两个节点上调整/tmp/metadata 文件中<code>la-size-sect</code>的大小信息。注：这里 la-size-sect 指定的是扇区数量</p></li><li><p>重新初始化元数据区域</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm create-md &lt;resource&gt;</span><br></pre></td></tr></table></figure><ul><li>分别在两个节点上重新导入修正的元数据</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 此处使用bash脚本，需要确认可用性</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> drbdmeta_cmd=$(drbdadm -d dump-md &lt;resource&gt;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$&#123;drbdmeta_cmd/dump-md/restore-md&#125;</span> /tmp/metadata</span></span><br><span class="line">Valid meta-data in place, overwrite? [need to type 'yes' to confirm]</span><br><span class="line">yes</span><br><span class="line">Successfully restored meta data</span><br></pre></td></tr></table></figure><ul><li>重新启用 DRBD 资源</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm up &lt;resource&gt;</span><br></pre></td></tr></table></figure><h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><h3 id="查看元数据"><a href="#查看元数据" class="headerlink" title="查看元数据"></a>查看元数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> down 掉drbd</span></span><br><span class="line">[root@Storage ~]# drbdadm down drbds2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看元数据出错</span></span><br><span class="line">[root@Storage ~]# drbdadm dump-md drbds2</span><br><span class="line">Found meta data is "unclean", please apply-al first</span><br><span class="line">Command 'drbdmeta 2 v08 /dev/StorPool1/SANLun2 internal dump-md' terminated with exit code 255</span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂时不明白这句操作的含义，待查</span></span><br><span class="line">[root@Storage ~]# drbdadm apply-al drbds2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看meata-data</span></span><br><span class="line">[root@Storage ~]# drbdadm dump-md drbds2</span><br><span class="line"><span class="meta">#</span><span class="bash"> DRBD meta data dump</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2018-08-29 01:48:20 +0800 [1535478500]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Storage&gt; drbdmeta 2 v08 /dev/StorPool1/SANLun2 internal dump-md</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"></span><br><span class="line">version "v08";</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> md_size_sect 136</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> md_offset 1073737728</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> al_offset 1073704960</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bm_offset 1073672192</span></span><br><span class="line"></span><br><span class="line">uuid &#123;</span><br><span class="line">    0xDDB03F0DAF07DEDC; 0x0000000000000000; 0xE4689A94FBB0E78B; 0xE4679A94FBB0E78B;</span><br><span class="line">    flags 0x00000000;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> al-extents 1237;</span></span><br><span class="line">la-size-sect 2097016;</span><br><span class="line">bm-byte-per-bit 4096;</span><br><span class="line">device-uuid 0x625F486D2CB120D1;</span><br><span class="line">la-peer-max-bio-size 1048576;</span><br><span class="line">al-stripes 1;</span><br><span class="line">al-stripe-size-4k 8;</span><br><span class="line"><span class="meta">#</span><span class="bash"> bm-bytes 32768;</span></span><br><span class="line">bm &#123;</span><br><span class="line"><span class="meta">   #</span><span class="bash"> at 0kB</span></span><br><span class="line">    4096 times 0x0000000000000000;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> bits-set 0;</span></span><br></pre></td></tr></table></figure><p>从此命令中可以获知不同标记代数的 uuid 值，以及 metadata 的元数据信息，例如 md_size_sect=1951744 表示元数据所在分区占用了 1951744 个扇区。注意，该命令不要在 drbd 设备已启动的情况下执行。</p><p>知道这两个命令可以获取一些信息后，现在我们要做的是计算 metadata 部分的数据大小。这个大小在”修改 drbd 设备空间大小”时有用。</p><p>首先获取元数据所在分区的扇区数。即上面结果中的”md_size_sect”。不过也可以使用块设备工具 blockdev 来获取。</p><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><ul><li><a href="https://docs.linbit.com/docs/users-guide-8.4/#s-metadata" target="_blank" rel="noopener">16.1. DRBD meta data</a></li><li><a href="https://www.wenzizone.cn/2009/10/29/drbd%E4%B8%ADmetadata%E7%9A%84%E7%90%86%E8%A7%A3%E5%8E%9F%E5%88%9B.html" target="_blank" rel="noopener">原创 | drbd 中 metadata 的理解</a></li><li><a href="https://blog.csdn.net/yuanhangq220/article/details/46634249" target="_blank" rel="noopener">drbd 配置简述</a></li><li><a href="http://www.cnblogs.com/f-ck-need-u/p/8678883.html" target="_blank" rel="noopener">drbd(二)：配置和使用 - 骏马金龙 - 博客园</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> DRBD </tag>
            
            <tag> meta-data </tag>
            
            <tag> 元数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRBD 用户手册之命令篇</title>
      <link href="/blog/2018-06-22/commonds-of-drbd/"/>
      <url>/blog/2018-06-22/commonds-of-drbd/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文基于<code>DRBD-8.4</code>版编写。<br><a id="more"></a></p><h1 id="drbd-conf-配置文件"><a href="#drbd-conf-配置文件" class="headerlink" title="drbd.conf-配置文件"></a>drbd.conf-配置文件</h1><p>TODO</p><h1 id="drbdmeata-元数据"><a href="#drbdmeata-元数据" class="headerlink" title="drbdmeata-元数据"></a>drbdmeata-元数据</h1><p>TODO</p><h1 id="drbd"><a href="#drbd" class="headerlink" title="drbd"></a>drbd</h1><p>TODO</p><h1 id="drbdadm-管理工具"><a href="#drbdadm-管理工具" class="headerlink" title="drbdadm-管理工具"></a>drbdadm-管理工具</h1><h2 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h2><p>drbdadm - <code>DRBD</code>管理工具</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drbdadm [-d] [-c &#123; file&#125;] [-t &#123;file&#125;] [-s &#123;cmd&#125;] [-m &#123; cmd&#125;] [-S] [-h &#123;host&#125;] [-- &#123; backend-options&#125;] &#123;command&#125; [&#123;all&#125; | &#123; resource[/volume&gt;]...&#125;]</span><br></pre></td></tr></table></figure><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>Drbdadm</code>是<code>DRBD</code>程序套件的高级工具。 <code>Drbdadm</code>与<code>drbdsetup</code>和<code>drbdmeta</code>的关系可类比于 <code>ifup / ifdown</code>与<code>ifconfig</code> 。 <code>Drbdadm</code>通过调用<code>drbdsetup</code>和（或）<code>drbdmeta</code>程序读取相关配置文件并执行指定的命令。<br><code>Drbdadm</code>可以运行整个资源或资源中的单个卷。 子命令： <code>attach</code> ， <code>detach</code> ， <code>primary</code> ， <code>secondary</code>， <code>invalidate</code> ， <code>invalidate-remote</code> ， <code>outdate</code> ， <code>resize</code> ， <code>verify</code> ， <code>pause-sync</code> ， <code>resume-sync</code> ， <code>role</code> ， <code>cstate</code> ， <code>dstate</code> ， <code>create-md</code> ， <code>show-gi</code> ， <code>get-gi</code> ， <code>dump-md</code> ， <code>wipe-md</code>可以作用于整个资源和单个卷上。<br>仅限资源级别的命令有：<code>connect</code>, <code>disconnect</code>, <code>up</code>, <code>down</code>, <code>wait-connect</code> 和 <code>dump</code> 。</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul><li>-d ，– dry-run</li></ul><p>仅将<code>drbdsetup</code>的调用打印到<code>stdout</code>，但不会运行这些命令。</p><ul><li>-c ，– config-file 文件</li></ul><p>指定<code>drbdadm</code>将使用的配置文件。 如果未指定此参数，则<code>drbdadm</code>将查找<code>/etc/drbd-84.conf</code>、<code>/etc/drbd-83.conf</code>、<code>/etc/drbd-08.conf</code>和<code>/etc/drbd.conf</code> 。</p><ul><li>-t ，– config-to-test 文件</li></ul><p>指定一个额外的<code>drbdadm</code>检查文件。 该选项仅适用于<code>dump</code>和<code>sh-nop</code>命令。</p><ul><li>-s ，– drbdsetup 文件</li></ul><p>指定<code>drbdsetup</code>程序的完整路径。 如果省略此选项，<code>drbdadm</code>将首先内部查找它，然后在<code>PATH</code>环境变量中查找它。</p><ul><li>-m ，– drbdmeta 文件</li></ul><p>指定<code>drbdmeta</code>程序的完整路径。 如果省略此选项，<code>drbdadm</code>将首先内部查找它，然后在<code>PATH</code>中查找它。</p><ul><li>-S ， –stacked</li></ul><p>指定应该在堆叠资源上执行此命令。</p><ul><li>-P ， –peer</li></ul><p>指定要连接的对等节点。 只有当您正在使用的资源中有两个以上的主机时才需要此选项。</p><ul><li>后端配置选项</li></ul><p>双连字符（–）后面的所有选项都被视为后端选项。这些选项会传递给后端命令。 即<code>drbdsetup</code>、<code>drbdmeta</code>或<code>drbd-proxy-ctl</code> 。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul><li>attach</li></ul><p>将本地支持块设备连接到 DRBD 资源的设备。</p><ul><li>detach</li></ul><p>从 DRBD 资源的设备中删除备份存储设备。</p><ul><li>connect</li></ul><p>建立资源设备的网络配置。 如果对等设备已配置，则两个<code>DRBD</code>设备将连接。 如果资源中有两个以上的主机部分，则需要使用<code>--peer</code>选项来选择要连接的对等端。</p><ul><li>disconnect</li></ul><p>从资源中删除网络配置。 设备将进入<code>StandAlone</code>状态。</p><ul><li>syncer（注：<code>drbdadm --help</code> 未发现该命令）</li></ul><p>将重新同步参数加载到设备中。</p><ul><li>up</li></ul><p>是<code>attach</code>、<code>syncer</code>和 <code>connect</code>的快捷方式。</p><p>实际上，可以将<code>drbdadm up</code>拆分为以下几个动作：</p><ol><li><p>将 drbd 的资源关联到底层设备(metadata 和 data 区)上，使之能通过底层设备存、取数据。该过程调用的是 drbdsetup 程序。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drbdadm attach drbd1</span><br></pre></td></tr></table></figure></li><li><p>加载 drbd 资源的同步参数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drbdadm syncer drbd1</span><br></pre></td></tr></table></figure></li><li><p>连接对端。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drbdadm connect drbd1</span><br></pre></td></tr></table></figure></li></ol><p>这些命令在<code>drbdadm</code>中部分已弃用，放在这里只是为了说明<code>up</code>时所执行的几个步骤。</p><ul><li>down</li></ul><p>是<code>disconnect</code> 和 <code>detach</code>的捷径。</p><ul><li>primary</li></ul><p>将资源设备转化为主要角色。 您需要在访问设备之前执行此操作，如创建或挂载文件系统。</p><ul><li>secondary</li></ul><p>将设备转回次要角色。 这是必需的，因为在连接状态的 DRBD 设备对中，两个节点中只能有一个节点是主端（除非在配置文件中明确设置了<strong>allow-two-primaries</strong> ）。</p><ul><li>invalidate</li></ul><p>强制 DRBD 将本地存储设备上的数据视为不同步（out-of-sync）。 因此，DRBD 将复制其对等体中的每个块，以使本地存储设备重新同步。 为避免竞争，你需要建立了的复制链接，或断开连接的次端。</p><ul><li>invalidate-remote</li></ul><p>该命令类似于<code>invalidate</code>命令，但是是对等端的备份存储被视为无效，因此对端被本地节点的数据重写。 为避免竞争，您需要已建立的复制链接，或断开连接的主端。</p><ul><li>resize</li></ul><p><code>DRBD</code>重新检查所有大小限制，并相应调整资源的设备大小。 例如，如果您增加了备份存储设备的大小（当然是在两个节点上均进行次操作），那么在您的某个节点上调用此命令后，DRBD 将采用新的大小。 由于必须同步新的存储空间，因此只有存在至少一个主节点时，此命令才可用。<br><code>--size</code>选项可用于联机缩小<code>drbd</code>设备的可用大小。 用户必须负责确保设备上的文件系统不被该操作截断。<br><code>--assume-peer-have-space</code>允许你调整当前未连接到对等设备的设备。 使用时需要小心，因为如果您不重新调整对等磁盘的大小，则两者的进一步连接尝试将失败。<br><code>--assume-clean</code>允许您调整现有设备的大小并避免同步新的空间。 将附加空白存储添加到设备时，这样操作非常有用。 例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># drbdadm -- --assume-clean resize r0</span><br></pre></td></tr></table></figure></p><p>选项<code>-al-stripes</code>和<code>--al-stripe-size-kB</code>可用于在线更改 <code>activity log</code>的布局。 在使用内部元数据的情况下，这可能会同时缩小用户可见大小（使用<code>--size</code> ）或增加后备设备上的可用空间。</p><ul><li>check-resize</li></ul><p>调用<code>drbdmeta</code>达到移动内部元数据的目的。 如果后台设备的大小已调整，而<code>DRBD</code>未运行，则必须将元数据移至设备的末尾，以便接下来的 <code>attach</code> 命令可以成功。</p><ul><li>create-md</li></ul><p>初始化元数据存储。 这需要在<code>DRBD</code>资源首次上线之前完成。 如果有关于该命令的问题请看<a href="https://docs.linbit.com/man/v84/drbdmeta-8/" target="_blank" rel="noopener">drbdmeta</a></p><ul><li>get-gi</li></ul><p>显示数据生成标识符(<code>GI元祖</code>)的简短文字表示。</p><ul><li>show-gi</li></ul><p>打印包含说明信息的数据生成标识符的文本表示。</p><ul><li>dump-md</li></ul><p>以文本形式转储元数据存储的全部内容，包括存储的位图和活动日志。</p><ul><li>outdate</li></ul><p>设置元数据中的过期标志。</p><ul><li>adjust</li></ul><p>将设备的配置与你的配置文件同步。 在实际执行此命令之前，应始终检查<code>dry-run</code>模式的输出。</p><ul><li>wait-connect</li></ul><p>等待设备连接到对等设备。</p><ul><li>role</li></ul><p>显示设备的当前角色（local/peer）。 例如：<code>Primary/Secondary</code></p><ul><li>state</li></ul><p>不赞成使用（废止），“角色”的别名，参见上文。</p><ul><li>cstate</li></ul><p>显示设备的当前连接状态。如：Connected、StandAlone 等</p><ul><li>dump</li></ul><p>解析配置文件并将其转储到<code>stdout</code>。 可用于检查配置文件的语法正确性。</p><ul><li>outdate</li></ul><p>用于将节点的数据标记为过时。 通常由对等方的 fence-peer 处理程序使用。</p><ul><li>verify</li></ul><p>开始在线验证。 在线验证期间，比较两个节点上的数据是否相等。 请参阅<code>/proc/drbd</code>进行在线验证。 如果发现不同步块，则它们不会自动重新同步。因此，请在验证完成后使用<code>disconnect</code> 和<code>connect</code>断开并连接资源。<br>另请参阅<code>drbd.conf</code>联机帮助页上有关数据完整性的注意事项。</p><ul><li>pause-sync</li></ul><p>通过设置本地暂停标志暂时中止正在进行的重新同步。 如果本地和远程暂停标志均未设置，则同步进行。 可能需要推迟<code>DRBD</code>的重新同步到支持存储的<code>RAID</code>设置重新同步之后进行。</p><ul><li>resume-sync</li></ul><p>取消设置本地同步暂停标志。</p><ul><li>new-current-uuid</li></ul><p>生成新的<code>当前 UUID</code>并旋转所有其他 UUID 值。<br>这可以用来缩短集群的初始再同步。 有关更多详细信息，请参阅<code>drbdsetup</code>联机帮助页。</p><ul><li>dstate</li></ul><p>以<code>local/peer</code>形式显示后备存储设备的当前状态。 如：UpToDate/UpToDate</p><ul><li>hidden-commands</li></ul><p>显示所有命令没有记录的命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[root@imoyao ~]# drbdadm hidden-commands</span><br><span class="line"></span><br><span class="line">These additional commands might be useful for writing   # 写脚本或许有用</span><br><span class="line">nifty shell scripts around drbdadm:</span><br><span class="line"></span><br><span class="line"> sh-nop                             sh-resources                       </span><br><span class="line"> sh-resource                        sh-mod-parms                       </span><br><span class="line"> sh-dev                             sh-udev                            </span><br><span class="line"> sh-minor                           sh-ll-dev                          </span><br><span class="line"> sh-md-dev                          sh-md-idx                          </span><br><span class="line"> sh-ip                              sh-lr-of                           </span><br><span class="line"> sh-b-pri                           sh-status                          </span><br><span class="line"> proxy-up                           proxy-down                         </span><br><span class="line"> new-resource                       </span><br><span class="line"></span><br><span class="line">These commands are used by the kernel part of DRBD to   # drbd内核</span><br><span class="line">invoke user mode helper programs:</span><br><span class="line"></span><br><span class="line"> before-resync-target               after-resync-target                </span><br><span class="line"> before-resync-source               pri-on-incon-degr                  </span><br><span class="line"> pri-lost-after-sb                  fence-peer                         </span><br><span class="line"> local-io-error                     pri-lost                           </span><br><span class="line"> initial-split-brain                split-brain                        </span><br><span class="line"> out-of-sync                        </span><br><span class="line"></span><br><span class="line">These commands ought to be used by experts and developers:  # 开发人员</span><br><span class="line"></span><br><span class="line"> sh-new-minor                       new-minor                          </span><br><span class="line"> suspend-io                         resume-io                          </span><br><span class="line"> set-gi                             new-current-uuid                   </span><br><span class="line"> check-resize</span><br></pre></td></tr></table></figure><h1 id="drbddisk-8"><a href="#drbddisk-8" class="headerlink" title="drbddisk.8"></a>drbddisk.8</h1><p>TODO</p><h1 id="drbdsetup-8-配置内核模块"><a href="#drbdsetup-8-配置内核模块" class="headerlink" title="drbdsetup.8-配置内核模块"></a>drbdsetup.8-配置内核模块</h1><p>TODO</p><h1 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h1><p>本文档针对 DRBD 发行版本 8.4.0 进行了修订。</p><h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>由 Philipp Reisner <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#112;&#104;&#105;&#x6c;&#105;&#112;&#112;&#46;&#114;&#x65;&#x69;&#115;&#x6e;&#101;&#114;&#x40;&#x6c;&#105;&#110;&#x62;&#105;&#116;&#46;&#x63;&#x6f;&#109;">&#112;&#104;&#105;&#x6c;&#105;&#112;&#112;&#46;&#114;&#x65;&#x69;&#115;&#x6e;&#101;&#114;&#x40;&#x6c;&#105;&#110;&#x62;&#105;&#116;&#46;&#x63;&#x6f;&#109;</a>和 Lars Ellenberg 撰写<a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x6c;&#x61;&#114;&#115;&#x2e;&#x65;&#108;&#x6c;&#x65;&#110;&#98;&#101;&#x72;&#x67;&#64;&#x6c;&#x69;&#x6e;&#x62;&#105;&#x74;&#46;&#x63;&#x6f;&#x6d;">&#x6c;&#x61;&#114;&#115;&#x2e;&#x65;&#108;&#x6c;&#x65;&#110;&#98;&#101;&#x72;&#x67;&#64;&#x6c;&#x69;&#x6e;&#x62;&#105;&#x74;&#46;&#x63;&#x6f;&#x6d;</a>。中译版由<code>imoyao</code>首发于别院牧志（<code>idealyard</code>）</p><h1 id="报告错误"><a href="#报告错误" class="headerlink" title="报告错误"></a>报告错误</h1><p>将错误报告给<a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#x3a;&#100;&#114;&#98;&#100;&#45;&#x75;&#x73;&#x65;&#114;&#x40;&#x6c;&#x69;&#115;&#116;&#115;&#46;&#108;&#x69;&#110;&#x62;&#105;&#x74;&#46;&#99;&#x6f;&#109;">&#100;&#114;&#98;&#100;&#45;&#x75;&#x73;&#x65;&#114;&#x40;&#x6c;&#x69;&#115;&#116;&#115;&#46;&#108;&#x69;&#110;&#x62;&#105;&#x74;&#46;&#99;&#x6f;&#109;</a>。</p><h1 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h1><p>版权所有 2001-2011 LINBIT 信息技术公司，Philipp Reisner，Lars Ellenberg。 这是免费软件; 请参阅复制条件的来源。 没有保修; 甚至不适用于适销性或针对特定用途的适用性。</p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p>drbd.conf （5）， drbd （8）， drbddisk （8）， drbdsetup （8）， drbdmeta （8）和 DRBD 项目网站 [1]</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://docs.linbit.com/man/v84/" target="_blank" rel="noopener">DRBD 8.4 Manual Pages</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DRBD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 DRBD 裂脑问题的总结</title>
      <link href="/blog/2018-05-27/Split-Brain-Of-DRBD/"/>
      <url>/blog/2018-05-27/Split-Brain-Of-DRBD/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>裂脑一旦发生，需要及时排查问题所在，最大限度保护数据完整性。<br><a id="more"></a></p><h2 id="什么是DRBD裂脑"><a href="#什么是DRBD裂脑" class="headerlink" title="什么是DRBD裂脑"></a>什么是<code>DRBD</code>裂脑</h2><p>裂脑(<code>split brain</code>)实际上是指在某种情况下，由集群节点间的网络连接临时故障、集群软件管理干预或者是人为错误，导致两个节点都切换为主节点（<code>primary</code>）而断开连接。这种状态是一个潜在的有害状态，因为它意味着不能复制数据到对等节点，这样就可能导致两个节点的数据产生分歧，产生不可合并的分裂。</p><h2 id="怎么判定裂脑"><a href="#怎么判定裂脑" class="headerlink" title="怎么判定裂脑"></a>怎么判定裂脑</h2><h3 id="查看日志信息"><a href="#查看日志信息" class="headerlink" title="查看日志信息"></a>查看日志信息</h3><p>如果<code>DRBD</code>出现裂脑，会在 <code>/var/log/message</code> 出现一条日志：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Split-Brain detected but unresolved, dropping connection!</span><br></pre></td></tr></table></figure><p>当发生<code>split brain</code>之后，如果查看连接状态，其中至少会有一个是<code>StandAlone</code>状态，另外一个可能也是<code>StandAlone</code>（如果是同时发现<code>split brain</code>状态），也有可能是 <code>WFConnection</code> 状态。</p><h3 id="裂脑自动通知"><a href="#裂脑自动通知" class="headerlink" title="裂脑自动通知"></a>裂脑自动通知</h3><p>如果进行配置，DRBD 会调用裂脑处理程序，当裂脑发生时就会被探测到。要配置这个程序，需要对资源<code>/etc/drbd.d/global_common.conf</code>添加如下配置：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resource &lt;resource&gt;</span><br><span class="line"></span><br><span class="line">  handlers &#123;</span><br><span class="line"></span><br><span class="line">    split-brain &lt;handler&gt;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>&lt;handler&gt;</code>可能是目前系统中一个可执行的文件。</p><p><code>Drbd</code>自带一个裂脑处理程序脚本<code>/usr/lib/drbd/notify-split-brain.sh</code>。它可以通过电子邮件的方式发送到指定的地址。要配合程序发送信息到 root@localhost（这假设是设置的系统管理员的邮件地址），配置如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resource &lt;resource&gt;</span><br><span class="line"></span><br><span class="line">  handlers &#123;</span><br><span class="line"></span><br><span class="line">    split-brain "/usr/lib/drbd/notify-split-brain.sh root";</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当配置已经在资源上进行修改（同步到两个节点上），就不需要添加其他的处理就可以启动处理程序。<code>Drbd</code>会在下一次检测到裂脑时直接调用该处理程序。</p><p>如果要配置真实可用的报警邮箱地址，则除了将上面的通知地址改为真实邮件地址:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">split-brain "/usr/lib/drbd/notify-split-brain.sh foo@bar.com</span><br></pre></td></tr></table></figure></p><p>还需要修改一下<code>ssmtp</code>配置文件：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/ssmtp/ssmtp.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 填写真实收件服务器信息</span></span><br><span class="line">mailhub=idealyard.imoyao.com:25</span><br></pre></td></tr></table></figure></p><p>更多配置参见 <a href="http://iqjar.com/jar/sending-emails-from-the-raspberry-pi/" target="_blank" rel="noopener">这里</a></p><h3 id="世代标识符元组（GI）"><a href="#世代标识符元组（GI）" class="headerlink" title="世代标识符元组（GI）"></a>世代标识符元组（GI）</h3><p>参见<a href="https://docs.linbit.com/docs/users-guide-8.4/#s-gi" target="_blank" rel="noopener">16.2. Generation Identifiers</a></p><p>DRBD 将其备份的数据的更新变化过程比拟成人类世代繁衍的过程。每个时点同一个双机的 DRBD 的两个节点上的数据都来自于同一份原始数据，我们可认为这个时点上两分数据源于同一祖先。主备节点的 DRBD 都会用一个叫作 GI(Generation ID)的标识符来标识当前的数据是哪个世代的，同样也会记录最近两个数据祖先的 GI 用于追朔当前数据的历史来源。DRBD 可以据此来判断两个节点是否是属于同一个双机,因为同一个双机的两份数据应该是从同一个祖先而来。<br>GI 作为 DRBD 的内部机制主要被用来：</p><ol><li>确定这两个节点是否是事实上的同一个集群的成员（而不是意外连接的两个节点）；</li><li>确定触发全盘同步（<code>full re-synchronization</code>）还是只触发部分同步（<code>partial re-synchronization</code>）。</li><li>确定后台重新同步的方向（如果需要全盘同步）；</li><li>确定裂脑。</li></ol><h4 id="数据迭代"><a href="#数据迭代" class="headerlink" title="数据迭代"></a>数据迭代</h4><p>当出现下列情形里<code>DRBD</code>会生成一个新的<code>GI</code>，用来标识新一代的数据：</p><ol><li>第一次全盘同步时；</li><li>一个<code>Disconnected</code>的资源转换为<code>Primary</code>时；</li><li>一个<code>Primary</code>的资源转换为<code>Disconnected</code>时。</li></ol><p>因此,我们可以总结出：只要一个<code>DRBD</code>资源处于<code>Connected</code>的状态，并且两边磁盘的状态为<code>UpToDate</code>，那么此<code>DRBD</code>资源在两个节点上的<code>GI</code>一定是一样的。此结论反过来也同样成立。请注意，<strong>当前实现使用最低位来编码节点的角色(<code>Primary/Secondary</code>)。 因此，即使它们被认为具有相同的数据生成，最低位在不同节点上也可能不同。</strong></p><p>每个新的数据生成都由一个<code>8</code>字节的通用唯一标识符（<code>UUID</code>）来标识。</p><h4 id="GI元祖"><a href="#GI元祖" class="headerlink" title="GI元祖"></a><code>GI</code>元祖</h4><p><code>DRBD</code>在本地资源元数据中保存有关当前和历史数据生成的四条信息：</p><ul><li><p>当前<code>UUID(C-UUID)</code><br>从本地节点的角度来看，这是当前数据生成的生成标识符。 当资源被连接并完全同步时，当前<code>UUID</code>在节点之间是相同的。</p></li><li><p>位图<code>UUID(B-UUID)</code><br>这是磁盘上同步位图跟踪的生成的<code>UUID</code>更改。 作为磁盘上的同步位图本身，此标识符仅在断开模式下才有用。 如果资源已连接，则此<code>UUID</code>始终为空（零）。</p></li><li><p>两个<code>历史UUID</code></p></li></ul><p>这些是当前之前两个数据世代的标识符。</p><ol><li>上一代数据的<code>UUID(H1-UUID)</code>；</li><li>最近第二代数据的<code>UUID(H2-UUID)</code>，即上一代数据的上一代数据的<code>UUID</code>。</li></ol><p>总的来说，这四个项目被称为代码标识符元组，或简称为<code>GI元组</code>。</p><h4 id="GI如何变化"><a href="#GI如何变化" class="headerlink" title="GI如何变化"></a><code>GI</code>如何变化</h4><ul><li>开始新的数据生成代</li></ul><p>当节点与其对等方失去连接时（网络故障或人工干预都有可能），DRBD 将按照以下方式修改其本地生成标识符：</p><p><img src="https://docs.linbit.com/ug-src/users-guide-8.4/images/gi-changes-newgen.png" alt="图1 GI元祖在生成新的数据代时改变"></p><ol><li>为新的数据代生成新的<code>UUID</code>，变为主节点的<code>C-UUID</code>；</li><li>之前的 UUID 现在指向位图（<code>B-UUID</code>）以跟踪数据变化，因此它成为主节点的新位图<code>UUID</code>；</li><li>备节点 GI 元祖保持不变。</li></ol><ul><li>开始重新同步</li></ul><p>在开始重新同步时，<code>DRBD</code>在本地代标识符上执行如下修改：</p><p><img src="https://docs.linbit.com/ug-src/users-guide-8.4/images/gi-changes-syncstart.png" alt="图2 GI元祖在重新开始同步是改变"></p><ol><li>在同步源端的<code>当前UUID</code>（C-UUID）保持不变；</li><li>同步源端的<code>位图UUID</code>轮转为<code>第一历史UUID</code>（H1-UUID）；</li><li>同步源端生成新的<code>位图UUID</code>（B-UUID）;</li><li>该 UUID（<em>应指同步源端生成的<code>B-UUID</code></em>）变为同步目标端的新的<code>当前UUID</code>（C-UUID）；</li><li>同步目标端的<code>位图UUID</code>（B-UUID）和<code>历史UUID</code>（H1-UUID,H2-UUID）保持不变。</li></ol><ul><li>重新同步结束</li></ul><p>当重新同步结束后，将执行以下更改：</p><p><img src="https://docs.linbit.com/ug-src/users-guide-8.4/images/gi-changes-synccomplete.png" alt="图3 当重新同步结束后，GI元祖发生改变"></p><ol><li>同步源端<code>当前UUID</code>(C-UUID)保持不变；</li><li>同步源端的<code>位图UUID</code>(B-UUID)轮转为<code>第一历史UUID</code>（H1-UUID），同时该 UUID(指<code>H1-UUID</code>)轮转为<code>第二历史UUID</code>(现有的第二历史 uuid 被丢弃)；</li><li>同步源端的<code>位图UUID</code>(B-UUID)清空（置零）；</li><li>同步目标端采用同步源端整个<code>GI元祖</code>。</li></ol><p>当节点之间建立连接之后，两个节点之间会交换当前可用的代标识符,然后根据比对的结果采取相应的操作。以下是可能的几种结果：</p><ul><li>两个节点上的当前<code>UUID(C-UUID)</code>都为空</li></ul><p>本地节点检测到它的当前<code>UUID</code>和对方的当前<code>UUID</code>都是空的。这通常是发生于尚未启动初始完全同步的新配置资源的正常情况。此时没有同步发生;须手动人为触发启动。</p><ul><li>单一节点上的当前<code>UUID(C-UUID)</code>为空</li></ul><p>本地节点检测到对方的当前<code>UUID</code>为空，而其本身非空。这是新配置资源的正常情况，此时初始全盘同步刚刚触发，本地节点被选为初始同步源（<code>sync source</code>）。 <code>DRBD</code>将磁盘上的同步位图(<code>sync bitmap</code>)中的所有位全部置位（意味着它认为整个设备不同步），并开始将其作为同步源同步。相反，（即本地当前<code>UUID</code>为空，对等节点非空），除了本地节点成为同步目标（<code>sync target</code>）之外，<code>DRBD</code>执行相同的步骤。</p><ul><li>当前<code>UUID(C-UUID)</code>相等</li></ul><p>本地节点检测到它的当前<code>UUID</code>和对等节点的当前<code>UUID</code>非空且相等时。这是资源在<code>secondary</code>状态进入断开连接（<code>disconnected</code>）模式时的正常情况，并且在断开连接时并未在任一节点上升为 <code>primary</code> 状态。此时不会触发同步，因为两边的数据一致，没有必要。</p><ul><li>位图<code>UUID（B-UUID）</code>匹配对等节点的当前<code>UUID（`C-UUID`）</code></li></ul><p>本地节点检测到其位图<code>UUID</code>匹配对等节点的当前<code>UUID</code>，且对等节点的位图<code>UUID</code>为空。这是本地节点处于 <code>primary</code> 状态，次要节点故障后正常且预期的情况。这意味着对端在此期间永远不会变为<code>primary</code>状态，并始终以相同的数据生成为前提运行。 <code>DRBD</code>此时以本地节点作为同步源（<code>sync source</code>）启动正常的后台重新同步（<code>re-sync</code>）。相反，如果本地节点检测到其位图<code>UUID</code>为空，且对等节点的位图与本地节点的当前<code>UUID</code>匹配，那么这是本地节点失败后的正常和预期情况。同样地，<code>DRBD</code>此时启动正常的后台重新同步，只不过本地节点成为同步目标（<code>sync target</code>）。</p><ul><li>当前<code>UUID(C-UUID)</code>匹配对等节点的历史<code>UUID（h-UUID）</code></li></ul><p>本地节点检测到其当前<code>UUID</code>与对等节点的历史<code>UUID</code>之一(<code>h1/h2</code>)匹配。这意味着尽管两个数据集共享一个共同的祖先且对等节点具有最新的数据，但保存在对等节点的位图中的信息已过时并且不可用。因此，简单的正常同步不够的。 <code>DRBD</code>此时将整个设备标记为未同步（<code>out-of-sync</code>）并启动以本地节点作为同步目标（<code>sync target</code>）的全盘后台重新同步。在相反的情况下（本地节点的某个历史<code>UUID</code>与对等节点的当前<code>UUID</code>相匹配），除了本地节点成为同步源（<code>sync source</code>）之外，<code>DRBD</code>执行相同的步骤。</p><ul><li>位图<code>UUID（B-UUID）</code>匹配，当前 <code>UUID(C-UUID)</code>不匹配</li></ul><p>本地节点检测到其当前<code>UUID</code>与对等节点的当前<code>UUID</code>不同且位图<code>UUID</code>匹配。这是裂脑（<code>split brain</code>）的一种情况，两份数据有相同的父代。这意味着<code>DRBD</code>可以调用裂脑自动恢复策略进行数据恢复（如果已配置）。否则，<code>DRBD</code>断开连接并等待手动恢复。</p><ul><li>当前<code>UUID（C-UUID）</code>和位图<code>UUID(B-UUID)</code>都不匹配</li></ul><p>本地节点检测到它的当前<code>UUID</code>与对等节点的当前<code>UUID</code>不同，并且位图<code>UUID</code>不匹配。这是两份数据与无关父代产生的一种裂脑，因此即使配置了自动恢复策略也没有意义。 <code>DRBD</code>处于断开连接并等待手动恢复状态。</p><ul><li>没有<code>UUID</code>匹配</li></ul><p>最后，如果<code>DRBD</code>未能检测到两个节点之间的<code>GI</code>元组中的单个元素匹配，则会记录关于无关数据（<code>unrelated data</code>）的警告并断开连接。这是<code>DRBD</code>的防范措施，可防止之前无关联的两个集群节点的意外连接导致数据破坏。</p><p>以上逻辑使用代码表示如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">empty_uuid = <span class="string">'0000000000000000'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slice_seq</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    对GI元祖内元素进行切片操作</span></span><br><span class="line"><span class="string">    :param seq: GI元祖</span></span><br><span class="line"><span class="string">    :return:type:list</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">global</span> empty_uuid</span><br><span class="line">    sliced_seq = [item[:<span class="number">-1</span>] <span class="keyword">if</span> item != empty_uuid <span class="keyword">else</span> item <span class="keyword">for</span> item <span class="keyword">in</span> seq]</span><br><span class="line">    <span class="keyword">return</span> sliced_seq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmp_both</span><span class="params">(seqa,seqb)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> seqa:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seqb:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_gi_action</span><span class="params">(drbdname)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    调用'drbdadm get-gi DRBDNAME'命令获取drbd的 GI(Generation ID) 信息</span></span><br><span class="line"><span class="string">    :param drbdname:type:str,drbd名称 like:'drbds1/drbdn301'</span></span><br><span class="line"><span class="string">    :return:获取正常返回元祖(c_uuid, b_uuid, h1_uuid, h2_uuid)，获取失败返回None</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    get_gi_cmd = <span class="string">"drbdadm get-gi %s |awk -F: '&#123;print $1,$2,$3,$4&#125;'"</span>%(drbdname)</span><br><span class="line">    retcode,proc = utils.cust_popen(get_gi_cmd)</span><br><span class="line">    message = proc.stderr.read(), proc.stdout.read()</span><br><span class="line">    retstr = message[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> retstr:</span><br><span class="line">        c_uuid,b_uuid,h1_uuid,h2_uuid = tuple(retstr.split())</span><br><span class="line">        <span class="keyword">return</span> c_uuid,b_uuid,h1_uuid,h2_uuid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        debug.write_debug(debug.LINE(), <span class="string">"peradrbd"</span>, message)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_remote_gi</span><span class="params">(params)</span>:</span></span><br><span class="line">    rtndata = &#123;&#125;</span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    drbdname = <span class="string">'drbdname'</span> <span class="keyword">in</span> params <span class="keyword">and</span> params[<span class="string">'drbdname'</span>] <span class="keyword">or</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> drbdname:</span><br><span class="line">        <span class="keyword">if</span> hasthedrbd(drbdname):</span><br><span class="line">            gi_uuids = get_gi_action(drbdname)</span><br><span class="line">            <span class="keyword">if</span> gi_uuids <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                rtndata[<span class="string">'state'</span>] = <span class="string">'0'</span></span><br><span class="line">                result[<span class="string">'message'</span>] = <span class="string">''</span></span><br><span class="line">                result[<span class="string">'gi_id'</span>] = gi_uuids</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rtndata[<span class="string">'state'</span>] = <span class="string">'1'</span></span><br><span class="line">                result[<span class="string">'message'</span>] = <span class="string">'11069'</span>     <span class="comment"># 获取 gi_id 出错</span></span><br><span class="line">                result[<span class="string">'gi_id'</span>] = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rtndata[<span class="string">'state'</span>] = <span class="string">'1'</span></span><br><span class="line">            result[<span class="string">'message'</span>] = <span class="string">'11060'</span>  <span class="comment"># the drbd not found</span></span><br><span class="line"></span><br><span class="line">        rtndata[<span class="string">'result'</span>] = result</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rtndata = &#123;<span class="string">'state'</span>: <span class="string">'1'</span>, <span class="string">'result'</span>: &#123;<span class="string">'message'</span>: <span class="string">'11059'</span>&#125;&#125;  <span class="comment"># drbdname error</span></span><br><span class="line">    <span class="keyword">return</span> rtndata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange_gi_process</span><span class="params">(drbdname)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    see:https://docs.linbit.com/docs/users-guide-8.4/#s-gi (16.2.4. How DRBD uses generation identifiers)</span></span><br><span class="line"><span class="string">    :param drbdname:</span></span><br><span class="line"><span class="string">    :return:type:str</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    local_gis = get_gi_action(drbdname)</span><br><span class="line">    remote_gis = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">global</span> remoteip</span><br><span class="line">    retresult = hautils.socketclient(ip=remoteip,</span><br><span class="line">                                     **&#123;<span class="string">'target'</span>: <span class="string">'drbd'</span>, <span class="string">'op'</span>: <span class="string">'getremotegi'</span>, <span class="string">'params'</span>: &#123;<span class="string">'drbdname'</span>:drbdname&#125;&#125;)</span><br><span class="line">    <span class="keyword">if</span> retresult:</span><br><span class="line">        <span class="keyword">if</span> retresult[<span class="string">'state'</span>] == <span class="string">'0'</span>:</span><br><span class="line">            remote_gis = retresult[<span class="string">'result'</span>][<span class="string">'gi_id'</span>]</span><br><span class="line">        drbd_next = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> local_gis <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> remote_gis <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            local_gis_sliced = slice_seq(local_gis)</span><br><span class="line">            remote_gis_sliced = slice_seq(remote_gis)</span><br><span class="line">            <span class="keyword">global</span> empty_uuid</span><br><span class="line">            print(<span class="string">'sliced'</span>, local_gis_sliced, remote_gis_sliced)</span><br><span class="line">            <span class="keyword">if</span> local_gis_sliced[<span class="number">0</span>] == empty_uuid <span class="keyword">and</span> remote_gis_sliced[<span class="number">0</span>] == empty_uuid:</span><br><span class="line">                drbd_next = <span class="string">'no_sync:(manual_sync)'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> local_gis_sliced[<span class="number">0</span>] == empty_uuid <span class="keyword">or</span> remote_gis_sliced[<span class="number">0</span>] == empty_uuid:</span><br><span class="line">                <span class="keyword">if</span> remote_gis_sliced[<span class="number">0</span>] == empty_uuid <span class="keyword">and</span> local_gis_sliced[<span class="number">0</span>] != empty_uuid:</span><br><span class="line">                    drbd_next = <span class="string">'full_re_sync:(local_source)'</span></span><br><span class="line">                <span class="keyword">elif</span> local_gis_sliced[<span class="number">0</span>] == empty_uuid <span class="keyword">and</span> remote_gis_sliced[<span class="number">0</span>] != empty_uuid:</span><br><span class="line">                    drbd_next = <span class="string">'full_re_sync:(local_target)'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> local_gis_sliced[<span class="number">0</span>] != empty_uuid <span class="keyword">and</span> remote_gis_sliced[<span class="number">0</span>] != empty_uuid <span class="keyword">and</span> local_gis_sliced[<span class="number">0</span>] == remote_gis_sliced[<span class="number">0</span>]:</span><br><span class="line">                drbd_next = <span class="string">'consistent:(both_secondary)'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> local_gis_sliced[<span class="number">1</span>] == remote_gis_sliced[<span class="number">0</span>] <span class="keyword">and</span> remote_gis_sliced[<span class="number">1</span>] == empty_uuid:</span><br><span class="line">                drbd_next = <span class="string">'partial_re_sync:(local_source)'</span></span><br><span class="line">            <span class="keyword">elif</span> local_gis_sliced[<span class="number">1</span>] == empty_uuid <span class="keyword">and</span> remote_gis_sliced[<span class="number">1</span>] == local_gis_sliced[<span class="number">0</span>]:</span><br><span class="line">                drbd_next = <span class="string">'partial_re_sync:(local_target)'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> local_gis_sliced[<span class="number">0</span>] <span class="keyword">in</span> [remote_gis_sliced[<span class="number">2</span>], remote_gis_sliced[<span class="number">3</span>]]:</span><br><span class="line">                drbd_next = <span class="string">'full_re_sync:(local_target)'</span></span><br><span class="line">            <span class="keyword">elif</span> remote_gis_sliced[<span class="number">0</span>] <span class="keyword">in</span> [local_gis_sliced[<span class="number">2</span>], local_gis_sliced[<span class="number">3</span>]]:</span><br><span class="line">                drbd_next = <span class="string">'full_re_sync:(local_source)'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> local_gis_sliced[<span class="number">0</span>] != remote_gis_sliced[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> local_gis_sliced[<span class="number">1</span>] == remote_gis_sliced[<span class="number">1</span>]:</span><br><span class="line">                    drbd_next = <span class="string">'split_brain:(auto_recover_able)'</span></span><br><span class="line">                <span class="keyword">elif</span> local_gis_sliced[<span class="number">1</span>] != remote_gis_sliced[<span class="number">1</span>]:</span><br><span class="line">                    drbd_next = <span class="string">'split_brain:(wait_for_manual_recover)'</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> cmp_both(local_gis_sliced,remote_gis_sliced):</span><br><span class="line">                drbd_next = <span class="string">'unrelated_data:(wait_for_manual_recover)'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                debug.write_debug(debug.LINE(), <span class="string">"peradrbd"</span>, (local_gis_sliced, remote_gis_sliced))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            debug.write_debug(debug.LINE(), <span class="string">"peradrbd"</span>, (local_gis,remote_gis))</span><br><span class="line">        <span class="keyword">return</span> drbd_next</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">**注意**：</span><br><span class="line"></span><br><span class="line">经分析官方文档中的<span class="string">'matches'</span>并不是完全相等，而 <span class="string">'UUID is always empty (zero)'</span> 是指 <span class="string">"'0'*16"</span> 的字符串</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如何模拟一个 `Split-Brain`状态</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 往主节点写入大文件，在未写入完前停止备节点的`DRBD`；</span><br><span class="line">```plain</span><br><span class="line"><span class="comment"># on secondary</span></span><br><span class="line">drbdadm down drbdxx</span><br></pre></td></tr></table></figure><ol><li><p>停止主节点的<code>DRBD</code>；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># on primary</span><br><span class="line">drbdadm down drbdxx</span><br></pre></td></tr></table></figure></li><li><p>启动备节点的<code>DRBD</code>，设置为主节点；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># on secondary</span><br><span class="line">drbdadm up drbdxx</span><br><span class="line">drbdadm primary drbdxx</span><br></pre></td></tr></table></figure></li><li><p>启动原主节点的<code>DRBD</code>，这时发现它的状态就是<code>StandAlone Secondary/Unknown UpToDate/DUnknown</code>，<code>Split-Brain</code> 情况出现。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># on primary</span><br><span class="line">drbdadm up drbdxx</span><br></pre></td></tr></table></figure></li></ol><h2 id="解决-DRBD-裂脑状态"><a href="#解决-DRBD-裂脑状态" class="headerlink" title="解决 DRBD 裂脑状态"></a>解决 DRBD 裂脑状态</h2><h3 id="设置自动修复"><a href="#设置自动修复" class="headerlink" title="设置自动修复"></a>设置自动修复</h3><p><a href="https://docs.linbit.com/docs/users-guide-8.4/#s-configure-split-brain-behavior" target="_blank" rel="noopener">5.17.2. Automatic split brain recovery policies</a></p><p><strong>警告</strong>：配置<code>DRBD</code>自动修复裂脑（或其他状况）导致的数据分歧情况可能是正在配置的数据丢失，如果你不知道你在干什么，那最好别干。（NO ZUO NO DIE）</p><p><em>提示</em> ：您更应该查看系统防护策略，集群管理集成和冗余集群管理器通信连接状态，以避免出现数据分歧。（防患于未然而不是亡羊补牢）<br>在启用和配置<code>DRBD</code>的自动裂脑恢复策略之前，您必须了解<code>DRBD</code>为此提供了多种配置选项。 DRBD 根据检测到裂脑时主节点（<code>Primary role</code>）的数量应用其裂脑恢复程序。为此，DRBD 检查以下关键字，这些关键字均可在资源的网络配置部分中找到：</p><h4 id="after-sb-0pri"><a href="#after-sb-0pri" class="headerlink" title="after-sb-0pri"></a>after-sb-0pri</h4><p>裂脑被检测到的同时该资源在任一节点不是主节点。对于这种状况，<code>DRBD</code>可以理解以下关键字：</p><ul><li>disconnect: 不自动恢复，只调用裂脑通知程序（如果已配置），断开连接并保持断开；</li><li>discard-younger-primary: 丢弃并回滚最后升主节点的改动；</li><li>discard-least-changes: 丢弃并回滚修改更少节点的修改；</li><li>discard-zero-changes: 如果有某一节点一点未改动，只需应用对另一主机所做的修改并继续；</li></ul><h4 id="after-sb-1pri"><a href="#after-sb-1pri" class="headerlink" title="after-sb-1pri"></a>after-sb-1pri</h4><p>裂脑刚被检测到的同时该资源在一个节点上是主节点。对于这种状况，<code>DRBD</code>理解以下关键字：</p><ul><li>disconnect:同上</li><li>consensus：应用上一步的策略之后，如果裂脑受害者可以选择拆分则会自动解决。否则，与<code>disconnect</code>指令相同。</li><li>call-pri-lost-after-sb：应用上一步的策略之后，如果裂脑受害者节点可以选择拆分则调用<code>pri-lost-after-sb</code>处理程序，该处理程序必须在处理程序中进行配置，并且需要强制从集群中删除该节点。</li><li>discard-secondary：将从端（<code>Secondary role</code>）节点视为裂脑受害者。</li></ul><h4 id="after-sb-2pri"><a href="#after-sb-2pri" class="headerlink" title="after-sb-2pri"></a>after-sb-2pri</h4><p>裂脑刚被检测到时该资源在两个节点都处于主端。该选项接受与除<code>discard-secondary</code> 和 <code>consensus</code> 之外与 <code>after-sb-1pri</code> 相同的关键字。</p><p><em>提示</em>：<code>DRBD</code>还可以理解这三个选项下额外的关键字，这些关键字在这里被省略，因为它们很少被使用。请参阅<code>drbd.conf</code>的手册页以获取有关裂脑恢复关键字的详细信息，此处不再讨论。<br>例如，用作双主模式下<code>GFS</code>或<code>OCFS2</code>文件系统的块设备的资源可能会将其恢复策略定义如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resource &lt;resource&gt; &#123;</span><br><span class="line">  handlers &#123;</span><br><span class="line">    split-brain "/usr/lib/drbd/notify-split-brain.sh root"      # 脚本通知root用户，此处可以使用邮件提醒</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  net &#123;</span><br><span class="line">    after-sb-0pri discard-zero-changes;</span><br><span class="line">    after-sb-1pri discard-secondary;</span><br><span class="line">    after-sb-2pri disconnect;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手动恢复"><a href="#手动恢复" class="headerlink" title="手动恢复"></a>手动恢复</h3><p><a href="https://docs.linbit.com/docs/users-guide-8.4/#s-resolve-split-brain" target="_blank" rel="noopener">6.3. Manual split brain recovery</a></p><p>在检测到裂脑后，一个节点将始终使资源处于<code>StandAlone</code>连接状态。另一个可能也处于<code>StandAlone</code>状态（如果两个节点同时检测到裂脑）或<code>WFConnection</code>（如果某方节点在另一节点检测到裂脑之前断开连接）。</p><p>此时，除非已将<code>DRBD</code>配置为自动从裂脑状态中恢复，否则必须通过选择一个节点进行手动干预，该节点的修改将被丢弃（此节点称为裂脑受害者）。这个干预使用下面步骤完成：</p><p>裂脑受害者需要处于<code>StandAlone</code>的连接状态，否则以下命令将返回错误。您可以通过发出以下内容确保它是<code>StandAlone</code>的：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm disconnect &lt;resource&gt;</span><br><span class="line">drbdadm secondary &lt;resource&gt;</span><br><span class="line">drbdadm connect --discard-my-data &lt;resource&gt;    # 8.4+  if 8.3,use 'drbdadm -- --discard-my-data connect &lt;resource&gt;' instead</span><br></pre></td></tr></table></figure></p><p>在另一个节点（裂脑幸存者）上，如果它的连接状态也是<code>StandAlone</code>，你可以输入：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm connect &lt;resource&gt;</span><br></pre></td></tr></table></figure></p><p>如果节点已处于<code>WFConnection</code>状态，则可以省略此步骤;它会自动重新连接。</p><p>如果受裂脑影响的资源是<strong>堆叠</strong>资源，请使用<code>drbdadm --stacked</code>而不是<code>drbdadm</code>。</p><p>连接后，裂脑受害者立即将其连接状态更改为<code>SyncTarget</code>，并将其导致裂脑的修改由其余主节点的数据覆盖。</p><p>裂脑受害者不会引发全盘同步。相反，它的局部修改已经被回滚，对裂脑幸存者的任何修改都会传递给受害者。<br>重新同步完成后，裂脑被视为已解决（<code>resolved</code>），两个节点再次形成完全一致的冗余复制存储系统（<code>DRBD</code>）。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://docs.linbit.com/docs/users-guide-8.4/" target="_blank" rel="noopener">User’s Guide 8.4.x</a></li><li><a href="http://blog.sina.com.cn/s/blog_a30f2be401016d04.html" target="_blank" rel="noopener">关于 DRBD v8.3 的同步机制</a></li><li><a href="http://myhat.blog.51cto.com/391263/606318/" target="_blank" rel="noopener">一次 DRBD 裂脑行为的模拟</a></li><li><a href="http://itindex.net/detail/50197-drbd" target="_blank" rel="noopener">drbd 裂脑处理 | IT 瘾</a></li></ul><p><a href="http://www.3mu.me/%E4%BB%80%E4%B9%88%E6%98%AFdrbd%E8%84%91%E8%A3%82%E5%8F%8A%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9Fdrbd%E8%84%91%E8%A3%82/" target="_blank" rel="noopener">http://www.3mu.me/%E4%BB%80%E4%B9%88%E6%98%AFdrbd%E8%84%91%E8%A3%82%E5%8F%8A%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9Fdrbd%E8%84%91%E8%A3%82/</a></p><p>drbd 中 metadata 的理解(原创) – 蚊子世界<br><a href="http://www.wenzizone.cn/2009/10/29/drbd%e4%b8%admetadata%e7%9a%84%e7%90%86%e8%a7%a3%e5%8e%9f%e5%88%9b.html" target="_blank" rel="noopener">http://www.wenzizone.cn/2009/10/29/drbd%e4%b8%admetadata%e7%9a%84%e7%90%86%e8%a7%a3%e5%8e%9f%e5%88%9b.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> DRBD </tag>
            
            <tag> 裂脑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于在 Python 中 MySQL 的 WHERE 子句中执行 IN 操作（list，tuple）的问题</title>
      <link href="/blog/2018-05-10/executing-select-where-in-using-mysqldb/"/>
      <url>/blog/2018-05-10/executing-select-where-in-using-mysqldb/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天在写代码的时候，有一处查询语句需要执行 <code>IN</code> 操作，结果直接<code>join</code>操作会出错。<br><a id="more"></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_of_datas = [<span class="string">u'sde'</span>, <span class="string">u'sdf'</span>, <span class="string">u'sdb'</span>, <span class="string">u'sdc'</span>]</span><br><span class="line">sql = <span class="string">"SELECT DiskId,Name,Sg,PhyId,ExpanderId,EProduct FROM Disk WHERE Used='2' AND Name IN (%s)"</span> % <span class="string">','</span>.join(list_of_datas)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DiskId, <span class="keyword">Name</span>, Sg, PhyId, ExpanderId</span><br><span class="line">, EProduct</span><br><span class="line"><span class="keyword">FROM</span> Disk</span><br><span class="line"><span class="keyword">WHERE</span> Used = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">Name</span> <span class="keyword">IN</span> (sde, sdf, sdb, sdc)</span><br></pre></td></tr></table></figure><p>很明显与预期的结果是不一样的。因为 <code>IN</code> 操作中的选取字段应该是带引号的字符串，而不是直接显示的字符串。也就是说我们期望的<code>WHERE</code>子句中是<code>WHERE Used = &#39;2&#39; AND Name IN (&#39;sde&#39;, &#39;sdf&#39;, &#39;sdb&#39;, &#39;sdc&#39;)</code>形式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql1 = <span class="string">"SELECT DiskId,Name,Sg,PhyId,ExpanderId,EProduct FROM Disk WHERE Used='2' AND Name IN (%s)"</span> % <span class="string">','</span>.join([<span class="string">"'%s'"</span> % item <span class="keyword">for</span> item <span class="keyword">in</span> list_of_datas])</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DiskId, <span class="keyword">Name</span>, Sg, PhyId, ExpanderId</span><br><span class="line">, EProduct</span><br><span class="line"><span class="keyword">FROM</span> Disk</span><br><span class="line"><span class="keyword">WHERE</span> Used = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">Name</span> <span class="keyword">IN</span> (<span class="string">'sde'</span>, <span class="string">'sdf'</span>, <span class="string">'sdb'</span>, <span class="string">'sdc'</span>)</span><br></pre></td></tr></table></figure><p>至此，可以满足我们的要求。不过，由于上面字符化操作感觉有点暴力，我们可以稍微改进一下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">format_strings= <span class="string">','</span>.join([repr(item) <span class="keyword">for</span> item <span class="keyword">in</span> list_of_datas])</span><br><span class="line">print(format_strings)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">u'sde'</span>,<span class="string">u'sdf'</span>,<span class="string">u'sdb'</span>,<span class="string">u'sdc'</span></span><br></pre></td></tr></table></figure><p>此时 <code>SQL</code> 语句变成:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DiskId,<span class="keyword">Name</span>,Sg,PhyId,ExpanderId,EProduct <span class="keyword">FROM</span> Disk <span class="keyword">WHERE</span> Used=<span class="string">'2'</span> <span class="keyword">AND</span> <span class="keyword">Name</span> <span class="keyword">IN</span> (u<span class="string">'sde'</span>,u<span class="string">'sdf'</span>,u<span class="string">'sdb'</span>,u<span class="string">'sdc'</span>)</span><br></pre></td></tr></table></figure><p>这个是没办法正常查询出结果的，因为查询字段是 <code>unicode</code> 编码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">format_unicode_strings = <span class="string">','</span>.join([repr(item.encode(<span class="string">'utf-8'</span>)) <span class="keyword">if</span> isinstance(item,unicode) <span class="keyword">else</span> repr(item) <span class="keyword">for</span> item <span class="keyword">in</span> list_of_datas])</span><br></pre></td></tr></table></figure><p>此时结果满足我们的要求：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DiskId, <span class="keyword">Name</span>, Sg, PhyId, ExpanderId</span><br><span class="line">, EProduct</span><br><span class="line"><span class="keyword">FROM</span> Disk</span><br><span class="line"><span class="keyword">WHERE</span> Used = <span class="string">'2'</span></span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">Name</span> <span class="keyword">IN</span> (<span class="string">'sde'</span>, <span class="string">'sdf'</span>, <span class="string">'sdb'</span>, <span class="string">'sdc'</span>)</span><br></pre></td></tr></table></figure><p>至此，收工。</p><p>因为公司的代码封装函数是只能执行真正的 <code>SQL</code> 语句的，所以只能用上面的方法，查询网络上别人的解决方案发现下面的写法，以备参考。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>alist = [<span class="string">'1.1.1.1'</span>,<span class="string">'2.2.2.2'</span>,<span class="string">'3.3.3.3'</span>]                                                    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>select_str = <span class="string">'select * from server where ip in (%s)'</span> % <span class="string">','</span>.join([<span class="string">'%s'</span>] * len(alist))       </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>select_str  </span><br><span class="line"><span class="string">'select * from server where ip in (%s,%s,%s)'</span> </span><br><span class="line"> <span class="comment"># 执行sql查询</span></span><br><span class="line">cursor.execute(select_str,a)</span><br></pre></td></tr></table></figure><p>后面的写法有很多种，比如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">in_p = <span class="string">', '</span>.join((map(<span class="keyword">lambda</span> x: <span class="string">'%s'</span>, args)))</span><br><span class="line">realsql = sql % in_p</span><br><span class="line">cursor.execute(realsql, args)</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">in_p = <span class="string">', '</span>.join(itertools.repeat(<span class="string">'%s'</span>, len(args)))</span><br><span class="line">cursor.execute(sql % in_p, args)</span><br></pre></td></tr></table></figure><p>完整示例代码:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Created by imoyao at 2018/5/18 17:17</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">excute_sql</span><span class="params">(sql)</span>:</span></span><br><span class="line">    db = MySQLdb.connect(host=<span class="string">"localhost"</span>, user=<span class="string">"imoyao"</span>, passwd=<span class="string">"111111"</span>, db=<span class="string">"ODSP"</span>, charset=<span class="string">"utf8"</span>)</span><br><span class="line">    cr = db.cursor()</span><br><span class="line">    cr.execute(sql)</span><br><span class="line">    data = cr.fetchall()</span><br><span class="line">    cr.close()</span><br><span class="line">    db.close()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">excute_sql_datas</span><span class="params">(sqlstr, tupledata)</span>:</span></span><br><span class="line">    db = MySQLdb.connect(host=<span class="string">"localhost"</span>, user=<span class="string">"imoyao"</span>, passwd=<span class="string">"111111"</span>, db=<span class="string">"ODSP"</span>, charset=<span class="string">"utf8"</span>)</span><br><span class="line">    cr = db.cursor()</span><br><span class="line">    cr.execute(sqlstr,tupledata)</span><br><span class="line">    data = cr.fetchall()</span><br><span class="line">    cr.close()</span><br><span class="line">    db.close()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    list_of_datas = [<span class="string">u'sde'</span>, <span class="string">u'sdf'</span>, <span class="string">u'sdb'</span>, <span class="string">u'sdc'</span>]</span><br><span class="line">    format_strings = <span class="string">','</span>.join(</span><br><span class="line">        [repr(item.encode(<span class="string">'utf-8'</span>)) <span class="keyword">if</span> isinstance(item, unicode) <span class="keyword">else</span> repr(item) <span class="keyword">for</span> item <span class="keyword">in</span> list_of_datas])</span><br><span class="line">    sql = <span class="string">"SELECT DiskId,Name,Sg,PhyId,ExpanderId,EProduct FROM Disk WHERE Used='2' AND Name IN (%s)"</span> % format_strings</span><br><span class="line">    print(excute_sql(sql))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'*'</span>*<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">    sql2 = <span class="string">"SELECT DiskId,Name,Sg,PhyId,ExpanderId,EProduct FROM Disk WHERE Used='2' AND Name IN (%s)"</span></span><br><span class="line">    <span class="comment"># format_strings2 = ', '.join(map(lambda x: '%s', list_of_datas))</span></span><br><span class="line">    <span class="comment"># format_strings2 = ', '.join(['%s'] * len(list_of_datas))</span></span><br><span class="line">    format_strings2 = <span class="string">', '</span>.join(itertools.repeat(<span class="string">'%s'</span>, len(list_of_datas)))</span><br><span class="line">    sqlstr = sql2 % format_strings2</span><br><span class="line">    print(excute_sql_datas(sqlstr, list_of_datas))</span><br></pre></td></tr></table></figure><p>参考链接：</p><ol><li><p><a href="https://blog.csdn.net/u011085172/article/details/79044490" target="_blank" rel="noopener">python mysql where in 对列表（list,,array）问题 - CSDN 博客</a></p></li><li><p><a href="https://stackoverflow.com/questions/4574609/executing-select-where-in-using-mysqldb" target="_blank" rel="noopener">python - Executing “SELECT … WHERE … IN …” using MySQLdb - Stack Overflow</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Python 中的下划线用法的记录</title>
      <link href="/blog/2018-04-28/the-underline-of-Python/"/>
      <url>/blog/2018-04-28/the-underline-of-Python/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="Py-乙己"><a href="#Py-乙己" class="headerlink" title="Py 乙己"></a>Py 乙己</h2><p>孔乙己自己知道不能和架构师谈天，便只好向实习生说话。</p><p>有一回对我说道，“你写过<code>Python</code>么？”我略略点一点头。</p><p>他说，“写过代码，……我便考你一考。<code>Python</code>中的下划线，怎样用的？”</p><p>我想，搬砖一样的人，也配考我么？便回过脸去，不再理会。</p><p>孔乙己等了许久，很恳切的说道，“不能写罢？……我教给你，记着！这些用法应该记着。将来做面试官的时候要用。”</p><p>我暗想我和面试官的等级还很远呢，而且我们面试官也从不将这些问题拿来考应聘者；又好笑，又不耐烦，懒懒的答他道，“谁要你教，不就是命名变量，增加代码的可读性吗？”</p><p>孔乙己显出极高兴的样子，将两个指头的长指甲敲着键盘，点头说，“对呀对呀！……下划线有四种写法，你知道么？”</p><p>我愈不耐烦了，努着嘴走远。孔乙己刚用纸巾擦了擦键盘上的咖啡渍，想在<code>IDE</code>里写代码，见我毫不热心，便又叹一口气，显出极惋惜的样子。<br><a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul><li>在交互式解释器中获取上一个语句执行的结果；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>+<span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_ * <span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>用来在函数、模块、包、变量名中分隔单词，增加可读性；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var_foo_bar = <span class="string">'hello,world!'</span></span><br></pre></td></tr></table></figure><ul><li>内部使用的变量、属性、方法、函数、类或模块，（约定）又称为内部实现；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假定存在foo.py中定义变量：</span></span><br><span class="line">_var = <span class="number">9527</span></span><br><span class="line"><span class="comment"># 在bar.py中导入</span></span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> *   <span class="comment"># 不会导入以下划线开头的对象</span></span><br><span class="line">print(_var)</span><br><span class="line"><span class="comment"># 返回：</span></span><br><span class="line">NameError: name <span class="string">'_var'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">当然也可以强制导入（不推荐）</span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> _var        <span class="comment"># Access to a protected member _var of a module</span></span><br><span class="line">print(_var)</span><br><span class="line"><span class="comment"># 返回：</span></span><br><span class="line"><span class="number">9527</span></span><br></pre></td></tr></table></figure><ul><li>避免与 <code>Python</code> 保留的关键字冲突（约定）；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Tkinter.Toplevel(master, class_=<span class="string">'ClassName'</span>)        <span class="comment"># 注意class为Python內建名称</span></span><br></pre></td></tr></table></figure><ul><li>在类内的私有变量（<code>private</code>），类外部无法直接使用原名称访问，需要通过<code>instance._ClassName__var</code>的形式访问（<code>name mangling</code>）；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    __say_hello = <span class="string">'Hello,world'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pi = Person(<span class="string">'Peter'</span>, <span class="number">26</span>)</span><br><span class="line">    <span class="comment"># print(pi.__say_hello)       # AttributeError: 'Person' object has no attribute '__say_hello'</span></span><br><span class="line">    print(pi._Person__say_hello)</span><br><span class="line">    print(pi.get_age())</span><br></pre></td></tr></table></figure><p>我们可以使用<code>dir(pi)</code>看一下对象中的中的属性和方法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">['_Person__say_hello', '__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'get_age', 'get_name', 'name']</span><br></pre></td></tr></table></figure><p>这里 <code>Python</code> 解释器触发名称修饰，它这样做是为了防止变量在子类中被重写。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个集成Person的AI类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AI</span><span class="params">(Person)</span>:</span></span><br><span class="line"></span><br><span class="line">    __say_hello = <span class="string">'ALL in AI'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    ai_attr = [<span class="string">'ALL in AI'</span>]*<span class="number">3</span></span><br><span class="line">    ai = AI(*ai_attr)</span><br><span class="line">    print(dir(ai))</span><br></pre></td></tr></table></figure><p>我们可以看到继承关系：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回</span></span><br><span class="line">[<span class="string">'_AI__say_hello'</span>, <span class="string">'_Person__gender'</span>, <span class="string">'_Person__say_hello'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__format__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'_age'</span>, <span class="string">'name'</span>]</span><br></pre></td></tr></table></figure><p>这点在 <code>《Python Cookbook》- 8.5 在类中封装属性名</code> 中对于单下划线和双下划线的使用场景也有提及和解释：</p><blockquote><p>大多数而言，你应该让你的非公共名称以单下划线开头。但是，如果你清楚你的代码会涉及到子类，并且有些内部属性应该在子类中隐藏起来，那么才考虑使用双下划线方案。</p></blockquote><ul><li>在类内的保护变量（这一条存疑）；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_var_</span><br></pre></td></tr></table></figure><ul><li><code>Python</code> 内置的“魔法”方法或属性，你也可以自己定义，但强烈 <strong>不推荐</strong>。比如：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__init__, __file__, __main__</span><br></pre></td></tr></table></figure><ul><li>作为内部使用的一次性变量；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">通常在循环里使用,比如：</span><br><span class="line">foo_list = [_ <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">或是用作占位，不实际使用的变量,比如：</span><br><span class="line"><span class="keyword">for</span> _, a <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>)]:</span><br><span class="line">    <span class="keyword">print</span> a</span><br></pre></td></tr></table></figure><ul><li><code>i18n</code> 里作为 <code>gettext()</code> 的缩写；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_()</span><br></pre></td></tr></table></figure><ul><li>用来分隔数值以增加可读性（<code>Python 3.6</code> 新增）；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>num = <span class="number">1</span>_000_000 </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num</span><br><span class="line"><span class="number">1000000</span></span><br><span class="line"><span class="number">1</span>_000_000</span><br></pre></td></tr></table></figure><h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><ol><li><p><a href="http://pep8.org/#descriptive-naming-styles" target="_blank" rel="noopener">PEP 8 – Style Guide for Python Code</a></p></li><li><p><a href="https://www.pythonsheets.com/notes/python-basic.html#python-naming-rule" target="_blank" rel="noopener">Python basic cheatsheet</a></p></li><li><p><a href="https://dbader.org/blog/meaning-of-underscores-in-python" target="_blank" rel="noopener">The Meaning of Underscores in Python – dbader.org</a></p></li><li><p><a href="https://www.zhihu.com/question/268940585/answer/344852737" target="_blank" rel="noopener">Python 中的下划线_有多少个意思？- 知乎</a></p></li></ol><h2 id="派森多一点"><a href="#派森多一点" class="headerlink" title="派森多一点"></a>派森多一点</h2><p><code>Python</code>中的<code>dunder</code></p><p>参见<a href="https://nedbatchelder.com/blog/200605/dunder.html" target="_blank" rel="noopener">这里</a></p><blockquote><p>关于<code>Python</code> 编程的一个尴尬的事情是：有很多种双下划线。 例如，语法糖下面的标准方法名称具有 <code>__getattr__</code> 这样的名称，构造函数是 <code>__init__</code> ，内置运算符可以用 <code>__add__</code> 重载，等等。 在 <code>Django</code> 框架中（至少在他们整合了 <code>magic-removal</code> 分支之前），对象关系映射器使用了名为 <code>user__id__exact</code> 的关键字参数。</p><p>双下划线的问题是很难向别人描述。 你怎么读 <code>__init__</code> ？ “下划线下划线 <code>init</code> 下划线下划线”？ “双下划线 <code>init</code> 双下划线”？ 简单的 “<code>init</code>” 似乎漏掉了一些重要的东西。</p><p>我有一个解决方案：双下划线应该发音为 “<code>dunder</code>” 。 所以 <code>__init__</code> 念成“<code>dunder init dunder</code>”，或者也可以简读为 “<code>dunder init</code>” 。</p><p>现在我期待某个人定义一下 “<code>dunderhead</code>” 是什么意思，haha……</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析 Python 中的延迟绑定问题</title>
      <link href="/blog/2018-04-10/late-binding-of-Python/"/>
      <url>/blog/2018-04-10/late-binding-of-Python/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="延迟绑定-late-binding-闭包"><a href="#延迟绑定-late-binding-闭包" class="headerlink" title="延迟绑定(late binding)闭包"></a>延迟绑定(<code>late binding</code>)闭包</h1><p><code>Python</code> 使用中一个常见的困惑是 <code>Python</code> 在闭包(或在周围全局作用域（<code>surrounding global scope</code>）)中绑定变量的方式。<br><a id="more"></a><br>你所写的函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_expression</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">lambda</span> n: n*i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure></p><p>你所期望的：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print([mult(<span class="number">10</span>) <span class="keyword">for</span> mult <span class="keyword">in</span> multi_expression()])</span><br></pre></td></tr></table></figure></p><p>一个包含五个函数返回值的列表，每个函数有它们自己的封闭变量 <code>i</code> 乘以它们的参数，得到:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br></pre></td></tr></table></figure></p><p>而实际结果是：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>]</span><br></pre></td></tr></table></figure></p><p>创建了五个函数，它们全都是 <code>4</code> 乘以 <code>n</code> 。<br><code>Python</code> 的闭包是<em>迟绑定</em> 。这意味着闭包中用到的变量的值是在内部函数被调用时查询得到的。<br>在这里, 每当调用<em>任何</em>函数返回时, <code>i</code> 的值是调用时在周围作用域（ <code>surrounding scope</code>）中查询到的。到那个时候，循环已经完成， <code>i</code> 的值最终变成 <code>4</code> 。<br>关于这个陷阱有一个普遍严重的误解，它很容易被甩锅给 <code>Python</code> 的 <a href="http://docs.python.org/reference/expressions.html#lambda" target="_blank" rel="noopener">lambda</a>表达式。实际上， <code>lambda</code> 表达式是被冤枉滴。我们尝试把它改写成普通函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_func</span><span class="params">()</span>:</span></span><br><span class="line">    foo = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> n * i</span><br><span class="line">        foo.append(func)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> foo</span><br></pre></td></tr></table></figure></p><h2 id="为了实现目标，你应该这样"><a href="#为了实现目标，你应该这样" class="headerlink" title="为了实现目标，你应该这样"></a>为了实现目标，你应该这样</h2><ol><li>最一般的解决方案可以说是有点取巧（ <code>hack</code> ）。由于 <code>Python</code> 拥有在前文提到的为函数默认参数赋值的行为（参见 <a href="http://docs.python-guide.org/en/latest/writing/gotchas/#default-args" target="_blank" rel="noopener">可变默认参数</a> ）,你可以像下面这样创建一个立即绑定参数的闭包：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_expression_hack</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">lambda</span> n, i=i: n * i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]     <span class="comment"># 此处用法参见《Python Cookbook》7.7 匿名函数捕获变量值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print([func(<span class="number">10</span>) <span class="keyword">for</span> func <span class="keyword">in</span> multi_expression_hack()])</span><br></pre></td></tr></table></figure><ol><li>或者，你可以使用 <code>functools.partial</code> 函数（偏函数）：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [partial(mul, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print([func(<span class="number">10</span>) <span class="keyword">for</span> func <span class="keyword">in</span> partial_func()])</span><br></pre></td></tr></table></figure><ol><li>优雅的写法，直接用生成器推导式：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_expression</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">lambda</span> n: n * i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print([gen(<span class="number">10</span>) <span class="keyword">for</span> gen <span class="keyword">in</span> gen_expression()])</span><br></pre></td></tr></table></figure><ol><li>利用 <code>yield</code> 的惰性求值思想编写生成器函数：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">lambda</span> n: i * n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print([gen(<span class="number">10</span>) <span class="keyword">for</span> gen <span class="keyword">in</span> gen_func()])</span><br></pre></td></tr></table></figure><h2 id="当陷阱不是一个陷阱"><a href="#当陷阱不是一个陷阱" class="headerlink" title="当陷阱不是一个陷阱"></a>当陷阱不是一个陷阱</h2><p>有时, 你预期闭包是这样的（迟绑定的表现形式）。延迟绑定在多数情况下是正常的。不幸的是, 循环创建独特的函数可能会导致未知的小问题。</p><h2 id="派森多一点"><a href="#派森多一点" class="headerlink" title="派森多一点"></a>派森多一点</h2><p>关于生成器的惰性求值，我们可以看点简单的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(m_num, m_gen_num)</span>:</span></span><br><span class="line">    base = gen(m_gen_num)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(m_num):</span><br><span class="line">        base = (add(i, n) <span class="keyword">for</span> i <span class="keyword">in</span> base)</span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num = <span class="number">5</span></span><br><span class="line">    gen_num = <span class="number">10</span></span><br><span class="line">    print(list(main(num, gen_num)))</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>]</span><br></pre></td></tr></table></figure><p>如果我们对之前改写的<code>multi_func()</code>函数再稍微改写一下，让内部函数传值<code>*args</code>会怎么样？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_func_starred</span><span class="params">()</span>:</span></span><br><span class="line">    foo = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*n)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> n * i</span><br><span class="line">        foo.append(func)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print([func(<span class="number">10</span>) <span class="keyword">for</span> func <span class="keyword">in</span> multi_func_starred()])</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>), (<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>), (<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>), (<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>), (<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p>实际上，<code>*args</code>相当于一个生成器推导式，这点很容易验证：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_expression_starred</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># print(type(lambda *n: n*i for i in range(5)))     # 去掉注释 &gt;&gt;&gt;: &lt;class 'generator'&gt;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">lambda</span> *n: n * i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print([func(<span class="number">10</span>) <span class="keyword">for</span> func <span class="keyword">in</span> multi_expression_starred()])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 延迟绑定 </tag>
            
            <tag> 生成器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 环境管理介绍</title>
      <link href="/blog/2018-01-18/python-env-introduce/"/>
      <url>/blog/2018-01-18/python-env-introduce/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv 等工具的区别与介绍。<br>项目开发中可能需要用到不同版本的<code>Python</code>及相关的开发环境。比如<code>Python2</code>及<code>Python3</code>，或者有的项目需要 <code>Django1.5</code> ，有的需要<code>2.0</code>，这个时候借助一些工具，往往可以达到事半功倍的效果。</p><a id="more"></a><p><img src="https://farm5.staticflickr.com/4290/35294660055_42c02b2316_k_d.jpg" alt="Python"></p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><h3 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h3><p><code>virtualenv</code>是一个非常流行的工具，为<code>Python</code>库创建独立的<code>Python</code>环境。如果你不熟悉这个工具，我强烈建议你学习它，因为它是一个非常有用的工具，我将在这个答案的其余部分对此进行比较。</p><p>它通过在一个目录（例如：<code>env/</code>）中安装一堆文件，然后修改<code>PATH</code>环境变量来为自定义<code>bin</code>目录（例如：<code>env/bin/</code>）添加前缀。 <code>python</code>或<code>python3</code>二进制文件的精确拷贝会被放置在这个目录中，但<code>Python</code>被编程为首先在环境目录中查找相对于其路径的库。它不是<code>Python</code>标准库的一部分，但是获得<code>PyPA</code>（Python Packaging Authority）正式称赞。激活之后，你就可以使用<code>pip</code>在虚拟环境中安装软件包。</p><h4 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h4><p><code>virtualenvwrapper</code>是<code>virtualenv</code>的一组扩展（参见<a href="http://virtualenvwrapper.readthedocs.io/en/latest/" target="_blank" rel="noopener">文档</a>）。它提供例如<code>mkvirtualenv</code>、<code>lssitepackages</code>这样的命令，特别是<code>workon</code>命令，它可以在不同的<code>virtualenv</code>目录之间切换。如果你想要多个<code>virtualenv</code>目录，这个工具特别有用。</p><h3 id="pyenv"><a href="#pyenv" class="headerlink" title="pyenv"></a>pyenv</h3><p><code>pyenv</code>是<code>Python</code>的<strong>版本</strong>管理器,用于隔离<code>Python</code>版本。例如，你可能想要针对<code>Python 2.6</code>,<code>2.7</code>,<code>3.3</code>,<code>3.4</code>和<code>3.5</code>测试你的代码，因此你需要在不同<code>Python</code>版本之间进行切换。一旦激活，它就会在<code>PATH</code>环境变量前加上<code>~/.pyenv/shims</code>，其中有一些与<code>Python</code>命令（<code>python</code>，<code>pip</code>）匹配的特殊文件。这些不是<code>Python</code>提供的命令的副本;它们是根据<code>PYENV_VERSION</code>环境变量或<code>.python-version</code>文件或<code>~/.pyenv/version</code>文件决定运行哪个版本的<code>Python</code>的特殊脚本。 <code>pyenv</code>也使下载和安装多个<code>Python</code>版本的过程变得更简单，使用命令<code>pyenv install</code>即可。</p><h4 id="pyenv-virtualenv"><a href="#pyenv-virtualenv" class="headerlink" title="pyenv-virtualenv"></a>pyenv-virtualenv</h4><p><code>pyenv-virtualenv</code>是<code>pyenv</code>的一个插件，和<code>pyenv</code>一样，允许你在同一时间方便地使用<code>pyenv</code>和<code>virtualenv</code>。但是，如果你使用<code>Python 3.3</code>或更高版本，则<code>pyenv-virtualenv</code>会尝试运行<code>python -m venv</code>（如果可用），而不是<code>virtualenv</code>。如果你不想使用便利功能，则可以搭配使用<code>virtualenv</code>和<code>pyenv</code>而不使用<code>pyenv-virtualenv</code>。</p><h4 id="pyenv-virtualenvwrapper"><a href="#pyenv-virtualenvwrapper" class="headerlink" title="pyenv-virtualenvwrapper"></a>pyenv-virtualenvwrapper</h4><p><code>pyenv-virtualenvwrapper</code>是<code>pyenv</code>的一个插件，可以很方便地将<code>virtualenvwrapper</code>集成到<code>pyenv</code>中。</p><h3 id="pipenv"><a href="#pipenv" class="headerlink" title="pipenv"></a>pipenv</h3><p><code>pipenv</code>是<code>Python</code>的<strong>包</strong>管理器。由<code>Kennetth Reitz</code>（<code>requests</code>的作者）编写维护，是我们上面提到的这些项目里面最新的。它的目标是在命令行中将<code>Pipfile</code>、<code>pip</code>和<code>virtualenv</code>合并为一个命令。</p><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="pyvenv"><a href="#pyvenv" class="headerlink" title="pyvenv"></a>pyvenv</h3><p><code>pyvenv</code>是一个<code>Python 3</code>附带的脚本，但在<strong>Python 3.6 中被弃用</strong>，（参见<a href="https://docs.python.org/dev/whatsnew/3.6.html#id8" target="_blank" rel="noopener">这里</a>）因为它有问题（暂且不说名字还容易造成混淆）。在<code>Python 3.6+</code>中，实际上等价于命令<code>python3 -m venv</code>。</p><h3 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h3><p><code>venv</code>是<code>Python 3</code>附带的一个包，你可以使用<code>python3 -m venv</code>运行（虽然由于某些原因，一些发行版把它分离成一个单独的发行包，比如<code>Ubuntu / Debian</code>上的<code>python3-venv</code>）。它的作用与<code>virtualen</code>v 相似，工作方式也非常相似，但不需要复制<code>Python</code>二进制文件（<code>Windows</code>下除外）。如果你的代码不需要支持<code>Python 2</code>，可以使用它。在撰写本文时，<code>Python</code>社区似乎对<code>virtualenv</code>感到满意，<code>venv</code>相对来说比较小众。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1.<a href="https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe" target="_blank" rel="noopener">Python - What is the difference between venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv, etc? - Stack Overflow</a></p><p>2.<a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/" target="_blank" rel="noopener">Pipenv &amp; Virtual Environments — The Hitchhiker’s Guide to Python</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 环境下配置 DRBD</title>
      <link href="/blog/2018-01-11/how-to-configure-drbd-on-CentOS7/"/>
      <url>/blog/2018-01-11/how-to-configure-drbd-on-CentOS7/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文主要记录<code>DRBD</code>的配置过程和功能验证。<br><a id="more"></a></p><p>本文使用<code>64</code>位<code>CentOS</code>，基本环境：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+-----------------------+              |               +----------------------+</span><br><span class="line">| [ DRBD_A (Server#1) ] | 10.10.17.18  |  10.10.17.19  | [DRBD_B (Server#2) ] |</span><br><span class="line">|       node01          +--------------+---------------+         node02       |</span><br><span class="line">|                       |                              |                      |</span><br><span class="line">+-----------------------+                              +----------------------+</span><br><span class="line"></span><br><span class="line">DRBD 服务器A ：ip:10.10.17.18，hostname：DRBD_A</span><br><span class="line">DRBD 服务器B ：ip:10.10.17.19，hostname：DRBD_B</span><br></pre></td></tr></table></figure><h2 id="建立磁盘分区"><a href="#建立磁盘分区" class="headerlink" title="建立磁盘分区"></a>建立磁盘分区</h2><ul><li>分区之前</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@DRBD_A ~]# lsblk      # 查询块设备信息</span><br><span class="line">NAME                  MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">fd0                     2:0    1    4K  0 disk</span><br><span class="line">sda                     8:0    0   16G  0 disk</span><br><span class="line">├─sda1                  8:1    0  500M  0 part /boot</span><br><span class="line">└─sda2                  8:2    0 15.5G  0 part</span><br><span class="line">  ├─centos_bogon-root 253:0    0 13.9G  0 lvm  /</span><br><span class="line">  └─centos_bogon-swap 253:1    0  1.6G  0 lvm  [SWAP]</span><br><span class="line">sdb                     8:16   0    5G  0 disk</span><br><span class="line">└─StorPool-SANLun10   253:2    0    2G  0 lvm</span><br><span class="line">sr0                    11:0    1 1024M  0 rom</span><br><span class="line">drbd0                 147:0    0    2G  1 disk</span><br></pre></td></tr></table></figure><ul><li>进行分区</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@DRBD_A ~]# fdisk /dev/sdb     # 在sdb上新建分区</span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">Building a new DOS disklabel with disk identifier 0xb25d5d26.</span><br><span class="line"></span><br><span class="line">Command (m for help): n         #  新建</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p):</span><br><span class="line">Using default response p</span><br><span class="line">Partition number (1-4, default 1):</span><br><span class="line">First sector (2048-10485759, default 2048):</span><br><span class="line">Using default value 2048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-10485759, default 10485759): +1G</span><br><span class="line">Partition 1 of type Linux and of size 1 GiB is set</span><br><span class="line"></span><br><span class="line">Command (m for help): w         #  写入</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure><ul><li>分区之后</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@DRBD_A ~]# lsblk</span><br><span class="line">NAME                  MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">fd0                     2:0    1    4K  0 disk</span><br><span class="line">sda                     8:0    0   16G  0 disk</span><br><span class="line">├─sda1                  8:1    0  500M  0 part /boot</span><br><span class="line">└─sda2                  8:2    0 15.5G  0 part</span><br><span class="line">  ├─centos_bogon-root 253:0    0 13.9G  0 lvm  /</span><br><span class="line">  └─centos_bogon-swap 253:1    0  1.6G  0 lvm  [SWAP]</span><br><span class="line">sdb                     8:16   0    5G  0 disk</span><br><span class="line">├─sdb1                  8:17   0    1G  0 part      # 新分区</span><br><span class="line">└─StorPool-SANLun10   253:2    0    2G  0 lvm</span><br><span class="line">sr0                    11:0    1 1024M  0 rom</span><br><span class="line">drbd0                 147:0    0    2G  0 disk /media</span><br></pre></td></tr></table></figure><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><h3 id="更改-DRBD-全局配置"><a href="#更改-DRBD-全局配置" class="headerlink" title="更改 DRBD 全局配置"></a>更改 DRBD 全局配置</h3><p>首先根据需求更改<code>DRBD</code>全局配置<code>/etc/drbd.d/global_common.conf</code>:</p><p>此处可参阅另一篇文章：<a href="https://imoyao.github.io/blog/2017-09-11/Record_of_drbd/#global-common-conf配置（示例）">DRBD 全局配置</a></p><h3 id="创建DRBD配置文件"><a href="#创建DRBD配置文件" class="headerlink" title="创建DRBD配置文件"></a>创建<code>DRBD</code>配置文件</h3><p>由于<code>DRBD</code>是基于块设备的存储复制解决方案，所以此处使用<code>Lun</code>作为演示。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi r0.res</span><br><span class="line">resource r0 &#123;</span><br><span class="line">    # DRBD device</span><br><span class="line">    device /dev/drbd0;</span><br><span class="line">    # block device</span><br><span class="line">    disk /dev/StorPool/SANLun10;    # 磁盘路径，若为disk则修改为/dev/sdb1</span><br><span class="line">    meta-disk internal;</span><br><span class="line">    on DRBD_A &#123;</span><br><span class="line">        # IP address:port</span><br><span class="line">        address 10.10.17.18:7788;</span><br><span class="line">    &#125;</span><br><span class="line">    on DRBD_B &#123;</span><br><span class="line">        address 10.10.17.19:7788;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意：</code>本机主机名(<code>hostname</code>)和地址(<code>ip</code>)必须严格按照真实情况配置，两边<code>.res</code>文件内容尽量保持一致。</p><p>配置文件创建完成之后，在两个服务器上分别执行如下命令，创建<code>DRBD</code>资源，当然你也可以通过<code>scp</code>把配置文件拷过去，然后执行相关命令。</p><p>其中上述配置文件的 meta-disk 有三种记录方式：internal/device/device[index_num]。其中不管是哪种方式，metadata 存放的分区不能格式化，哪怕使用 internal 时 metadata 和一般 data 在同一个分区也不能格式化该分区。</p><p>internal 是将元数据也写入到数据分区的尾部，即数据和元数据同分区。如果指定的 device 没有给定 index 时，则表示元数据存储到该设备中。如果某节点指定 device[index_num]，那么指定几次元数据分区索引就必须大于 128M 的几倍，例如上述文件中 drbd1.longshuai.com 节点指定了/dev/sdb1[0]，那么 sdb1 就必须大于 128M，如果此时其他资源的节点也指定了同一台服务器的/dev/sdb1[1]，则指定了两次就必须大于 256M。指定为 internal 和 device 时，元数据区的大小是 drbd 自行计算的。<br>上面 index 的说法来自<a href="http://www.cnblogs.com/f-ck-need-u/p/8678883.html#1-drbd-" target="_blank" rel="noopener">这里</a>，具体没有实际验证。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm create-md r0</span><br></pre></td></tr></table></figure><p>然后启动 DRBD：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm up r0</span><br></pre></td></tr></table></figure><p>我在测试时没有操作下一步操作，但是数据也可以完成同步。查询了一下，网上说<code>drbdadm up</code>这个命令相当于<code>attach</code>、<code>syncer</code>、<code>connect</code>的总集合。但是后台使用<code>systemctl status drbd</code>获取到的状态还是<code>inactive (dead)</code>，欢迎大家提出自己的看法。</p><hr><p>在两个服务器上分别启动<code>DRBD</code>服务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/drbd start</span><br></pre></td></tr></table></figure><hr><p>把<code>DRBD_A</code>做为主服务器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 无数据时</span></span><br><span class="line">drbdadm primary r0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 有数据时，把本端作为primary端，本地数据分发到其他节点。</span></span><br><span class="line">drbdadm -- --overwrite-data-of-peer primary r0</span><br></pre></td></tr></table></figure><p>使用如下命令查看<code>DRBD</code>服务的状态信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/drbd status</span><br><span class="line"><span class="meta">#</span><span class="bash">或者</span></span><br><span class="line">drbd-overview</span><br></pre></td></tr></table></figure><p>此时，写入<code>DRBD_A</code>端(<code>/dev/drbd1</code>)的数据都会同步到<code>DRBD_B</code>端。</p><h2 id="测试数据同步"><a href="#测试数据同步" class="headerlink" title="测试数据同步"></a>测试数据同步</h2><h3 id="Primary端"><a href="#Primary端" class="headerlink" title="Primary端"></a><code>Primary</code>端</h3><ul><li>格式化<code>drbd</code></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfs.xfs /dev/drbd0</span><br></pre></td></tr></table></figure><ul><li>挂载设备</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount /dev/drbd0 /media</span><br></pre></td></tr></table></figure><ul><li>写入数据</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /media/</span><br><span class="line">mkdir drbd_test</span><br><span class="line">cd drbd_test/</span><br><span class="line">echo "hello World" &gt; hello.txt</span><br></pre></td></tr></table></figure><ul><li>卸载设备</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">umount /media</span><br></pre></td></tr></table></figure><ul><li>本端降级</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm secondary r0</span><br></pre></td></tr></table></figure><h3 id="Secondary端"><a href="#Secondary端" class="headerlink" title="Secondary端"></a><code>Secondary</code>端</h3><ul><li>从端升主</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm primary r0</span><br></pre></td></tr></table></figure><ul><li>挂载设备</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount /dev/drbd0 /media</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 此时从端不需要再次格式化，否则数据丢失。</p><ul><li>验证数据</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /media</span><br><span class="line">ls</span><br><span class="line">cat ./drbd_test/hello.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回</span></span><br><span class="line">hello World</span><br></pre></td></tr></table></figure><p>参考来源</p><ul><li><a href="https://www.server-world.info/en/note?os=CentOS_7&amp;p=drbd&amp;f=2" target="_blank" rel="noopener">CentOS 7 : DRBD : Configure : Server World</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DRBD </tag>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 下源码安装 DRBD</title>
      <link href="/blog/2018-01-11/how-to-install-drbd-on-CentOS7/"/>
      <url>/blog/2018-01-11/how-to-install-drbd-on-CentOS7/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>最近开发中又要用到<code>DRBD</code>做远程复制的功能，网上搜到很多都是<code>yum</code>安装的办法，这里记录一下源码安装的办法。<br><a id="more"></a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><h3 id="关闭-SELinux"><a href="#关闭-SELinux" class="headerlink" title="关闭 SELinux"></a>关闭 SELinux</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i -e "s/=enforcing/=disabled/g" /etc/selinux/config</span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y update </span><br><span class="line">yum -y install gcc make automake autoconf libxslt libxslt-devel flex rpm-build wget</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 安装<code>kernel-devel</code>一定要和<code>uname -r</code>获取结果一致。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -q kernel-devel</span><br><span class="line">uname -r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.10.0-327.el7.x86_64</span></span><br></pre></td></tr></table></figure><p>返回的内核版本应当一致，否则建议用本地源安装<code>kernel-devel</code>。</p><h2 id="下载-解压源码"><a href="#下载-解压源码" class="headerlink" title="下载/解压源码"></a>下载/解压源码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">官方地址：https://www.linbit.com/en/drbd-community/drbd-download/</span><br><span class="line">旧版本：http://www.linbit.com/en/drbd-community/old-releases/</span><br><span class="line">MORE：http://www.linbit.com/www.linbit.com/downloads/drbd/</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 在<code>DRBD 8.4.3</code>(?)以上版本，对<code>drbd</code>和<code>utils</code>做了拆分，需要分别进行下载。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://xxx.tar.gz</span><br></pre></td></tr></table></figure><p>当然，如果需要你也可以通过我的分享下载编译好的<code>rpm</code>包（示例版本）：</p><blockquote><p>链接:  <a href="https://pan.baidu.com/s/1huncgDI" target="_blank" rel="noopener">https://pan.baidu.com/s/1huncgDI</a>       密码:  b41i</p></blockquote><h3 id="解压下载的两个tar包"><a href="#解压下载的两个tar包" class="headerlink" title="解压下载的两个tar包"></a>解压下载的两个<code>tar</code>包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf drbd-8.*.tar.gz</span><br><span class="line">tar -zxvf drbd-utils-*.tar.gz</span><br></pre></td></tr></table></figure><h2 id="编译rpm"><a href="#编译rpm" class="headerlink" title="编译rpm"></a>编译<code>rpm</code></h2><h3 id="创建构建DRBD需要的目录"><a href="#创建构建DRBD需要的目录" class="headerlink" title="创建构建DRBD需要的目录"></a>创建构建<code>DRBD</code>需要的目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p rpmbuild/&#123;BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS&#125;</span><br></pre></td></tr></table></figure><h3 id="编译DRBD"><a href="#编译DRBD" class="headerlink" title="编译DRBD"></a>编译<code>DRBD</code></h3><h4 id="制作-rpm-包"><a href="#制作-rpm-包" class="headerlink" title="制作 rpm 包"></a>制作 <code>rpm</code> 包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd drbd-8.4.5/</span><br><span class="line">make clean</span><br><span class="line">make km-rpm KDIR=/usr/src/kernels/`uname -r`/       # 启用内核模块 自动识别内核版本    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You have now:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /root/rpmbuild/RPMS/x86_64/drbd-km-3.10.0_693.11.6.el7.x86_64-8.4.5-1.x86_64.rpm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /root/rpmbuild/RPMS/x86_64/drbd-km-debuginfo-8.4.5-1.x86_64.rpmmakeinsta</span></span><br></pre></td></tr></table></figure><hr><h4 id="直接编译安装"><a href="#直接编译安装" class="headerlink" title="直接编译安装"></a>直接编译安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># drbd模块</span></span></span><br><span class="line"></span><br><span class="line">cd drbd</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">lsmod|grep drbd</span><br><span class="line">cp drbd.ko /lib/modules/`uname -r`/kernel/lib/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 安装模块</span></span></span><br><span class="line">modprobe drbd</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 验证drbd模块是否加载（部分系统默认有该模块）</span></span></span><br><span class="line">lsmod|grep drbd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> drbd                  364858  0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> libcrc32c              12644  4 xfs,drbd,nf_nat,nf_conntrack</span></span><br></pre></td></tr></table></figure><hr><h3 id="编译-drbd-utils-组件"><a href="#编译-drbd-utils-组件" class="headerlink" title="编译 drbd-utils 组件"></a>编译 drbd-utils 组件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ../../drbd-utils-8.9.0/   </span><br><span class="line">./configure</span><br><span class="line">make rpm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br><span class="line">+ exit 0</span><br><span class="line">You have now:</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-km-3.10.0_693.11.6.el7.x86_64-8.4.5-1.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-km-debuginfo-8.4.5-1.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-8.9.0-1.el7.centos.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-utils-8.9.0-1.el7.centos.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-xen-8.9.0-1.el7.centos.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-udev-8.9.0-1.el7.centos.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-pacemaker-8.9.0-1.el7.centos.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-bash-completion-8.9.0-1.el7.centos.x86_64.rpm</span><br><span class="line">/root/rpmbuild/RPMS/x86_64/drbd-debuginfo-8.9.0-1.el7.centos.x86_64.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br></pre></td></tr></table></figure><p>此时有可能提示错误如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/xsltproc \</span><br><span class="line">        --xinclude \</span><br><span class="line">        http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl drbdsetup.xml</span><br><span class="line">error : Operation in progress</span><br><span class="line">warning: failed to load external entity "http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl"</span><br><span class="line">cannot parse http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl</span><br><span class="line">make[1]: *** [drbdsetup.8] Error 4</span><br></pre></td></tr></table></figure><p>提示有一个地址文件没能找到，解决方法：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install docbook-style-xsl</span><br></pre></td></tr></table></figure><p>TODO: 此处暂未找到别的解决方法，欢迎读者留言。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装编译生成的文件"><a href="#安装编译生成的文件" class="headerlink" title="安装编译生成的文件"></a>安装编译生成的文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root/rpmbuild/RPMS/x86_64/</span><br><span class="line">rpm -ivh drbd-* --force</span><br></pre></td></tr></table></figure><h3 id="加载模块（参见分割线部分）"><a href="#加载模块（参见分割线部分）" class="headerlink" title="加载模块（参见分割线部分）"></a>加载模块（参见分割线部分）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe drbd</span><br></pre></td></tr></table></figure><h2 id="验证安装结果"><a href="#验证安装结果" class="headerlink" title="验证安装结果"></a>验证安装结果</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsmod|grep drbd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回（`depends` 可能略有不同）：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> drbd                  373375  4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> libcrc32c              12644  2 xfs,drbd</span></span><br><span class="line"></span><br><span class="line">drbd-overview  </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下两者返回稍有不同    </span></span><br><span class="line">cat /proc/drbd</span><br><span class="line">drbdadm -V</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回</span></span><br><span class="line"></span><br><span class="line">DRBDADM_BUILDTAG=GIT-hash:\ 79677f4***7ca6b99929\ build\ by\ root@imoyao\,\ 2018-01-06\ 14:25:03</span><br><span class="line">DRBDADM_API_VERSION=1</span><br><span class="line">DRBD_KERNEL_VERSION_CODE=0x080405</span><br><span class="line">DRBDADM_VERSION_CODE=0x080900</span><br><span class="line">DRBDADM_VERSION=8.9.0</span><br></pre></td></tr></table></figure><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><ul><li><p><a href="https://www.server-world.info/en/note?os=CentOS_7&amp;p=drbd&amp;f=1" target="_blank" rel="noopener">CentOS 7 : DRBD : Install : Server World</a></p></li><li><p><a href="http://blog.topspeedsnail.com/archives/8381" target="_blank" rel="noopener">CentOS 安装配置 DRBD – WTF Daily Blog</a></p></li><li><p><a href="http://www.3mu.me/centos%E4%B8%8B%E5%AE%9E%E7%8E%B0heartbeatdrbdmysql%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87%E7%A1%AC%E4%BB%B6%E6%95%85%E9%9A%9C%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E9%AB%98%E5%8F%AF%E7%94%A8ha/#respond" target="_blank" rel="noopener">CentOS 下实现 Heartbeat+DRBD+MySQL 双机热备硬件故障自动切换高可用(HA)方案 | 三木的人生——3mu.me</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DRBD </tag>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🐍PyTricks | Python 技巧写法记录</title>
      <link href="/blog/2018-01-02/pytricks-collection/"/>
      <url>/blog/2018-01-02/pytricks-collection/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>写出<code>Pythonic</code>的代码应该是每个<code>Pythonista</code>的基本追求，本文主要记录在开发中遇到的一些有关<code>Python</code>技巧。</p><a id="more"></a><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li><code>JSON</code>字典内按照某个键值排序</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: alist = [&#123;<span class="string">'create'</span>: <span class="string">'2017-12-28 11:05:48'</span>, <span class="string">'id'</span>: <span class="string">'0_1'</span>, <span class="string">'path'</span>: <span class="string">'foo.py'</span>, <span class="string">'size'</span>: <span class="number">0</span>&#125;,</span><br><span class="line">   ....:  &#123;<span class="string">'create'</span>: <span class="string">'2017-12-28 11:00:29'</span>, <span class="string">'id'</span>: <span class="string">'0_2'</span>, <span class="string">'path'</span>: <span class="string">'bar.py'</span>, <span class="string">'size'</span>: <span class="number">0</span>&#125;,</span><br><span class="line">   ....:  &#123;<span class="string">'create'</span>: <span class="string">'2017-12-28 11:05:55'</span>, <span class="string">'id'</span>: <span class="string">'0_3'</span>, <span class="string">'path'</span>: <span class="string">'baz.py'</span>, <span class="string">'size'</span>: <span class="number">0</span>&#125;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: alist.sort(key=<span class="keyword">lambda</span> x:x[<span class="string">'create'</span>])    <span class="comment"># 按照创建时间排序 </span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: alist</span><br><span class="line">Out[<span class="number">17</span>]:``</span><br><span class="line">[&#123;<span class="string">'create'</span>: <span class="string">'2017-12-28 11:00:29'</span>, <span class="string">'id'</span>: <span class="string">'0_2'</span>, <span class="string">'path'</span>: <span class="string">'bar.py'</span>, <span class="string">'size'</span>: <span class="number">0</span>&#125;,</span><br><span class="line"> &#123;<span class="string">'create'</span>: <span class="string">'2017-12-28 11:05:48'</span>, <span class="string">'id'</span>: <span class="string">'0_1'</span>, <span class="string">'path'</span>: <span class="string">'foo.py'</span>, <span class="string">'size'</span>: <span class="number">0</span>&#125;,</span><br><span class="line"> &#123;<span class="string">'create'</span>: <span class="string">'2017-12-28 11:05:55'</span>, <span class="string">'id'</span>: <span class="string">'0_3'</span>, <span class="string">'path'</span>: <span class="string">'baz.py'</span>, <span class="string">'size'</span>: <span class="number">0</span>&#125;]</span><br></pre></td></tr></table></figure><ul><li>字典排序</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: languages = &#123;<span class="string">'JAVA'</span>:<span class="number">15</span>,<span class="string">'Python'</span>:<span class="number">12</span>,<span class="string">'Go'</span>:<span class="number">13</span>,<span class="string">'PHP'</span>:<span class="number">14</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: sorted(languages.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])        <span class="comment"># 以key排序</span></span><br><span class="line">Out[<span class="number">35</span>]: [(<span class="string">'Go'</span>, <span class="number">13</span>), (<span class="string">'JAVA'</span>, <span class="number">15</span>), (<span class="string">'PHP'</span>, <span class="number">12</span>), (<span class="string">'Python'</span>, <span class="number">12</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: sorted(languages.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])        <span class="comment"># 以value排序</span></span><br><span class="line">Out[<span class="number">36</span>]: [(<span class="string">'Python'</span>, <span class="number">12</span>), (<span class="string">'PHP'</span>, <span class="number">12</span>), (<span class="string">'Go'</span>, <span class="number">13</span>), (<span class="string">'JAVA'</span>, <span class="number">15</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: sorted(languages.items(),key=<span class="keyword">lambda</span> x:-x[<span class="number">1</span>])       <span class="comment"># 以value倒序</span></span><br><span class="line">Out[<span class="number">37</span>]: [(<span class="string">'JAVA'</span>, <span class="number">15</span>), (<span class="string">'Go'</span>, <span class="number">13</span>), (<span class="string">'Python'</span>, <span class="number">12</span>), (<span class="string">'PHP'</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>sort()</code>与<code>sorted()</code>的区别，前者返回值为<code>None</code>，后者可重新赋值；</p><p>参考阅读</p><ul><li><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP 8 – Style Guide for Python Code | Python.org</a></li><li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/" target="_blank" rel="noopener">Python 风格指南 — Google 开源项目风格指南</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017 年过去了，我很怀念它</title>
      <link href="/blog/2017-12-28/Annual-record-of-2017/"/>
      <url>/blog/2017-12-28/Annual-record-of-2017/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>马上毕业三年，从前途迷茫,自我否定到逐渐看到一点努力的方向，给自己做一个简单的记录还是必要的。</p><a id="more"></a><p>年初，入职一家北大数学系某研究生创办的农业科技公司。第一次看到所谓的创业公司拿着高校办公计算机当作自己办公用品使用，也是第一次看见凌晨两点钟的北京。也曾梦想跟着自带光芒的人干一番大事业，却不料在短暂的时间之后就被干掉。抛开女老板不懂技术、没技术大牛带、技术团队就一草台班子，归根结底还得怪自己手艺不精。所以过年回家那段时间一直挺失落的，整个人可以说是相当「愁云惨淡万里凝」了。幸好还有高中的女同学 Y 的暖心安慰，才不至于对生活失去信心。回忆过往，内心泪流满面的同时对朋友们的鼓励表示默默感谢。</p><p>过年来还算顺利，在经过漫长而短暂的差不多半个月面试之后终于进入现在的公司。对于一个没有工作的人，可以说每一天都很煎熬，而且面试中带来的挫败感会逐渐让人对自己丧失信心。庆幸的是，柳暗花明之后，终于收到三份<code>Offer</code>，本着向钱看齐的指导方针选择了现在的公司。虽然谈不上多好，但是快饿死的人是没有资格挑食的，最重要还是先养活自己。</p><p>回顾在新公司的近一年时间，从开始的什么两眼一抹黑到现在可以实现新增功能的独立完成，难免唏嘘。当然，也暴露出自己在技术方面的欠缺：前端<code>JavaScript</code>有时需要同事帮助才可以搞定，对<code>Python</code>中的系统编程了解不够深入，目前陷入一种困难的搞不定，简单的又不屑做的尴尬境地。只能送自己一句革命仍未成功，同志仍需努力。</p><p>了解一个人最快的方式是：和一个男性发生金钱关系，和一个女性发生肉体关系。异性间的肉体关系近期我多半是不及见了，倒是可以聊聊今年和别人之间钱的问题。大概是 6 月的时候，某大学同学联系我说和室友合租住不下去了，问我是否能够凑合一下，租金均摊。虽然我习惯独居，但是考虑到应该也不会太久就同意了。后来住到一块才知道是因为他晚上整宿磨牙被室友赶出来了。住了不到两个月他找到房子说要搬走，房钱大概算了 <code>1000</code> 多点，结果给我来了句「能不能抹个零，就当请我抽包烟？」我脸上笑嘻嘻，心里<code>MMP</code>地拒绝了他。刚好他那时才找到工作，于是又说宽限他十多天，月初发工资就还我。到了月初，我以为是忘了，10 号左右要的时候说花光了，下个月吧。下个月再要，又说什么爷爷去世，钱都用来料理后事了，事情处理完回去想办法。到了月底，我也没等到其想到的办法。电影里面说「成年人的崩溃都是从借钱开始的」，而我要说成年人的崩溃都是从要钱开始的。一个月薪 13K 的欠别人 1.3K 还要拖那么久，最后到了 10 月发工资才给我。我的内心只能响起梁朝伟的那句「明明说好三年，三年之后又三年，三年之后又三年，都快十年了老大！」当然这还不是最奇葩的，最奇葩的是还钱之后，居然不联系我了。我想，大抵是因为我连 1000 块钱都要得罪人家了吧？毕竟，人家可能从来没想着住同学租的房子还要给钱。其实，我想问一句「哎，<strong>搬家时说好京东下单之后就还我的鼠标用坏了没呀</strong>？」</p><p>再一个就是今年父母开始时不时暗示该找个女朋友了，家人的关心也不无道理，没有组织关心的人是得提前考虑自己的个人问题。难堪的是虽然我本人自觉女生缘不错，但是可能女人缘实在是差了点，自从 14 年和前女友分手之后，至今还属于漫长的空窗期。而在这个狼多肉少的时代，项目组中的能够激发两性情感的妹子们都早早地被别人捷足先登了。从个人层面来说倒也不是着急，但是作为一个非「不婚族」个体，这个问题或许是得认真考虑一下啦。</p><p>还有最近有件比较困扰我的事，因为我极度不喜欢运动，所以一年来体重极速飙升，这真是一件残酷而危险的事情，希望能够克服困难，通过节食加锻炼控制在可接受的范围之内。</p><p><img src="/images/letter-from-PanXiao.jpg" alt="潘晓来信"></p><center><a href="https://finance.sina.com.cn/roll/2019-02-12/doc-ihrfqzka5080346.shtml" target="_blank" rel="noopener">潘晓来信</a></center><p>每个时代，个体都有各自的无奈和苦难。裹挟在西二旗早高峰人流中意气风发的少年被岁月早早地盘出了油腻的包浆；回不去的家乡和触不到的梦想如烧红的铁板的反覆煎熬着身心；高不可攀的房价和日益年迈的父母也开始往人的肩膀上增添重量感。人生的路呵，怎么越走越窄……</p><p>当然，平心而论觉得自己还是很幸运的。在父母的经济支持下来到这边站住脚，起码到北京之后的日子里，结余多过之前的工资，而且也不再像之前做没有技术含量的卑微活计。对这份工作谈不上热爱，也没有改变世界的勇气和能力，目前只希望尽力做好本职工作吧。</p><p>繁华世界，不敢爱慕，不敢憧憬，不知不觉在开心时也小心翼翼。意犹未尽，见好就收。</p><p>絮絮叨叨写了这么些，发现也没啥重点可以突出一下，看来遣词造句能力退化不少。行吧，我满斟烈酒：一杯敬明天，一杯敬过往，给所有<a href="http://www.juzimi.com/ju/3766577" target="_blank" rel="noopener">像我这样的人</a>。</p><blockquote><p>像我这样优秀的人<br>本该灿烂过一生<br>怎么二十多年到头来<br>还在人海里浮沉    </p><p>像我这样聪明的人<br>早就告别了单纯<br>怎么还是用了一段情<br>去换一身伤痕   </p><p>像我这样迷茫的人<br>像我这样寻找的人<br>像我这样碌碌无为的人<br>你还见过多少人<br>像我这样庸俗的人  </p><p>像我这样懦弱的人<br>凡事都要留几分<br>怎么曾经也会为了谁<br>想过奋不顾身   </p><p>你还见过多少人<br>像我这样孤单的人<br>像我这样傻的人<br>像我这样不甘平凡的人<br>像我这样莫名其妙的人   </p></blockquote><div align="right"> <font size="2">以上文字引用略有删改 </font> </div>]]></content>
      
      
      <categories>
          
          <category> 个人日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Storcli 常用管理命令汇总</title>
      <link href="/blog/2017-12-27/storcli-command-share/"/>
      <url>/blog/2017-12-27/storcli-command-share/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>目前<code>LSI RAID</code>卡使用的配置工具主要有：<code>Megaraid Storage Manager</code>（MSM，图形环境）、<code>MegaCLI</code>（字符界面）、<code>StorCLI</code>（字符界面）。其中<code>StorCLI</code>作为<code>MegaCLI</code>后继者整合了<code>LSI</code>和原来<code>3ware</code>的产品支持，兼容<code>MegaCLI</code>命令的同时更加简洁。<a href="https://imoyao.github.io/blog/2017-11-20/megacli_command_share/">前面的文章</a>记录了<code>MegaCli</code>常用管理命令，本篇主要记录<code>StorCLI</code>的使用。</p><a id="more"></a><h2 id="安装Storcli"><a href="#安装Storcli" class="headerlink" title="安装Storcli"></a>安装<code>Storcli</code></h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip ul_avago_storcli_1.18.11_anyos.zip</span><br><span class="line">dpkg -i storcli_all_os/Ubuntu/storcli_1.18.11_all.deb</span><br><span class="line">dpkg -l | grep -i storcli</span><br></pre></td></tr></table></figure><h3 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip ul_avago_storcli_1.18.11_anyos.zip</span><br><span class="line">rpm -ivh storcli_all_os/Linux/storcli-1.18.11-1.noarch.rpm</span><br><span class="line">rpm -qi storcli</span><br><span class="line">ln -s /opt/MegaRAID/storcli/storcli64 /usr/local/bin/storcli</span><br></pre></td></tr></table></figure><h3 id="ESXi-5-5-amp-ESXi-6-0"><a href="#ESXi-5-5-amp-ESXi-6-0" class="headerlink" title="ESXi 5.5 &amp; ESXi 6.0"></a>ESXi 5.5 &amp; ESXi 6.0</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip ul_avago_storcli_1.18.11_anyos.zip</span><br><span class="line">esxcli software vib install -v=vmware-esx-storcli-1.21.06.vib --no-sig-check</span><br><span class="line">ln -s /opt/lsi/storcli/storcli /sbin/storcli</span><br><span class="line">storcli -V</span><br></pre></td></tr></table></figure><h2 id="storcli使用"><a href="#storcli使用" class="headerlink" title="storcli使用"></a><code>storcli</code>使用</h2><p>专有名词解释：</p><p><code>/cx, /vx</code> 表示 <code>Controller/Virtual Drive Number</code>.</p><p><code>/ex, /sx</code>表示 <code>Enclosure/Slot ID</code>.</p><p><code>VD</code>表示 <code>Virtual Drive</code>.</p><p>要输出<code>json</code>格式的返回,在命令行最后添加<code>J</code>.</p><ul><li>固件升级</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx download file=/path/to/firmware.rom</span><br></pre></td></tr></table></figure><ul><li>查看控制器和配置信息</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx show all</span><br></pre></td></tr></table></figure><ul><li>使用激活码激活特性(如 CacheCade, FastPath,…)</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx set aso key=AAAAAAAABBBBBBBBCCCCCCCC</span><br></pre></td></tr></table></figure><ul><li>查看现有硬盘及其状态的信息 (IDs,…)</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx /eall /sall show (all)</span><br></pre></td></tr></table></figure><p>返回结果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Controller = 0</span><br><span class="line">Status = Success</span><br><span class="line">Description = Show Drive Information Succeeded.</span><br><span class="line"></span><br><span class="line">Drive Information :</span><br><span class="line">=================</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">EID:Slt DID State DG     Size Intf Med SED PI SeSz Model                  Sp</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">252:0     1 Onln   1 3.637 TB SATA HDD N   N  512B WDC WD4000FYYZ-03UL1B3 U</span><br><span class="line">252:1     3 Onln   1 3.637 TB SATA HDD N   N  512B WDC WD4000FYYZ-03UL1B3 U</span><br><span class="line">......</span><br><span class="line">252:6    85 Onln   0 3.637 TB SATA HDD N   N  512B WDC WD4000FYYZ-03UL1B3 U</span><br><span class="line">252:7     2 UGood  - 3.637 TB SATA HDD N   N  512B WDC WD4000FYYZ-03UL1B3 D</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EID-Enclosure Device ID|Slt-Slot No.|DID-Device ID|DG-DriveGroup</span><br><span class="line">DHS-Dedicated Hot Spare|UGood-Unconfigured Good|GHS-Global Hotspare</span><br><span class="line">UBad-Unconfigured Bad|Onln-Online|Offln-Offline|Intf-Interface</span><br><span class="line">Med-Media Type|SED-Self Encryptive Drive|PI-Protection Info</span><br><span class="line">SeSz-Sector Size|Sp-Spun|U-Up|D-Down|T-Transition|F-Foreign</span><br><span class="line">UGUnsp-Unsupported|UGShld-UnConfigured shielded|HSPShld-Hotspare shielded</span><br><span class="line">CFShld-Configured shielded|Cpybck-CopyBack|CBShld-Copyback Shielded</span><br></pre></td></tr></table></figure><ul><li>现有虚拟硬盘及其状态的信息</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx /vall show (all)</span><br></pre></td></tr></table></figure><ul><li>查看当前所有重建的状态</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx /eall /sall show rebuild</span><br></pre></td></tr></table></figure><h2 id="创建-初始化-raid"><a href="#创建-初始化-raid" class="headerlink" title="创建/初始化 raid"></a>创建/初始化 <code>raid</code></h2><ul><li><code>shell</code>创建<code>VD</code></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx add vd type=[RAID0(r0)|RAID1(r1)|...] drives=[EnclosureID:SlotID|:SlotID-SlotID|:SlotID,SlotID]</span><br><span class="line"><span class="meta">#</span><span class="bash">more</span></span><br><span class="line">storcli /cx add vd type=raid[0|1|5|6|00|10|50|60(r0|r1|...)] [Size=&lt;VD1_Sz&gt;,&lt;VD2_Sz&gt;,..|all] [name=&lt;VDNAME1&gt;,..] drives=e:s|e:s-x,y;e:s-x,y,z [PDperArray=x] [SED] [pdcache=on|off|default] [pi] [DimmerSwitch(ds)=default|automatic(auto)|none|maximum(max)|MaximumWithoutCaching(maxnocache)] [wt|wb] [nora|ra] [direct|cached] [CachedBadBBU|NoCachedBadBBU][cachevd] [Strip=&lt;8|16|32|64|128|256|1024&gt;] [AfterVd=X] [Spares = [e:]s|[e:]s-x|[e:]s-x,y] [force][ExclusiveAccess]</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用硬盘0-2创建raid1</span></span><br><span class="line">storcli /cx add vd type=r1 drives=252:0-2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 raid5,write-bakc,<span class="built_in">read</span>-ahead</span></span><br><span class="line">storcli /cx add vd type=raid5  size=all names=VD1 drives=32:2-7 wb ra</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 raid10/50/60,必须设定PDperArray参数,write-bakc,<span class="built_in">read</span>-ahead</span></span><br><span class="line">storcli /cx add vd type=raid10 size=all names=VD1 drives=32:2-7 PDperArray=2 wb ra</span><br></pre></td></tr></table></figure><ul><li><code>shell</code>之初始化<code>VD</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">storcli /cx/vx start init (force)</span><br></pre></td></tr></table></figure><ul><li>监视初始化进度</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx/vx show init</span><br></pre></td></tr></table></figure><ul><li><code>shell</code>之移除<code>VD</code></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx/vx del (force)</span><br></pre></td></tr></table></figure><h2 id="缓存加速"><a href="#缓存加速" class="headerlink" title="缓存加速"></a>缓存加速</h2><ul><li><code>shell</code>之创建<code>CacheCade</code>设备（SSD 缓存加速）</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx add vd cc type=r[0,1,10] drives=[EnclosureID:SlotID|:SlotID-SlotID|:SlotID,SlotID]  WT|WB (assignvds=0,1,2)</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /c0 add vd cc type=r1 drives=252:2-3 WB</span><br></pre></td></tr></table></figure><ul><li><code>shell</code>之<code>CacheCade</code>激活/停用</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx/[vx|vall] set ssdCaching=[on|off]</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /c0/v1 set ssdCaching=on</span><br></pre></td></tr></table></figure><ul><li><code>shell</code>之移除<code>CacheCade</code></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx/vx del cc</span><br></pre></td></tr></table></figure><h2 id="误插拔设备合并"><a href="#误插拔设备合并" class="headerlink" title="误插拔设备合并"></a>误插拔设备合并</h2><p>如果不正确地移除设备并重新连接到 RAID 控制器，它将被识别为 UBAD(Unconfigured Bad)。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /c0 /eall /sall show</span><br></pre></td></tr></table></figure><p>此时的返回结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Controller = 0</span><br><span class="line">Status = Success</span><br><span class="line">Description = Show Drive Information Succeeded.</span><br><span class="line"></span><br><span class="line">Drive Information :</span><br><span class="line">=================</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">EID:Slt DID State DG       Size Intf Med SED PI SeSz Model                  Sp </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">252:0     7 Onln   0  465.25 GB SATA HDD N   N  512B WDC WD5003ABYX-01WERA1 U  </span><br><span class="line">252:1     6 Onln   1  465.25 GB SATA HDD N   N  512B WDC WD5003ABYX-01WERA1 U  </span><br><span class="line">252:2     5 UGood  -  465.25 GB SATA HDD N   N  512B WDC WD5003ABYX-01WERA1 U  </span><br><span class="line">252:3     4 UBad   - 223.062 GB SATA SSD N   N  512B INTEL SSDSC2CW240A3    U  </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>此时<code>252:3</code>必需置为<code>UGOOD</code></p><ul><li><code>UBad</code>置为<code>UGOOD</code></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx /ex /sx set good</span><br></pre></td></tr></table></figure><p>返回结果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Controller = 0</span><br><span class="line">Status = Success</span><br><span class="line">Description = Show Drive Information Succeeded.</span><br><span class="line"></span><br><span class="line">Drive Information :</span><br><span class="line">=================</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">EID:Slt DID State DG       Size Intf Med SED PI SeSz Model                  Sp </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">252:0     7 Onln   0  465.25 GB SATA HDD N   N  512B WDC WD5003ABYX-01WERA1 U  </span><br><span class="line">252:1     6 Onln   1  465.25 GB SATA HDD N   N  512B WDC WD5003ABYX-01WERA1 U  </span><br><span class="line">252:2     5 UGood  -  465.25 GB SATA HDD N   N  512B WDC WD5003ABYX-01WERA1 U  </span><br><span class="line">252:3     4 UGood  F 223.062 GB SATA SSD N   N  512B INTEL SSDSC2CW240A3    U  </span><br><span class="line">-------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><ul><li><code>foreign</code>管理</li></ul><p>此时硬盘为<code>foreign</code>状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx /fall show</span><br></pre></td></tr></table></figure><p>返回结果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Controller = 0</span><br><span class="line">Status = Success</span><br><span class="line">Description = Operation on foreign configuration Succeeded</span><br><span class="line"></span><br><span class="line">FOREIGN CONFIGURATION :</span><br><span class="line">=====================</span><br><span class="line">----------------------------------------</span><br><span class="line">DG EID:Slot Type State       Size NoVDs </span><br><span class="line">----------------------------------------</span><br><span class="line"> 0 -        Cac0 Frgn  223.062 GB     1 </span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">NoVDs - Number of VDs in disk group|DG - Diskgroup</span><br><span class="line">Total foreign drive groups = 1</span><br></pre></td></tr></table></figure><p>现在它可以重新包含在配置中</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx /fall import</span><br></pre></td></tr></table></figure><p>如果设备是 RAID 的一部分，则会自动执行重建（请参阅概述中的状态：Rbld）。 可用以下命令监视进度：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">storcli /cx /ex /sx show rebuild</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看VD健康状态等,获取到坏盘的E:S编号,然后查看对应盘的SN</span></span><br><span class="line">storcli /c0 /vall show [all]</span><br><span class="line">storcli /c0 /eX /sY show all |grep SN</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看阵列卡</span></span><br><span class="line">storcli show ctrlcount</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 virtual disk 0 @controlor 0</span></span><br><span class="line">storcli /cx /v0 show</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 Controlor-0, Enclosure-7, Slot-7的磁盘信息</span></span><br><span class="line">storcli /cx/e252/s7 show all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看报警信息</span></span><br><span class="line">storcli /cx show alarm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭beep蜂鸣器报警</span></span><br><span class="line">storcli /cx set alarm=&lt;on|off|silence&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 定位磁盘仓位</span></span><br><span class="line">storcli /c0/e8/s2 start/stop locate</span><br></pre></td></tr></table></figure><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><ul><li><a href="https://www.broadcom.com/site-search?q=storcli" target="_blank" rel="noopener">官方相关资源下载-broadcom</a></li><li><a href="https://docs.broadcom.com/docs-and-downloads/raid-controllers/raid-controllers-common-files/StorCLI_RefMan_revf.pdf" target="_blank" rel="noopener">StorCLI 官方手册下载</a></li><li><a href="https://www.thomas-krenn.com/en/wiki/StorCLI" target="_blank" rel="noopener">StorCLI _Thomas-Krenn</a></li><li><a href="https://www.xargs.cn/doku.php/lsi:storcli%E6%89%8B%E5%86%8C" target="_blank" rel="noopener">STORCLI-wiki（个人博主维护）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> Linux </tag>
            
            <tag> RAID </tag>
            
            <tag> Storcli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 资源推荐--[书籍篇]</title>
      <link href="/blog/2017-12-03/recommend-books-for-Python-learner/"/>
      <url>/blog/2017-12-03/recommend-books-for-Python-learner/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>因为我目前做<code>Python</code>相关开发，很多想入门<code>Python</code>的朋友或者从事其他语言开发的同学私聊讨论书籍资料推荐的话题，其实网上有很多关于这个问题的话题总结，我个人的推荐并不见得比大神更好，希望真正想沉下心来学习的人能够早点明白“自己动手，丰衣足食”的道理。在这里做个简单整理也算是给大家一个交代，以不留下盛气凌人的傲慢印象为盼。</p><a id="more"></a><h2 id="红药丸还是蓝药丸"><a href="#红药丸还是蓝药丸" class="headerlink" title="红药丸还是蓝药丸"></a>红药丸还是蓝药丸</h2><p>刚开始学习编程的时候，很多人会有各种困惑：选择哪门语言？选择语言的哪个版本？用什么编辑器/开发平台……</p><p>相信看这篇文章的对第一个问题已然有了自己的选择，在此不多赘述。关于 Python 版本的问题，时至今日（2017 年），除非公司项目需要，不然请果断选择 Python3，毕竟大多数第三方库已经做出放弃 Python2 维护的相关说明。第三个问题倒是不用过分纠结，毕竟只要能够 run，哪怕是用记事本写的也没人会在意。个人目前使用 Sublime Text 3 搭配 IDE PyCharm。</p><h2 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h2><ul><li>《”笨办法”学 Python》    （《Learn Python the Hard Way》）</li></ul><p><a href="https://www.gitbook.com/book/flyouting/learn-python-the-hard-way-cn/details" target="_blank" rel="noopener">笨办法学 Python -Gitbook</a></p><p>学习一门语言的最好办法就是多敲多用，妄图靠眼睛<strong>看</strong>会一门技术的人，希望能够早点丢掉幻想，准备战斗！</p><blockquote><p>这本简单书的目的是让你起步编程。 虽然书名说是“笨办法”,但其实并非如此. 所谓的“笨办法”是指本书教授的方式。这本书的<br>教学方式就是按照我告诉你的方式去做一系列的练习，目的是通过重复练习掌握一种技能。这对于一些什么都不知道的初学者，在理解更复杂的科目之前获取基本能力是很有效的方法。这种方法适用于一切领域，从武术到音乐甚至基本的数学和阅读技巧。<br>这本书以习题的方式引导读者一步一步学习编程，从简单的打印一直讲到完整项目的实现。也许读完这本书并不<br>意味着你已经学会了编程，但至少你会对编程语言以及编程这个行业有一个初步的了解。</p></blockquote><ul><li>《简明 Python 教程》    （《A Byte of Python》）</li></ul><p><a href="https://www.gitbook.com/book/lenkimo/byte-of-python-chinese-edition/details" target="_blank" rel="noopener">简明 Python 教程-Gitbook</a></p><p>看一下激动人心的前言介绍：</p><blockquote><p>本书将以指南或教程的形式向你介绍<code>Python</code>这门编程语言。它以新手为主要目标。同时本书也对有经验的程序员有所帮助。<br>如果你对电脑的所有了解仅止步于如何保存文本文件的话，那本书的目标便是协助你通过本书学习<code>Python</code>。如果在此之前你已经有了编程经验，你同样可以通过本书来学习<code>Python</code>。<br>如果你已经有过编程经验，你或许会对<code>Python</code>与其它你所喜爱的编程语言间有何区别抱有兴趣——而我将会你展现许多这种区别。顺便提醒你一下，<code>Python</code>将会很快成为你最喜欢的编程语言！</p></blockquote><ul><li>《 Python 3.3 官方教程》</li></ul><p><a href="http://www.pythondoc.com/pythontutorial3/index.html" target="_blank" rel="noopener">Python 入门指南中文版</a><br><a href="https://docs.python.org/3/" target="_blank" rel="noopener">Python 官方教程（英文原版）</a></p><p>更新、权威、条理化的官方<code>tutorial</code> ，最原汁原味的<code>Python</code>指南。</p><ul><li>《零基础学 Python》/《跟老齐学 Python》</li></ul><p><a href="https://www.gitbook.com/book/looly/python-basic/details" target="_blank" rel="noopener">零基础学 Python</a></p><p>这本教程是我当初开始自学的时候看过的，由于是国内作者，语言习惯更适合我们，顺便也推荐给大家。</p><blockquote><p>在我看来，<code>Python</code>是非常适合作为学习高级语言编程的第一门语言的。有一本书，名字叫《与孩子一起学编程》，这本书的定位，是将 python 定位为学习者学习的第一门高级编程语言。然而，由于读者对象是孩子，很多“成年人”不屑一顾，当然，里面的讲法与“实战”有点距离，导致以“找工作”、“工作需要”为目标的学习者，认为这本书跟自己要学的方向相差甚远。<br>为了弥补那本书的缺憾，我在这里推出面向成年人——大学生、或者其他想学习程序但是没有任何编程基础的朋友——学习第一门编程高级语言的教程。</p></blockquote><p>读完上面的书，你已经掌握<code>Python</code>的语法特点，可以看懂语言逻辑，也可以按照自己的想法写一点小<code>demo</code>了。这个时候，如果打算从事相关工作，可以尝试迈出第一步啦。需要提醒大家的是：读书和做写代码应该是并驾齐驱的，不能一味地去读书，也不要一味敲代码。（当然，你可能也写不出来）只有相互有机结合，才能记得稳固，学得牢靠。</p><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><ul><li>《流畅的 Python》   (《Fluent Python-Clear, Concise, and Effective Programming》)</li></ul><p><a href="https://github.com/cundi/fluent-python" target="_blank" rel="noopener">流畅的 Python(未完成)</a></p><blockquote><p>这本书并不是一本完备的 <code>Python</code> 使用手册，而是会强调 <code>Python</code> 作为编程语言独有的特性，这些特性或者是只有 <code>Python</code> 才具备的，或者是在其他大众语言里很少见的。本书的目标读者是那些正在使用 <code>Python</code>，又想熟悉 <code>Python 3</code> 的程序员。本书的主要目的是为了充分地展现 <code>Python 3.4</code> 的魅力。</p></blockquote><ul><li>《《Python Cookbook》3rd Edition 》</li></ul><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">Python Cookbook</a></p><blockquote><p>这本书的目标读者是那些想深入理解<code>Python</code>语言机制和现代编程风格的有经验的<code>Python</code>程序员。本书大部分内容集中于在标准库，框架和应用程序中广泛使用的高级技术。<br>本书所有示例均假设读者具有一定的编程背景并且可以读懂相关主题 （比如基本的计算机科学知识，数据结构知识，算法复杂度，系统编程，并行，C 语言编程等）。 另外，每个示例都只是一个入门指导，如果读者想深入研究，需要自己去查阅更多资料。我们假定读者可以很熟练的使用搜索引擎以及知道怎样查询在线的<code>Python</code>文档。</p></blockquote><p>读完上面的书，你已经可以写出<code>Pythonic</code>的代码了，应该对<code>Python</code>有了自己的理解，并且也会有自己的方向，可以确定自己的发展方向：Web 应用开发、爬虫数据分析、网络安全、运维测试、<code>Linux</code>系统开发、人工智能/机器学习。相信这个时候你已经不再需要别人的推荐，那么是时候为<code>Python</code>的蓬勃发展贡献自己的力量啦！</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p><a href="https://foofish.net/python-free-ebook.html" target="_blank" rel="noopener">免费中文 Python 电子书（教程）</a><br><a href="https://github.com/Junnplus/awesome-python-books/blob/master/README-ZH_CN.md" target="_blank" rel="noopener">Awesome Python Books</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Python 进行计数统计</title>
      <link href="/blog/2017-11-21/how-to-count-sequense-with-python/"/>
      <url>/blog/2017-11-21/how-to-count-sequense-with-python/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>from collections import Counter</p><a id="more"></a><h2 id="使用常规for循环"><a href="#使用常规for循环" class="headerlink" title="使用常规for循环"></a>使用常规<code>for</code>循环</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: test_seq = <span class="string">'asfsdgfads'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: count_dict = dict()</span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: <span class="keyword">for</span> item <span class="keyword">in</span> test_seq:</span><br><span class="line">    ...:     <span class="keyword">if</span> item <span class="keyword">in</span> count_dict:</span><br><span class="line">    ...:         count_dict[item] += <span class="number">1</span></span><br><span class="line">    ...:     <span class="keyword">else</span>:</span><br><span class="line">    ...:         count_dict[item] = <span class="number">0</span></span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">56</span>]: count_dict</span><br><span class="line">Out[<span class="number">56</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">1</span>, <span class="string">'f'</span>: <span class="number">1</span>, <span class="string">'g'</span>: <span class="number">0</span>, <span class="string">'s'</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="使用collections库中的defaultdict"><a href="#使用collections库中的defaultdict" class="headerlink" title="使用collections库中的defaultdict"></a>使用<code>collections</code>库中的<code>defaultdict</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: cd_dict = defaultdict()</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: cd_dict = defaultdict(int)</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: <span class="keyword">for</span> item <span class="keyword">in</span> test_seq:</span><br><span class="line">    ...:     cd_dict[item] += <span class="number">1</span></span><br><span class="line">    ...:</span><br><span class="line">In [<span class="number">62</span>]: cd_dict</span><br><span class="line">Out[<span class="number">62</span>]: defaultdict(int, &#123;<span class="string">'a'</span>: <span class="number">2</span>, <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'f'</span>: <span class="number">2</span>, <span class="string">'g'</span>: <span class="number">1</span>, <span class="string">'s'</span>: <span class="number">3</span>&#125;)</span><br><span class="line">In [<span class="number">63</span>]: cd_dict.items()</span><br><span class="line">Out[<span class="number">63</span>]: [(<span class="string">'a'</span>, <span class="number">2</span>), (<span class="string">'s'</span>, <span class="number">3</span>), (<span class="string">'d'</span>, <span class="number">2</span>), (<span class="string">'g'</span>, <span class="number">1</span>), (<span class="string">'f'</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><h2 id="使用collections库中的Counter"><a href="#使用collections库中的Counter" class="headerlink" title="使用collections库中的Counter"></a>使用<code>collections</code>库中的<code>Counter</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: Counter(test_data)</span><br><span class="line">Out[<span class="number">65</span>]: Counter(&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">3</span>, <span class="string">'g'</span>: <span class="number">3</span>, <span class="string">'h'</span>: <span class="number">1</span>, <span class="string">'s'</span>: <span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: counter = Counter(test_seq)</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: counter.items()</span><br><span class="line">Out[<span class="number">85</span>]: [(<span class="string">'a'</span>, <span class="number">2</span>), (<span class="string">'s'</span>, <span class="number">3</span>), (<span class="string">'d'</span>, <span class="number">2</span>), (<span class="string">'g'</span>, <span class="number">1</span>), (<span class="string">'f'</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><ul><li>《编写高质量代码：改善 Python 程序的 91 个建议》迷你书-建议 39：使用 Counter 进行计数统计</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> HOWTO </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘阵列控制卡（RAID 卡）MegaCli 常用管理命令汇总</title>
      <link href="/blog/2017-11-20/megacli-command-share/"/>
      <url>/blog/2017-11-20/megacli-command-share/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>进行存储开发时需要创建磁盘阵列，本文主要记录 RAID 卡管理工具<code>MegaCli</code>的使用。需要注意的是，目前该管理工具因为商业收购已经被官方“弃坑”，<code>StorCLI</code>作为后继者整合了<code>LSI</code>和原来<code>3ware</code>的产品支持，兼容<code>MegaCLI</code>命令的同时更加简洁，参阅<a href="https://imoyao.github.io/blog/2017-12-27/storcli_command_share/">此篇</a>。<br><a id="more"></a></p><h2 id="巡读"><a href="#巡读" class="headerlink" title="巡读"></a>巡读</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">立即激活</span></span><br><span class="line">MegaCli -adppr -enblauto -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置成手动模式，需要用MegaCli -adppr -start –a0 来激活</span></span><br><span class="line">MegaCli -adppr -enblman -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看巡读的模式，本次巡读结束与下一次开始巡读的间隔，当前状态等信息</span></span><br><span class="line">MegaCli -adppr -info -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看巡读的进度</span></span><br><span class="line">MegaCli -fwtermlog -dsply -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">结束巡读，在巡读过程中，多次运用MegaCli -adppr -stop -a0或MegaCli -adppr -start -a0会使叠代数增加，此时可能不能开始或结束巡读，用MegaCli -adppr -dsbl -a0来禁止巡读，重新开始。</span></span><br><span class="line">MegaCli -adppr -stop -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置本次巡读结束与下一次巡读开始的时间间隔，默认是168小时，当val=0时, 本次巡读结束后，立即开始下一次巡读</span></span><br><span class="line">MegaCli -adppr -setdelay val -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">巡读时是否纠正媒介错误</span></span><br><span class="line">MegaCli -AdpSetProp -PrCorrectUncfgdAreas -val -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置定时巡读 yyyymmdd hh，具体含义如下：20120108 16表示2012年01月08日16点</span></span><br><span class="line">MegaCli -AdpPR -SetStartTime yyyymmdd hh -a0</span><br></pre></td></tr></table></figure><h2 id="cc-校验"><a href="#cc-校验" class="headerlink" title="cc 校验"></a>cc 校验</h2><ul><li>立即开始 cc 校验</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">L0表示Target ID 为0的raid组</span></span><br><span class="line">MegaCli -ldcc -start -L0 –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">如果没有完全初始化或后台初始化</span></span><br><span class="line"><span class="meta">#</span><span class="bash">The virtual disk has not been initialized、 Running a consistency check may result <span class="keyword">in</span> inconsistent messages <span class="keyword">in</span> the <span class="built_in">log</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">可以强行cc校验</span></span><br><span class="line">MegaCli -ldcc -start -force –L0 –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">显示当前cc校验的进度</span></span><br><span class="line">MegaCli -ldcc -progdsply -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">关掉当前的cc校验</span></span><br><span class="line">MegaCli -ldcc -abort -L0 -a0</span><br></pre></td></tr></table></figure><ul><li>计划 cc 校验<br>如果模式为 disable(MegaCli -adpccsched -info -a0 来查看)，则下一次开始时间为 07/28/2135, 02:00:00，状态为 Stopped，延期为 168 个小时;<br>只有模式为 Sequential 和 Concurrent 模式时，才可以设定定期时间，所以要首先设定模式;<br>如果模式为 Sequential 时，所有虚拟磁盘组顺序进行 cc 校验;<br>如果模式为 Concurrent 时，所有虚拟磁盘组同时进行 cc 校验;<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设定CC模式</span></span><br><span class="line">MegaCli -adpccsched -modeconc -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">或者</span></span><br><span class="line">MegaCli -adpccsched -modeseq -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">然后设定开始时间</span></span><br><span class="line">MegaCli -adpccsched setstarttime 20101122 18 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置本次cc校验结束和下次cc校验开始的时间间隔</span></span><br><span class="line">MegaCli -adpccsched -setdelay 2 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">禁止计划cc校验</span></span><br><span class="line">MegaCli -AdpCcSched -dsbl -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置错误发生时放弃cc校验</span></span><br><span class="line">MegaCli -adpsetprop -AbortCC -1 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看cc校验的事件日志</span></span><br><span class="line">MegaCli -AdpEventLog -GetCCIncon –f filename –L0 –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">如果设置延期时间为0，本次cc校验结束后，下一次cc校验会立即开始</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="快速初始化和完全初始化"><a href="#快速初始化和完全初始化" class="headerlink" title="快速初始化和完全初始化"></a>快速初始化和完全初始化</h2><p>快速初始化值是往 raid 组的前 8M 和后 8M 写 0<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">快速初始化</span></span><br><span class="line">MegaCli -LDInit -start –L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">完全初始化</span></span><br><span class="line">MegaCli -LDInit -start -full –L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">显示初始化的进度</span></span><br><span class="line">MegaCli -LDInit -progdsply -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">结束完全初始化</span></span><br><span class="line">MegaCli -LDInit -abort -L0 -a0</span><br></pre></td></tr></table></figure></p><h2 id="后台初始化"><a href="#后台初始化" class="headerlink" title="后台初始化"></a>后台初始化</h2><p>Raid5 需要 5 个数据盘才可以后台初始化(5 个盘中不包含热备盘)<br>后台初始化是创建 raid 后 5 分钟开始的(好像有时不是这样的)<br>后台初始化和 cc 校验不同的地方是，后台初始化可以自动开始<br>改变后台初始化率时，需要停止后台初始化，否则没有效果<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">禁止后台初始化</span></span><br><span class="line">MegaCli -LDBI -dsbl -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">结束正在进行的后台初始化</span></span><br><span class="line">MegaCli -LDBI -abort -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看后台初始化的设置</span></span><br><span class="line">MegaCli -LDBI -getsetting -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">显示后台初始化进度</span></span><br><span class="line">MegaCli -LDBI -progdsply -L0 -a0</span><br></pre></td></tr></table></figure></p><h2 id="copyback"><a href="#copyback" class="headerlink" title="copyback"></a>copyback</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">开启或禁用copyback</span></span><br><span class="line">MegaCli -AdpSetProp –CopyBackDsbl -0 -a0 (开启)</span><br><span class="line"><span class="meta">#</span><span class="bash">显示copyback设置情况</span></span><br><span class="line">MegaCli –AdpGetProp -CopyBackDsbl –a0</span><br></pre></td></tr></table></figure><p>当设置 copyback 为 enable 时，拔出坏盘，换上一个 UNCONF 的新盘，先用热备盘进行重建，然后进行 copyback 操作，如果 copyback 为 disable 时，不进行 copyback 操作，可以设定 copyback 为 enable，然后用 MegaCli -PDCpyBk -Start -PhysDrv[E0:S0,E1:S1] –a0 开始 copyback 操作，其中[E0：S0]是 raid 组中的磁盘(源盘)，而[E1：S1]不是 raid 组中的磁盘(目的盘)</p><p>当某个盘出现第一个 smart 错误时，可以在这个盘和热备盘之间进行 copyback 操作，热备盘作为目的盘，完成了 copyback 操作时，smart 错误盘才标记为 failed 状态。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果在copyback时，raid组删除，目的盘回到热备盘状态或Unconfigured Good</span></span><br><span class="line">MegaCli -AdpGetProp SMARTCpyBkEnbl -a0</span><br></pre></td></tr></table></figure></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看所有的information日志</span></span><br><span class="line">MegaCli -adpalilog -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看固件调试日志(固件终端日志)</span></span><br><span class="line">MegaCli -fwtermlog -dsply -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看raid卡日志</span></span><br><span class="line">MegaCli -adpeventlog -getevents -f filename -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">清除日志</span></span><br><span class="line">MegaCli -AdpEventLog -Clear –a0</span><br></pre></td></tr></table></figure><h2 id="raid5-扩容"><a href="#raid5-扩容" class="headerlink" title="raid5 扩容"></a>raid5 扩容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">raid5的扩容</span></span><br><span class="line">MegaCli -LDRecon -Start -r5 -Add -Physdrv[E0:S0] -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看扩容的进度</span></span><br><span class="line">MegaCli -LDRecon -progdsply -L0 –a0</span><br></pre></td></tr></table></figure><h2 id="级别迁移"><a href="#级别迁移" class="headerlink" title="级别迁移"></a>级别迁移</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在迁移过程中，转换前的raid的一个盘下线，转换前raid的所有盘都下线</span><br><span class="line">支持的类型 RAID 0 to RAID 1，RAID 0 to RAID 5，RAID 0 to RAID 6，RAID 1 to RAID 0，RAID 1 to RAID 5，RAID 1 to RAID 6，RAID 5 to RAID 0，RAID 5 to RAID 6，RAID 6 to RAID 0，RAID 6 to RAID 5</span><br><span class="line"><span class="meta">#</span><span class="bash">建立了三个盘的raid 0</span></span><br><span class="line">MegaCli -cfgldadd -r0[117:1,117:3,117:11] -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">增加一个盘[117:14],转换到raid5</span></span><br><span class="line">MegaCli -ldrecon -start -r5 -add -physdrv[117:14] -l0 -a0</span><br></pre></td></tr></table></figure><h2 id="升级-ROM"><a href="#升级-ROM" class="headerlink" title="升级 ROM"></a>升级 ROM</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">从低版本到高版本升级</span></span><br><span class="line">MegaCli -adpfwflash -f x.rom -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">从高版本到低版本降级</span></span><br><span class="line"><span class="meta">#</span><span class="bash">加上noverchk忽略版本的检查，升级以后需要重启才生效</span></span><br><span class="line">MegaCli -adpfwflash -f x.rom -noverchk -a0</span><br></pre></td></tr></table></figure><h2 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h2><p>Raid 对内有两个接口，即 connector0 和 connector1。得到连接器的状态;<br> MegaCli -adpgetconnectormode -connector0 -a0<br>如果连接器的模式为 internal 时，jbod 的磁盘全部看不到，如果连接器的模式为 external 时，主柜上的磁盘全部看不到;</p><h2 id="外来配置"><a href="#外来配置" class="headerlink" title="外来配置"></a>外来配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">扫描外来配置的个数</span></span><br><span class="line">MegaCli -cfgforeign -scan -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看当前的磁盘在normal时的位置</span></span><br><span class="line">MegaCli -cfgforeign -preview -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">来导入配置，恢复虚拟磁盘组</span></span><br><span class="line">MegaCli -cfgforeign -import -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">清除外来配置</span></span><br><span class="line">MegaCli -cfgforeign -clear -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">显示出现外来配置(磁盘插入的顺序)的过程</span></span><br><span class="line">MegaCli -cfgforeign -dsply -a0</span><br></pre></td></tr></table></figure><h2 id="物理磁盘的处理"><a href="#物理磁盘的处理" class="headerlink" title="物理磁盘的处理"></a>物理磁盘的处理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">磁盘的状态由FAULTY变成CONF</span></span><br><span class="line">MegaCli -PDMakeGood -PhysDrv[E0:S0] –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">磁盘上线</span></span><br><span class="line">MegaCli -PDOnline -PhysDrv[E0:S0,E1:S1,...] –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">磁盘下线</span></span><br><span class="line"><span class="meta">#</span><span class="bash">failed状态的盘可以下线，然后用MegaCli -pdmarkmissing -physdrv[E0:S0] -a0让磁盘踢盘，让其他的UNCONF状态的磁盘来替代这个盘MegaCli -PdReplaceMissing -physdrv[E0:S0] -arrayA, -rowB -a0</span></span><br><span class="line">MegaCli -PDOffline -PhysDrv[E0:S0,E1:S1,...] –a0 </span><br><span class="line"><span class="meta">#</span><span class="bash">此时磁盘处于Spun down状态，如果用此磁盘来建立raid，则磁盘的状态自动变成Spun Up</span></span><br><span class="line">MegaCli -PdPrpRmv -physdrv[E0:S0] –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">清除单个磁盘</span></span><br><span class="line">MegaCli -pdclear -start -physdrv[E:S] -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置热备盘的节电策略</span></span><br><span class="line">MegaCli -AdpSetProp –DsblSpinDownHSP -val –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置空闲盘的节电策略</span></span><br><span class="line">MegaCli -AdpSetProp –EnblSpinDownUnConfigDrvs -val –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">获取所有磁盘的详细信息</span></span><br><span class="line">MegaCli -PDList –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">获取单个盘的详细信息</span></span><br><span class="line">MegaCli -pdInfo -PhysDrv[E0:S0] –a0</span><br></pre></td></tr></table></figure><h2 id="Adpsetprop-设置属性"><a href="#Adpsetprop-设置属性" class="headerlink" title="Adpsetprop 设置属性"></a>Adpsetprop 设置属性</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RebuildRate ，PatrolReadRate，BgiRate，CCRate，ReconRate，表示进行重建，巡读，后台初始化，cc校验，扩容等所占有的系统资源率，提高速度</span><br><span class="line">CoercionMode(强制模式)，分成三种形式，None，128M，1G，当为1G时，每个磁盘比没有设置的时减少了1G的空间;</span><br><span class="line">PredFailPollInterval，轮询预测失败的时间间隔。Predictive Failure Count就是smart错误;</span><br><span class="line">MaintainPdFailHistoryEnbl 保存坏盘的历史记录。当为enable时，当一个盘掉线并重新上线。需要清除配置信息，添加为热备盘才可以重建当为disable时。当一个盘掉线并重新上线，自动重建;</span><br><span class="line"><span class="meta">#</span><span class="bash">设置Cluster模式，目前不支持，只能设置为disbale</span></span><br><span class="line">MegaCli -AdpSetProp ClusterEnable -0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置jbod模式，针对raid0有效，对单个盘读写，即先写第一个盘，写满了在写第二个盘。MegaCli -PDMakeJBOD -physdrv[E0:S0,E1:S1] -a0 可以设置jbod模式(目前不支持)</span></span><br><span class="line">MegaCli -AdpSetProp -EnableJBOD -1 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">让设备驱动暴露enclosure devices</span></span><br><span class="line">MegaCli -AdpSetProp ExposeEnclDevicesEnbl -1 -a0</span><br></pre></td></tr></table></figure><h2 id="NCQ"><a href="#NCQ" class="headerlink" title="NCQ"></a>NCQ</h2><p>Native Command Queuing (NCQ)对硬盘的读写命令的顺序进行优化。带 NCQ 技术的硬盘在接到读写指令后，会根据指令对访问地址进行重新排序。比如根据指令，硬盘需要访问 330 扇区、980 扇区、340 扇区，由于数据在磁盘上分布位置不同，普通硬盘只会按部就班地依次访问。而 NCQ 硬盘对指令进行优化排列之后，就可以先读取 330 扇区，接着读取 340 扇区，然后再读取 980 扇区。这样做的好处就是减少了磁头臂来回移动的时间，使数据读取更有效，同时有效地延长了硬盘的使用寿命。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">显示NCQ的设置情况</span></span><br><span class="line">MegaCli -adpgetprop -NCQdsply -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置开启NCQ</span></span><br><span class="line">MegaCli -adpsetprop -NCQenbl -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭NCQ</span></span><br><span class="line">MegaCli -adpsetprop -NCQdsbl -a0</span><br></pre></td></tr></table></figure></p><h2 id="添加和移除热备盘"><a href="#添加和移除热备盘" class="headerlink" title="添加和移除热备盘"></a>添加和移除热备盘</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">添加局部热备盘，其中array0表示第0个raid</span></span><br><span class="line">MegaCli -PDHSP -Set -Dedicated -Array0 -physdrv[E:S] -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">添加全局热备盘</span></span><br><span class="line">MegaCli -pdhsp -set -physdrv[E:S] -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">移除全局和热备局部热备</span></span><br><span class="line">MegaCli -pdhsp -rmv -physdrv[E:S] -a0</span><br></pre></td></tr></table></figure><h2 id="重建"><a href="#重建" class="headerlink" title="重建"></a>重建</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看重建的进度</span></span><br><span class="line">MegaCli -PDRbld -progdsply -physdrv[E:S] -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">调快重建的速度</span></span><br><span class="line">MegaCli -AdpSetProp RebuildRate -val -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置自动重建，当一个盘坏掉时，热备盘可以自动重建，代替坏的盘</span></span><br><span class="line">MegaCli -AdpAutoRbld -Enbl -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">手动开始重建，E0:S0表示坏的盘</span></span><br><span class="line">MegaCli -PDRbld -Start -PhysDrv [E0:S0] -a0</span><br></pre></td></tr></table></figure><h2 id="恢复出厂设置"><a href="#恢复出厂设置" class="headerlink" title="恢复出厂设置"></a>恢复出厂设置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">恢复出厂的默认配置</span></span><br><span class="line">MegaCli -AdpFacDefSet –a0</span><br></pre></td></tr></table></figure><h2 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">临时关闭，重启又变成开启</span></span><br><span class="line">MegaCli -AdpSetProp -AlarmSilence –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">永久关闭，重启后还是关闭</span></span><br><span class="line">MegaCli -AdpSetProp -AlarmDsbl –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">开启</span></span><br><span class="line">MegaCli -AdpSetProp -Alarmenbl –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看告警的状态</span></span><br><span class="line">MegaCli -AdpgetProp -Alarmdsply –a0</span><br></pre></td></tr></table></figure><h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">可以查看一组磁盘上的多个raid的配置</span></span><br><span class="line">MegaCli -CfgDsply -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">保存配置文件</span></span><br><span class="line">MegaCli -CfgSave -f filename -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">导入配置文件，Raid组的配置文件放在最后，放在每个磁盘的最后512M，主要包含数据从哪里开始写的配置和用来Migration 的swap文件</span></span><br><span class="line">MegaCli -CfgRestore -f filename -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">启动时恢复外来配置</span></span><br><span class="line">MegaCli -AdpSetProp -AutoEnhancedImportEnbl -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">验证配置文件和文件的内容</span></span><br><span class="line">MegaCli -AdpSetVerify -f fileName -a0</span><br></pre></td></tr></table></figure><h2 id="RAID-卡相关"><a href="#RAID-卡相关" class="headerlink" title="RAID 卡相关"></a>RAID 卡相关</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看raid的配置信息</span></span><br><span class="line">MegaCli -adpallinfo -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭raid卡</span></span><br><span class="line">MegaCli -adpShutDown -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">获取raid的时间</span></span><br><span class="line">MegaCli -adpGetTime -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">对raid进行诊断</span></span><br><span class="line">MegaCli -AdpDiag val -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置负载均衡，Raid卡对终端设备采用多路径访问，一半的设备通过一条路径，另一半的设备通过另一条路径，一条途径有盘插入和移除时，启动负载平衡，避免设备有重用</span></span><br><span class="line">MegaCli -AdpSetProp –LoadBalanceMode -val –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">获取raid卡的个数</span></span><br><span class="line">MegaCli –adpCount</span><br><span class="line"><span class="meta">#</span><span class="bash">获取pci信息</span></span><br><span class="line">MegaCli -AdpGetPciInfo -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">Raid卡的在线重置，fw重置raid卡控制器芯片</span></span><br><span class="line">MegaCli -AdpSetProp DisableOCR -val -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">显示raid卡，系统等的一些简单信息</span></span><br><span class="line">MegaCli -ShowSummary -f filename -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">显示每个phy的错误数</span></span><br><span class="line">MegaCli -PhyErrorCounters -a0</span><br></pre></td></tr></table></figure><h2 id="Enclosure-的信息"><a href="#Enclosure-的信息" class="headerlink" title="Enclosure 的信息"></a>Enclosure 的信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看机柜的相关信息</span></span><br><span class="line">MegaCli -encinfo -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看机柜的状态</span></span><br><span class="line">MegaCli -encstatus -a0</span><br></pre></td></tr></table></figure><h2 id="BIOS-相关"><a href="#BIOS-相关" class="headerlink" title="BIOS 相关"></a>BIOS 相关</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在启动时要按任意键才可以启动这种情况设置这个参数。但是首先要确保 bios 处于 <span class="built_in">enable</span> 状态。通过 MegaCli -AdpBIOS -dsply -a0可以查看。如果不是，先用MegaCli -AdpBIOS -enbl -a0来设置</span></span><br><span class="line">MegaCli –AdpBIOS –BE –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">把当前的Raid组作为启动</span></span><br><span class="line">MegaCli –AdpBootDrive -set -L0 -a0</span><br></pre></td></tr></table></figure><h2 id="背板相关"><a href="#背板相关" class="headerlink" title="背板相关"></a>背板相关</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果背板 <span class="built_in">disable</span> 时，会自动的去检测背板</span></span><br><span class="line">MegaCli -AdpSetProp -AutoDetectBackPlaneDsbl -val –a0</span><br></pre></td></tr></table></figure><h2 id="启动时上电"><a href="#启动时上电" class="headerlink" title="启动时上电"></a>启动时上电</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置一次上电的磁盘的个数</span></span><br><span class="line">MegaCli -AdpSetProp SpinupDriveCount -val -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置上电的延迟时间</span></span><br><span class="line">MegaCli -AdpSetProp SpinupDelay -val -a0</span><br></pre></td></tr></table></figure><h2 id="刷新缓存"><a href="#刷新缓存" class="headerlink" title="刷新缓存"></a>刷新缓存</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">刷新raid卡缓存</span></span><br><span class="line">MegaCli -AdpCacheFlush –a0</span><br><span class="line"><span class="meta">#</span><span class="bash">刷缓存的时间间隔</span></span><br><span class="line">MegaCli -AdpSetProp CacheFlushInterval –val –a0</span><br></pre></td></tr></table></figure><h2 id="让硬盘-LED-灯闪烁"><a href="#让硬盘-LED-灯闪烁" class="headerlink" title="让硬盘 LED 灯闪烁"></a>让硬盘 LED 灯闪烁</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">开启blink</span></span><br><span class="line">MegaCli -AdpSetProp UseDiskActivityforLocate -1 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">让硬盘LED灯闪烁</span></span><br><span class="line">MegaCli -PdLocate -start –physdrv[E:S] -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">停掉硬盘LED灯</span></span><br><span class="line">MegaCli -PdLocate -stopt –physdrv[E:S] -a0</span><br></pre></td></tr></table></figure><h2 id="电池告警"><a href="#电池告警" class="headerlink" title="电池告警"></a>电池告警</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpSetProp BatWarnDsbl -val -a0</span><br></pre></td></tr></table></figure><h2 id="纠错码相关"><a href="#纠错码相关" class="headerlink" title="纠错码相关"></a>纠错码相关</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置纠错码漏桶的字节数</span></span><br><span class="line">MegaCli -AdpSetProp EccBucketSize -val -a0</span><br></pre></td></tr></table></figure><h2 id="后台初始化，完全初始化，cc-校验，巡读等之间的关系"><a href="#后台初始化，完全初始化，cc-校验，巡读等之间的关系" class="headerlink" title="后台初始化，完全初始化，cc 校验，巡读等之间的关系"></a>后台初始化，完全初始化，cc 校验，巡读等之间的关系</h2><p>后台初始化和完全初始化，cc 校验时不能进行巡读;<br>巡读时可以后台初始化和完全初始化，此时巡读结束;;<br>在后台初始化和 cc 校验时，不能开始完全初始化;<br>扩容时不能建 raid，不能添加热备盘;<br>rebuild 的优先级高于 copyback;</p><h2 id="RAID-的创建与删除"><a href="#RAID-的创建与删除" class="headerlink" title="RAID 的创建与删除"></a>RAID 的创建与删除</h2><ul><li>创建 raid 0，1，5，6</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">MegaCli -CfgLdAdd -rX[E0:S0,E1:S1,...] [WT|WB] [NORA|RA|ADRA] [Direct|Cached] [CachedBadBBU|NoCachedBadBBU] [-szXXX [-szYYY ...]] [-strpszM] [-Hsp[E0:S0,...]] [-AfterLdX] [-Force]|[FDE|CtrlBased] -a0 可以设置写模式(wt，wb)，读模式(ra，nora，adra)，缓存模式(direct，cached)，大小(sz)，条块大小(strpszM)等。比如1000G，只用指定盘的一部分(sz1000G)，设置条块的大小strpsz(设置为16k，则为strpsz16)</span></span><br><span class="line">MegaCli -cfgldadd -r5[117:1,117:3,117:11] -wb -ra -cached -cachedbadbbu -force -a0</span><br></pre></td></tr></table></figure><ul><li>创建 raid 10，50，60</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">MegaCli -CfgSpanAdd -rX-Array0[E0:S0,E1:S1] -Array1[E0:S0,E1:S1] [-ArrayX[E0:S0,E1:S1] ...] [WT|WB] [NORA|RA|ADRA] [Direct|Cached] [CachedBadBBU| NoCachedBadBBU] [-szXXX[-szYYY ...]][-strpszM][-AfterLdX][-Force] |[FDE|CtrlBased] -aN</span></span><br><span class="line">MegaCli -CfgSpanAdd -r10 -Array0[245:0,245:1] Array1[245:2,245:3] -WB -RA -Cached -Cachedbadbbu -a0</span><br></pre></td></tr></table></figure><ul><li>批量创建 raid0</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">把每个槽位的磁盘都创建为只有一个盘的raid0</span></span><br><span class="line">MegaCli -CfgEachDskRaid0 -wb -ra -cached -cachedbadbbu -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">把所有的空闲盘都加入到raid中</span></span><br><span class="line">MegaCli -CfgAllFreeDrv -r5 -SATAOnly -wb -ra -cached -cachedbadbbu -a0</span><br></pre></td></tr></table></figure><ul><li>删除 raid 组</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">清除所有的raid组的配置</span></span><br><span class="line">MegaCli -cfgclr -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">删除指定的raid组(Target Id: 0)的raid组</span></span><br><span class="line">MegaCli -cfglddel -L0 -a0</span><br></pre></td></tr></table></figure><h2 id="设置-RAID-组的属性"><a href="#设置-RAID-组的属性" class="headerlink" title="设置 RAID 组的属性"></a>设置 RAID 组的属性</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置raid组的名字</span></span><br><span class="line">MegaCli -ldsetprop -name dg -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置访问策略为读写，MegaCli -ldsetprop -blocked -L0 -a0设置访问策略为阻塞，此时raid组的设备不可以访问，fdisk -l不能发现设备</span></span><br><span class="line">MegaCli -ldsetprop -rw -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置写策略为wt(直写)，直接写入到硬盘上，然后再返回。wb模式是写入到缓存中就返回，设置wb模式写速度有显著的改善，提高到12倍</span></span><br><span class="line">MegaCli -ldsetprop -wt -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">设置读策略为ra(预先读出一定的数据)，还有nora模式，ra模式读可以提高到2倍左右</span></span><br><span class="line">MegaCli -ldsetprop -ra -L0 -a0 </span><br><span class="line"><span class="meta">#</span><span class="bash">设置缓存策略为cached</span></span><br><span class="line">MegaCli -ldsetprop -cached -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash">开启磁盘的缓存，对写速度有一定的提高(1.4倍)</span></span><br><span class="line">MegaCli -ldsetprop -endskcache -L0 -a0</span><br></pre></td></tr></table></figure><h2 id="查询篇"><a href="#查询篇" class="headerlink" title="查询篇"></a>查询篇</h2><ul><li><p>显示 BBU 状态信息    </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpBbuCmd -GetBbuStatus –aALL </span><br><span class="line">``` </span><br><span class="line">- 显示 BBU 容量信息    </span><br><span class="line">```shell</span><br><span class="line">MegaCli -AdpBbuCmd -GetBbuCapacityInfo –aALL</span><br></pre></td></tr></table></figure></li><li><p>显示 BBU 设计参数    </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpBbuCmd -GetBbuDesignInfo –aALL</span><br></pre></td></tr></table></figure></li><li><p>显示当前 BBU 属性   </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpBbuCmd -GetBbuProperties –aALL</span><br></pre></td></tr></table></figure></li><li><p>查看充电状态    </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpBbuCmd -GetBbuStatus -aALL |grep "Charger Status"</span><br></pre></td></tr></table></figure></li><li><p>查看充电进度百分比     </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpBbuCmd -GetBbuStatus -aALL |grep "Relative State of Charge"</span><br></pre></td></tr></table></figure></li><li><p>查看所有物理磁盘信息     </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -PDList -aALL</span><br></pre></td></tr></table></figure></li><li><p>显示所有逻辑磁盘组信息     </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -LDInfo -LALL –aAll</span><br></pre></td></tr></table></figure></li><li><p>查看物理磁盘重建进度(重要)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -PDRbld -ShowProg -PhysDrv [1:5] -a0</span><br></pre></td></tr></table></figure></li><li><p>查看适配器个数    </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli –adpCount</span><br></pre></td></tr></table></figure></li><li><p>查看适配器时间     </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpGetTime –aALL</span><br></pre></td></tr></table></figure></li><li><p>显示所有适配器信息    </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpAllInfo –aAll</span><br></pre></td></tr></table></figure></li><li><p>显示 RAID 卡型号，RAID 设置，Disk 相关信息      </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -cfgdsply –aALL</span><br></pre></td></tr></table></figure></li><li><p>查询 RAID 阵列个数    </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -cfgdsply -aALL |grep "Number of DISK GROUPS:"</span><br><span class="line">``` </span><br><span class="line">- 查看 Cache 策略设置    </span><br><span class="line">```shell</span><br><span class="line">MegaCli -cfgdsply -aALL |grep Polic</span><br></pre></td></tr></table></figure></li><li><p>查看磁盘缓存策略 </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> L----&gt;[VD num or ALL] a----&gt;[Adapter num or ALL]</span></span><br><span class="line">MegaCli -LDGetProp -Cache -L0 -a0</span><br><span class="line"><span class="meta">#</span><span class="bash"> or </span></span><br><span class="line">MegaCli -LDGetProp -DskCache -LALL -aALL</span><br></pre></td></tr></table></figure></li><li><p>查看物理磁盘重建进度</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -PDRbld -ShowProg -PhysDrv [1:5] -a0</span><br></pre></td></tr></table></figure></li><li><p>查看 Megacli 的 log</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -FwTermLog dsply -a0 &gt; adp2.log</span><br></pre></td></tr></table></figure></li></ul><h2 id="设置篇"><a href="#设置篇" class="headerlink" title="设置篇"></a>设置篇</h2><h3 id="创建-删除阵列"><a href="#创建-删除阵列" class="headerlink" title="创建/删除阵列"></a>创建/删除阵列</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个 RAID5 阵列，由物理盘 2,3,4 构成，该阵列的热备盘是物理盘 5 </span></span><br><span class="line">MegaCli -CfgLdAdd -r5 [1:2,1:3,1:4] WB Direct -Hsp[1:5] –a0 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建阵列，不指定热备 </span></span><br><span class="line">MegaCli -CfgLdAdd -r5 [1:2,1:3,1:4] WB Direct –a0 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除阵列 </span></span><br><span class="line">MegaCli -CfgLdDel -L1 –a0 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在线添加磁盘 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重建逻辑磁盘组 1 , RAID 级别是5，添加物理磁盘号 1:4。</span></span><br><span class="line">MegaCli -LDRecon -Start -r5 -Add -PhysDrv[1:4] -L1 -a0</span><br></pre></td></tr></table></figure><p><strong>注：</strong>重建完后，新添加的物理磁盘会自动处于重建(同步)状态，这个时候 <code>fdisk -l</code>是看不到阵列的空间变大的，只有在系统重启后才能看见。 </p><h3 id="查看阵列初始化信息"><a href="#查看阵列初始化信息" class="headerlink" title="查看阵列初始化信息"></a>查看阵列初始化信息</h3><ul><li><p>阵列创建完后，会有一个初始化同步块的过程，可以查看其进度。 </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -LDInit -ShowProg -LALL -aALL </span><br><span class="line"><span class="meta">#</span><span class="bash"> or 以动态可视化文字界面显示 </span></span><br><span class="line">MegaCli -LDInit -ProgDsply -LALL –aALL</span><br></pre></td></tr></table></figure></li><li><p>查看阵列后台初始化进度</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -LDBI -ShowProg -LALL -aALL </span><br><span class="line"><span class="meta">#</span><span class="bash"> or 以动态可视化文字界面显示 </span></span><br><span class="line">MegaCli -LDBI -ProgDsply -LALL -aALL</span><br></pre></td></tr></table></figure></li></ul><h3 id="设置磁盘缓存策略"><a href="#设置磁盘缓存策略" class="headerlink" title="设置磁盘缓存策略"></a>设置磁盘缓存策略</h3><p>缓存策略解释：</p><table><thead><tr><th style="text-align:left">代码</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">WT</td><td style="text-align:left">(Write through)</td></tr><tr><td style="text-align:left">WB</td><td style="text-align:left">(Write back)</td></tr><tr><td style="text-align:left">NORA</td><td style="text-align:left">(No read ahead)</td></tr><tr><td style="text-align:left">RA</td><td style="text-align:left">(Read ahead)</td></tr><tr><td style="text-align:left">ADRA</td><td style="text-align:left">(Adaptive read ahead)</td></tr><tr><td style="text-align:left">Cached</td><td style="text-align:left">-</td></tr><tr><td style="text-align:left">Direct</td><td style="text-align:left">-</td></tr></tbody></table><p>eg：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -LDSetProp WT|WB|NORA|RA|ADRA -L0 -a0 </span><br><span class="line"><span class="meta">#</span><span class="bash"> or </span></span><br><span class="line">MegaCli -LDSetProp -Cached|-Direct -L0 -a0 </span><br><span class="line"><span class="meta">#</span><span class="bash"> or </span></span><br><span class="line">- enable / disable disk cache </span><br><span class="line">MegaCli -LDSetProp -EnDskCache|-DisDskCache -L0 -a0</span><br></pre></td></tr></table></figure><h3 id="热备管理"><a href="#热备管理" class="headerlink" title="热备管理"></a>热备管理</h3><ul><li>创建热备</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> [1:5]----&gt;[E:S]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定第 5 块盘作为全局热备</span></span><br><span class="line">MegaCli -PDHSP -Set [-EnclAffinity] [-nonRevertible] -PhysDrv[1:5] -a0 </span><br><span class="line"><span class="meta">#</span><span class="bash"> eg：</span></span><br><span class="line">MegaCli -PDHSP   -Set   -Dedicated  -Array0  -physdrv[E:S] -a0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 为某个阵列指定专用热备 </span></span><br><span class="line">MegaCli -PDHSP -Set [-Dedicated [-Array1]] [-EnclAffinity] [-nonRevertible] -PhysDrv[1:5] -a0</span><br></pre></td></tr></table></figure><ul><li>删除热备</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -PDHSP -rmv -PhysDrv[1:5] -a0</span><br></pre></td></tr></table></figure><ul><li>将某块物理盘下线/上线 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下线</span></span><br><span class="line">MegaCli -PDOffline -PhysDrv [1:4] -a0 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 上线</span></span><br><span class="line">MegaCli -PDOnline -PhysDrv [1:4] -a0</span><br></pre></td></tr></table></figure></li></ul><p><strong>注：</strong>如果直接删除 RAID 而不操作热备，其局部热备会变为全局热备，而不是删除。</p><h2 id="管理篇"><a href="#管理篇" class="headerlink" title="管理篇"></a>管理篇</h2><ul><li><p>点亮指定硬盘（定位）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -PdLocate -start -physdrv[252:2] -a0</span><br></pre></td></tr></table></figure></li><li><p>查看 RAID 阵列中掉线的盘</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -pdgetmissing -a0</span><br></pre></td></tr></table></figure></li><li><p>替换坏掉的模块</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -pdreplacemissing -physdrv[12:10] -Array5 -row0 -a0</span><br></pre></td></tr></table></figure></li><li><p>手动开启 rebuid</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -pdrbld -start -physdrv[12:10] -a0</span><br></pre></td></tr></table></figure></li><li><p>查看 Megacli 的 log</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -FwTermLog dsply -a0 &gt; adp2.log</span><br></pre></td></tr></table></figure></li><li><p>关闭 Rebuild</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpAutoRbld -Dsbl -a0</span><br></pre></td></tr></table></figure></li><li><p>设置 rebuild 的速率</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -AdpSetProp RebuildRate -30 -a0</span><br></pre></td></tr></table></figure></li></ul><h3 id="foreign-管理"><a href="#foreign-管理" class="headerlink" title="foreign 管理"></a>foreign 管理</h3><p>创建 RAID 前, 需要检测是否具有<code>foreign</code>配置, 如果有但此时不需要保留 RAID 时需要清除 RAID 的 <code>foreign</code>状态。</p><ul><li><p>检测是否具有 <code>foreign</code> 配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -PDlist -aALL | grep "Foreign State"</span><br></pre></td></tr></table></figure></li><li><p>将标注为 <code>Foreign</code> 磁盘标注为<code>unconfigrue good</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -PDMakeGood -PhysDrv[32:5] -a0</span><br></pre></td></tr></table></figure></li><li><p>清除 <code>foreign</code> 配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -CfgForeign -Scan -a0</span><br></pre></td></tr></table></figure></li></ul><p><strong>注</strong>：一般以上两条都要执行才能清除 <code>foreign</code> 状态</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>磁盘状态 State<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">("Failed", "Online, Spun Up", "Online, Spun Down", "Unconfigured(bad)", "Unconfigured(good), Spun down", "Hotspare, Spun down", "Hotspare, Spun up" or "not Online")</span><br></pre></td></tr></table></figure></p><h2 id="Unsolved"><a href="#Unsolved" class="headerlink" title="Unsolved"></a>Unsolved</h2><ul><li>扩展 RAID（加盘）</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MegaCli -LDRecon -Start -r1 -Add -PhysDrv[252:1] -L1 -a0                                     </span><br><span class="line"><span class="meta">#</span><span class="bash"> 报错</span></span><br><span class="line">Failed to Start Reconstruction of Virtual Drive.</span><br><span class="line"></span><br><span class="line">FW error description: </span><br><span class="line"> The requested command has invalid arguments.  </span><br><span class="line"></span><br><span class="line">Exit Code: 0x03</span><br></pre></td></tr></table></figure><p><a href="http://en.community.dell.com/support-forums/servers/f/956/t/19531272" target="_blank" rel="noopener">参见这里 1</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.broadcom.com/site-search?q=megacli" target="_blank" rel="noopener">官方资源下载-broadcom</a></li><li><a href="https://techedemic.com/2014/08/07/dell-perclsi-megacli-how-to-install/" target="_blank" rel="noopener">Dell – PERC/LSI MegaCLI – How to install</a></li><li><a href="https://hwraid.le-vert.net/wiki/LSIMegaRAIDSAS#a3.1.megactl" target="_blank" rel="noopener">LSIMegaRAIDSAS</a></li><li><a href="http://zh.community.dell.com/techcenter/b/weblog/archive/2013/03/07/megacli-command-share" target="_blank" rel="noopener">DELL 磁盘阵列控制卡（RAID 卡）MegaCli 常用管理命令汇总</a></li><li><a href="http://blog.csdn.net/heart_2011/article/details/7254404" target="_blank" rel="noopener">MegaCli 命令总结 - CSDN 博客</a></li><li><a href="http://www.ha97.com/4073.html" target="_blank" rel="noopener">Linux 下查看 Raid 磁盘阵列信息的方法</a></li><li><a href="http://www.mamicode.com/info-detail-860128.html" target="_blank" rel="noopener">Megacli 常用命令</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
            <tag> Linux </tag>
            
            <tag> RAID </tag>
            
            <tag> MegaCli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在搭建 Hexo 中遇到的问题记录</title>
      <link href="/blog/2017-11-18/how-to-build-hexo-blog/"/>
      <url>/blog/2017-11-18/how-to-build-hexo-blog/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><img src="/images/v2-4b229aa661f0d337bd16390761963842.jpg" alt="Github loves Hexo"></p><p><br></p><p>在网络上搜索一天多才磕磕绊绊搭建好这个博客，⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄ 现在把过程中遇到的坑记录一下，希望可以给之后的同学们带来帮助。<br><a id="more"></a></p><h2 id="npm-包管理安装太慢怎么办"><a href="#npm-包管理安装太慢怎么办" class="headerlink" title="npm 包管理安装太慢怎么办"></a>npm 包管理安装太慢怎么办</h2><ul><li><p>临时使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm --registry https://registry.npm.taobao.org install express</span><br></pre></td></tr></table></figure></li><li><p>持久使用(更换源链接为淘宝源)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置后可通过下面方式来验证是否成功</span></span><br><span class="line">npm config get registry</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">npm info express</span><br></pre></td></tr></table></figure></li><li><p>通过 cnpm 使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"># 使用</span><br><span class="line">cnpm install expresstall express</span><br></pre></td></tr></table></figure></li></ul><p>还可以参考下面这个工具:</p><p><a href="https://segmentfault.com/a/1190000000473869" target="_blank" rel="noopener">nrm —— 快速切换 NPM 源 （附带测速功能）</a></p><h2 id="我有两台电脑-换电脑后如何重新发布博客"><a href="#我有两台电脑-换电脑后如何重新发布博客" class="headerlink" title="我有两台电脑/换电脑后如何重新发布博客"></a>我有两台电脑/换电脑后如何重新发布博客</h2><p>使用 Github 的 branch 功能建立两个分支，（如：master 和 hexo）设置 hexo 分支为默认分支，然后将博客后台配置文件全部<code>push</code>到该分支。master 端为使用<code>hexo d</code>命令发布分支。</p><p><strong>注：</strong>master 分支不能当作他用，只能作为 hexo 发布之后使用。</p><p>可以参考下面链接配置<br><a href="http://www.jianshu.com/p/beb8d611340a" target="_blank" rel="noopener">Hexo 博客从一台电脑迁移到其他电脑 - 简书</a></p><h2 id="如何设置腾讯公益为-404-页面"><a href="#如何设置腾讯公益为-404-页面" class="headerlink" title="如何设置腾讯公益为 404 页面"></a>如何设置腾讯公益为 404 页面</h2><p>以下是知乎网友给出的回答：</p><blockquote><p>直接在 source 根目录下创建自己的<code>404.html</code>即可。<del>但是自定义 404 页面仅对绑定顶级域名的项目才起作用。</del></p></blockquote><p>经我试验并不一定要绑定顶级域名才可以，使用官方给出的方案设置后并不能实现错误页 页面跳转到我们设置的 404 页面。<br>以下来自 github 网友在 issues 中的解释：</p><blockquote><p>你的站点(编注：二级域名即 Github)启用了 https，腾讯公益 404 的脚本是 http 协议，因此这段脚本被阻止了。</p></blockquote><p>解决的方法是将页面里的 script 换成如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/plain"</span> src=<span class="string">"http://www.qq.com/404/search_children.js"</span> charset=<span class="string">"utf-8"</span> homePageUrl=<span class="string">"/"</span> homePageName=<span class="string">"回到我的主页"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://qzone.qq.com/gy/404/data.js"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://qzone.qq.com/gy/404/page.js"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>经试验该方法还是会出现问题，使用 F12 审查元素出现报错信息。最后使用以下方案解决该问题:</p><p><a href="https://eason-yang.com/2016/08/06/set-tencent-lostchild-404-page-for-ssl/" target="_blank" rel="noopener">使腾讯 404 公益页面支持 HTTPS</a></p><p>目前存在问题：页面会有一个卡顿加载的过程，该页面没有适配移动端。</p><h2 id="Next-主题文章页如何设置多标签"><a href="#Next-主题文章页如何设置多标签" class="headerlink" title="Next 主题文章页如何设置多标签"></a>Next 主题文章页如何设置多标签</h2><p>在文章发布页（MARKDOWN 文件顶部）添加如下字段:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 在搭建Hexo中遇到的问题记录</span><br><span class="line"># 标签（注意短横杠后的空格）</span><br><span class="line">tags:</span><br><span class="line">- HOWTO</span><br><span class="line">- Hexo</span><br><span class="line">- Hexo-Next</span><br><span class="line">- etc.</span><br><span class="line">author: imoyao</span><br></pre></td></tr></table></figure><h2 id="如何给博客文章页添加音乐"><a href="#如何给博客文章页添加音乐" class="headerlink" title="如何给博客文章页添加音乐"></a>如何给博客文章页添加音乐</h2><p>可以用音乐网站的外链，但是一般外链是<code>&lt;iframe&gt;</code>，据说这个方法影响网站的 SEO。</p><p>下面我就隆重介绍一款 HTML5 音乐播放器：Aplayer。需要用到<code>hexo-tag-aplayer</code>插件。</p><p>切换到本地 Hexo 目录，运行：</p><p><code>npm install hexo-tag-aplayer@2.0.1</code></p><p>这里直接运行<code>npm install hexo-tag-aplayer</code>只会安装 2.0.0，该版本会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FATAL Cannot find module &apos;/Users/hechao/Documents/TechBlog/CniceToUpp/node_modules/hexo-tag-aplayer&apos;</span><br><span class="line">Error: Cannot find module &apos;/Users/hechao/Documents/TechBlog/CniceToUpp/node_modules/hexo-tag-aplayer&apos;</span><br></pre></td></tr></table></figure><p>作者给出来解决方案是用 2.0.1 版本。安装完成后，在需要添加音乐的地方加上：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#This is a example.</span><br><span class="line">&#123;% aplayer &quot;平凡之路&quot; &quot;朴树&quot; &quot;https://xxx.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3&quot; &quot;https://xxx.com/1.jpg&quot; &quot;autoplay&quot; %&#125;</span><br></pre></td></tr></table></figure><p>就会出现你想要的音乐啦。</p><p><div id="aplayer0" class="aplayer" style="margin-bottom: 20px;"></div><script>new APlayer({element: document.getElementById("aplayer0"),narrow: false,autoplay: true,showlrc: 0,music: {title: "蓝莲花",author: "许巍",url: "http://oh6j8wijn.bkt.clouddn.com/%E8%93%9D%E8%8E%B2%E8%8A%B1.mp3",pic: "http://oh6j8wijn.bkt.clouddn.com/133107859321201106e3c3ede9a13305.jpeg",}});</script>`</p><p>如果你想加入歌单，把上面的代码换成下面代码就行，参数的用法可以参照插件的使用说明。</p><p>```</p><h1 id="aplayer-删除（-）"><a href="#aplayer-删除（-）" class="headerlink" title="aplayer:删除（`）"></a>aplayer:删除（`）</h1><p>`<div id="aplayer1" class="aplayer" style="margin-bottom: 20px;"></div><script>var options = {"narrow":false,"autoplay":true,"showlrc":3,"mode":"random","music":[{"title":"平凡之路","author":"朴树","url":"http://xxx.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3","pic":"https://xxx.com/1.jpg","lrc":"http://og9ocpmwk.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.txt"},{"title":"野子","author":"苏运莹","url":"http://xxx.com/01%20%E9%87%8E%E5%AD%90.m4a","pic":"http://xxxx.com/%E9%87%8E%E5%AD%90.jpg","lrc":"https://xxx.com/%E9%87%8E%E5%AD%90.txt"}]};options.element = document.getElementById("aplayer1");new APlayer(options);</script>`<br>```plain</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p><code>material</code> 主题填坑</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">开始使用 - NexT 使用文档 </a></li><li><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">GitHub+Hexo 搭建个人网站详细教程</a></li><li><a href="http://tc9011.com/2016/12/24/hexo%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E3%80%81high%E4%B8%80%E4%B8%8B%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9D%91/" target="_blank" rel="noopener">hexo添加音乐、high一下及一些坑 | tc9011’s</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HOWTO </tag>
            
            <tag> Hexo </tag>
            
            <tag> Hexo-Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 中 exec()和 eval()的区别</title>
      <link href="/blog/2017-11-17/exec-vs-eval-in-Python/"/>
      <url>/blog/2017-11-17/exec-vs-eval-in-Python/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Python 动态执行字符串代码片段（也可以是文件）， 一般会用到 exec,eval。那么这两个方法有什么区别呢？</p><a id="more"></a><h2 id="exec-方法"><a href="#exec-方法" class="headerlink" title="exec 方法"></a>exec 方法</h2><p>注意：<code>exec</code> 是一个语法声明，不是一个函数。也就是说和<code>if</code>、<code>for</code>一样。</p><p>官方文档对于 exec 的解释</p><blockquote><p>This statement supports dynamic execution of Python code.</p></blockquote><p>exec 的第一个表达式可以是：</p><ol><li>代码字符串</li><li>文件对象</li><li>代码对象</li><li>tuple</li></ol><p>前面三种情况差不多，第四种比较特殊最后讲</p><p>如果忽略后面的可选表达式,exec 后面代码将在当前域执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=2</span><br><span class="line">&gt;&gt;&gt; exec &quot;a=1&quot;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p>如果在表达式之后使用 in 选项指定一个<code>dict</code>，它将作为<code>global</code>和<code>local</code>变量作用域<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=10 </span><br><span class="line">&gt;&gt;&gt; b=20 </span><br><span class="line">&gt;&gt;&gt; g=&#123;&apos;a&apos;:6,&apos;b&apos;:8&#125; </span><br><span class="line">&gt;&gt;&gt; exec &quot;global a;print a,b&quot; in g </span><br><span class="line">6 8</span><br></pre></td></tr></table></figure></p><p>如果<code>in</code>后详指定两个表达式，它们将分别用作<code>global</code>和<code>local</code>变量作用域<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=10 </span><br><span class="line">&gt;&gt;&gt; b=20 </span><br><span class="line">&gt;&gt;&gt; c=20 </span><br><span class="line">&gt;&gt;&gt; g=&#123;&apos;a&apos;:6,&apos;b&apos;:8&#125; </span><br><span class="line">&gt;&gt;&gt; l=&#123;&apos;b&apos;:9,&apos;c&apos;:10&#125; </span><br><span class="line">&gt;&gt;&gt; exec &quot;global a;print a,b,c&quot; in g,l </span><br><span class="line">6 9 10</span><br></pre></td></tr></table></figure></p><p>现在说下<code>tuple</code>的情况，这也是导致很多人误以为<code>exec</code>是一个函数的原因。</p><p>如果第一个表达式是<code>tuple</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec(expr, globals) #它等效于 `exec expr in globals`</span><br><span class="line"></span><br><span class="line">exec(expr, globals, locals) #它等效于  `exec expr in globals,locals`</span><br></pre></td></tr></table></figure><h2 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval()方法"></a>eval()方法</h2><p><code>eval</code>通常用来执行一个字符串表达式，并返回表达式的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eval(expression[, globals[, locals]])</span><br></pre></td></tr></table></figure><p>有三个参数，表达式字符串，globals 变量作用域，locals 变量作用域。 其中第二个和第三个参数是可选的。</p><p>如果忽略后面两个参数，则<code>eval</code>在当前作用域执行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=1 </span><br><span class="line">&gt;&gt;&gt; eval(&quot;a+1&quot;) </span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>如果指定 globals 参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=1 </span><br><span class="line">&gt;&gt;&gt; g=&#123;&apos;a&apos;:10&#125; </span><br><span class="line">&gt;&gt;&gt; eval(&quot;a+1&quot;,g) </span><br><span class="line">11</span><br></pre></td></tr></table></figure></p><p>如果指定<code>locals</code>参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a=10 </span><br><span class="line">&gt;&gt;&gt; b=20 </span><br><span class="line">&gt;&gt;&gt; c=20 </span><br><span class="line">&gt;&gt;&gt; g=&#123;&apos;a&apos;:6,&apos;b&apos;:8&#125; </span><br><span class="line">&gt;&gt;&gt; l=&#123;&apos;b&apos;:9,&apos;c&apos;:10&#125; </span><br><span class="line">&gt;&gt;&gt; eval(&quot;a+b+c&quot;,g,l) </span><br><span class="line">25</span><br></pre></td></tr></table></figure></p><p>如果要严格限制<code>eval</code>执行，可以设置<code>globals</code>为<code>__builtins__</code>,这样 这个表达式只可以访问<code>__builtin__</code> module。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">exec &apos;print(&quot;hello&quot;)&apos;   #支持str的表达式动态代码执行    &gt;&gt;hello</span><br><span class="line">exec (&apos;a = 3*4&apos;)</span><br><span class="line">print a     # &gt;&gt;12</span><br><span class="line">b = eval(&apos;3*4&apos;)     #不支持表达式 有返回值</span><br><span class="line">print b     # &gt;&gt;12</span><br></pre></td></tr></table></figure><p>参考来源：</p><p><a href="http://www.coolpython.com/index.php?aid=12" target="_blank" rel="noopener">python 的 exec、eval 详解 - 疯狂奔跑的猪</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>佛与姑娘</title>
      <link href="/blog/2017-11-11/choose-Buddha-or-gril/"/>
      <url>/blog/2017-11-11/choose-Buddha-or-gril/</url>
      
        <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>青灯，古佛。喝酒、吃肉、泡姑娘。</p><p>我盘坐参了你这么长的时间，却总不见你发言。</p><p>你说五蕴皆空。可谁的心里还不藏着一个不穿衣服的姑娘；你说观法自在，可那姑娘夜夜钻我的被窝，又让我如何是好？<br><a id="more"></a></p><p><br></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=28308561&auto=1&height=32"></iframe><p><br></p><p>我想了又想，还是把她办了吧。</p><p><br></p><p>你看这苍生万物，忙碌地生，忙碌地死。你笑他们无知无力，我仰你伟大慈悲。你关照那么多的生死，我却只关心自己的琐碎。</p><p>索性我也坦胸露乳，我也装它个四大皆空。</p><p><br></p><p>于是，你是不是也该教我个蒙事的法门？一念一执，念她个死心塌地，执她个执迷不悟。</p><p>管他欢乐还是痛苦，管他喜悦还是悲伤。</p><p>花间一壶酒，对着月亮喝个死去活来，摸着姑娘的大腿喃喃道：卧槽，真是难得糊涂。</p><p><br></p><p>糊涂着，我抱着那姑娘在床单上滚来又滚去。</p><p>你掐着手印笑而不语地看着我们手淫。</p><p>我想着等头发长长了也去烫一头如你一样五蕴皆空的头发，披上一身袈裟和姑娘拉着手私奔——也还是在你的手掌心里游荡。</p><p><br></p><p>说真的，如果你爱我就赶快带我离开。</p><p>其它的东西都是扯淡，扯多了你就是耍流氓。</p><p><br></p><p>谁说释迦老爷子不耍流氓？那是他自己说的。</p><p><br></p><p>我把木鱼敲碎，把蒲团坐穿，在梦里把你摸了一遍又一遍。</p><p>我脱了这身衣服就已不再是我，我穿上了衣服自己却怎么也找不到了。</p><p><br></p><p>一时，佛在舍卫国，破衣烂钵：“可有残羹施舍？”</p><p>一个说：“去去去，哪里来的叫花，这里人人都忙着寂寞，哪有闲工夫理你。”</p><p>佛说：“寂寞这个东西，多半是姑娘闹的。可到哪去找个姑娘，不可说，不可说。”</p><p><br></p><p>说到头来还是说到姑娘。</p><p>我就说寂寞就他妈是个光着大腿的姑娘，让你看着又偏偏不让你摸。</p><p>看得你心也痒痒嘴也痒痒，总憋着法地想一些污言秽语来挑逗她。</p><p>可越是挑逗她就离你越近，离你越近就越不让你摸。</p><p><br></p><p>我觉得，这很操蛋。</p><p><br></p><p>佛说，这就是法啊，你明知它是真的却总也抓不住，你分明看不到却总在你身边转。逗着你，馋着你，说一些恼人的话来勾引你，惹你生气，惹你欢喜。</p><p><br></p><p>我说，这分明是耍流氓。</p><p>佛说，对呀，就是耍流氓，你把恶根丢了，把执念丢了，把妄想丢了，把姑娘丢了，脱光了衣服站街上，就立地成佛了。</p><p><br></p><p>我脱光了衣服站在街上，来了两个漂亮的女警察问我在做什么。</p><p>我说，我立地成佛，然后度你们出苦厄。</p><p>她们非要把我抓走，我说我<strong>日</strong>你们老母！！！</p><p><br></p><p>佛笑了，坐在远远的云端，莲花台上。</p><p>我说这不科学，众生太执，姑娘又太美，教人怎么度，怎么个无欲无求。</p><p>佛打了个哈欠，就没再说什么。</p><p><br></p><p>我觉得这有些扯，但还是耐着性子思索一些事情。</p><p>最后我决定，还是把那个勾引我的小娘们给办了。</p><p><br></p><p>办她个五蕴皆空，度她出寂寞的苦厄。</p><p><br></p>]]></content>
      
      
      <categories>
          
          <category> 悦读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美文 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
