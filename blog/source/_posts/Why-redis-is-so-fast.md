---
title: 为什么Redis这么快？
date: 2019-09-19 21:05:31
tags:
- Redis
- 数据库
toc: true
---
## 太长不看版

1. Redis是基于内存的访问，内存的读写速度非常快；

2. Redis是单线程的模型。保证了每个操作的原子性，省去了很多上下文切换线程的时间以及竞态而产生的消耗；

3. Redis使用多路复用技术，可以处理并发的连接。非阻塞IO内部实现采用epoll，采用了epoll+自己实现的简单的事件轮询（event loop）框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。

4. 数据结构。Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。

## 为什么Redis使用单线程？

因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案。

### 详细原因

1. 不需要各种锁的性能消耗

    Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除
    
    一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。
    
    总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。

2. 单线程多进程集群方案

    单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。
    
    所以单线程、多进程的集群不失为一个时髦的解决方案。

3. CPU消耗

    采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。
    
## 但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？
    
可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。

## Redis单线程的优劣势

1. 单进程单线程优势

    - 代码更清晰，处理逻辑更简单；
    - 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
    - 不存在多进程或者多线程导致的切换而消耗CPU； 
  
2. 单进程单线程弊端
    无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；
    
## IO多路复用技术 

Redis 采用网络IO多路复用技术来保证在多连接的时候，系统的高吞吐量。

这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路I/O复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。

## 参考链接

- [Redis为什么是单线程、及高并发快的大原因详解](https://blog.csdn.net/u011663149/article/details/85307615)
- [Redis 为什么快？](https://www.jianshu.com/p/3d54131ee94c)